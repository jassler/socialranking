[{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"literature cooperative games, notion power index [1–3] widely studied analyze “influence” individuals taking account ability force decision within groups coalitions. practical situations, however, information concerning strength coalitions hardly quantifiable. , attempt numerically represent influence groups individuals clashes complex multi-attribute nature problem seems realistic represent collective decision-making mechanisms using ordinal coalitional framework based two main ingredients: binary relation groups coalitions ranking individuals. main objective package socialranking provide answers general problem compare elements finite set \\(N\\) given ranking elements power-set (set possible subsets \\(N\\)). , package socialranking implements portfolio solutions recent literature social rankings [4–11].","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"quick-start","dir":"Articles","previous_headings":"Introduction","what":"Quick start","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"power relation (.e, ranking subsets finite set \\(N\\); see Section PowerRelation objects formal definition) can constructed using functions PowerRelation() .PowerRelation(). Functions used analyze given PowerRelation object can grouped three main categories: Comparison functions, comparing two elements; Score functions, calculating scores element; Ranking functions, creating SocialRanking objects. Comparison score functions often used evaluate social ranking solution (see section PowerRelation objects formal definition). Listed prominent functions solutions introduced aforementioned papers. functions may called follows. Lastly, incidence matrix given coalitions can constructed using powerRelationMatrix(pr) .relation(pr) relations package [12]. incidence matrix may displayed using relations::relation_incidence().","code":"library(socialranking) PowerRelation(list(list(c(1,2)), list(1, c()), list(2))) ## 12 > (1 ~ {}) > 2 as.PowerRelation(\"12 > 1 ~ {} > 2\") ## 12 > (1 ~ {}) > 2 as.PowerRelation(\"ab > a ~ {} > b\") ## ab > (a ~ {}) > b as.PowerRelation(list(c(1,2), 1, c(), 2)) ## 12 > 1 > {} > 2 as.PowerRelation(list(c(1,2), 1, c(), 2), comparators = c(\">\", \"~\", \">\")) ## 12 > (1 ~ {}) > 2 pr <- as.PowerRelation(\"ab > abc ~ ac ~ bc > a ~ c > {} > b\")  # a dominates b, but b does not dominate a c(dominates(pr, \"a\", \"b\"),   dominates(pr, \"b\", \"a\")) ## [1]  TRUE FALSE # calculate cumulative scores scores <- cumulativeScores(pr) # show score of element a scores$a ## [1] 1 3 4 4 4 # performing a bunch of rankings lexcelRanking(pr) ## a > b > c L1Ranking(pr) ## a > b > c dualLexcelRanking(pr) ## a > c > b copelandRanking(pr) ## a > b ~ c kramerSimpsonRanking(pr) ## a > b ~ c ordinalBanzhafRanking(pr) ## a > c > b rel <- relations::as.relation(pr) rel ## A binary relation of size 8 x 8. relations::relation_incidence(rel) ## Incidences: ##     ab ​abc ​​ac ​​​bc ​​​​a ​​​​​c ​​​​​​{} ​​​​​​​b ## ab   1   1  1  1 1 1  1 1 ## ​abc  0   1  1  1 1 1  1 1 ## ​​ac   0   1  1  1 1 1  1 1 ## ​​​bc   0   1  1  1 1 1  1 1 ## ​​​​a    0   0  0  0 1 1  1 1 ## ​​​​​c    0   0  0  0 1 1  1 1 ## ​​​​​​{}   0   0  0  0 0 0  1 1 ## ​​​​​​​b    0   0  0  0 0 0  0 1"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"sec:prelim","dir":"Articles","previous_headings":"","what":"PowerRelation objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"first introduce basic definitions binary relations. Let \\(X\\) set. set \\(R \\subseteq X \\times X\\) said binary relation \\(X\\). two elements \\(x, y \\X\\), \\(xRy\\) refers relation, formally means \\((x,y) \\R\\). binary relation \\((x,y) \\R\\) said reflexive, \\(x \\X, xRx\\), transitive, \\(x, y, z \\X, xRy\\) \\(yRz \\Rightarrow xRz\\), total, \\(x,y \\X, x \\neq y \\Rightarrow xRy\\) \\(yRx\\), symmetric, \\(x,y \\X,xRy \\Leftrightarrow yRx\\), asymmetric, \\(x,y \\X,(x,y) \\R \\Rightarrow (y,x) \\notin R\\), antisymmetric, \\(x,y \\X,xRy \\cap yRx \\Rightarrow x=y\\). preorder defined reflexive transitive relation. total, called total preorder. Additionally antisymmetric, called linear order. Let \\(N = \\{1, 2, \\dots, n\\}\\) finite set elements, sometimes also called players. \\(p \\\\{1, \\ldots, 2^n\\}\\), let \\(\\mathcal{P} = \\{S_1, S_2, \\dots, S_{p}\\}\\) set coalitions \\(S_i \\subseteq N\\) \\(\\\\{1, \\ldots, p\\}\\). Thus \\(\\mathcal{P} \\subseteq 2^N\\), \\(2^N\\) denotes power set \\(N\\), set subsets coalitions \\(N\\). \\(\\mathcal{T}(N)\\) denotes set total preorders \\(N\\), \\(\\mathcal{T}(\\mathcal{P})\\) set total preorders \\(\\mathcal{P}\\). single total preorder \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) said power relation. given power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) \\(\\mathcal{P} \\subseteq 2^N\\), symmetric part denoted \\(\\sim\\) (.e., \\(S \\sim T\\) \\(S \\succsim T\\) \\(T \\succsim S\\)), whereas asymmetric part denoted \\(\\succ\\) (.e., \\(S \\succ T\\) \\(S \\succsim T\\) \\(T \\succsim S\\)). terms, \\(S \\sim T\\) say \\(S\\) indifferent \\(T\\), whereas \\(S \\succ T\\) say \\(S\\) strictly better \\(T\\). Lastly, given power relation form \\(S_1 \\succsim S_2 \\succsim \\ldots \\succsim S_m\\), coalitions indifferent one another can grouped equivalence classes \\(\\sum_i\\) get quotient order \\(\\sum_1 \\succ \\sum_2 \\succ \\ldots \\succ \\sum_m\\). Let \\(N=\\{1,2\\}\\) two players corresponding power set \\(2^N = \\{\\{1,2\\}, \\{1\\}, \\{2\\}, \\emptyset\\}\\). following power relation given: \\[ \\begin{array}{rrrr} \\succsim \\ =\\ \\{(\\{1,2\\},\\{1,2\\}), & (\\{1,2\\},\\{2\\}), & (\\{1,2\\},\\emptyset), & (\\{1,2\\},\\{1\\}),\\hphantom{\\}}\\\\ & (\\{2\\}, \\{2\\}), & (\\{2\\}, \\emptyset), & \\hphantom{1,}(\\{2\\}, \\{1\\}),\\hphantom{\\}}\\\\ & (\\emptyset, \\emptyset), & (\\emptyset, \\{2\\}), & (\\emptyset, \\{1\\}),\\hphantom{\\}}\\\\ & & & (\\{1\\}, \\{1\\})\\hphantom{,}\\} \\end{array} \\] power relation can rewritten consecutive order : \\(\\{1,2\\} \\succ \\{2\\} \\sim \\emptyset \\succ \\{1\\}\\). quotient order formed three equivalence classes \\(\\sum_1 = \\{\\{1,2\\}\\}, \\sum_2 = \\{\\{2\\}, \\emptyset\\},\\) \\(\\sum_3 = \\{\\{1\\}\\}\\); quotient order \\(\\succsim\\) \\(\\{\\{1,2\\}\\} \\succ \\{\\{2\\}, \\emptyset\\} \\succ \\{\\{1\\}\\}\\). Note way set \\(\\succsim\\) presented example somewhat deliberate better visualize occurring symmetries asymmetries. also lets us neatly represent power relation form incidence matrix.","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"creating-powerrelation-objects","dir":"Articles","previous_headings":"PowerRelation objects","what":"Creating PowerRelation objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"power relation socialranking package defined reflexive, transitive total. designing package deemed logical coalitions specified consecutive order, seen Example 1. coalition order split either \">\" (left side strictly better) \"~\" (two coalitions indifferent one another). following code chunk shows power relation Example 1 correlating PowerRelation object can constructed. Notice coalitions \\(\\{1,2\\}\\) written 12 improve readability. Similarly, passing string function .PowerRelation() saves typing user’s end interpreting character coalition separate element. Note spaces function ignored. compact notation done PowerRelation objects every element one digit one character long. case, curly braces commas added needed. may spotted \"SingleCharElements\" class missing class(prLong) class(pr). \"SingleCharElements\" influences coalitions printed. removed class(pr), output include curly braces commas displayed prLong. Internally PowerRelation list four attributes. coalitions formally defined sets, meaning order doesn’t matter element unique, package tries stay flexible. , coalitions sorted initialization, duplicate elements removed.","code":"library(socialranking) pr <- PowerRelation(list(   list(c(1,2)),   list(2, c()),   list(1) )) pr ## 12 > (2 ~ {}) > 1 class(pr) ## [1] \"PowerRelation\"      \"SingleCharElements\" as.PowerRelation(\"12 > 2~{} > 1\") ## 12 > (2 ~ {}) > 1 prLong <- PowerRelation(list(   list(c(\"Alice\", \"Bob\")),    list(\"Bob\", c()),   list(\"Alice\") )) prLong ## {Alice, Bob} > ({Bob} ~ {}) > {Alice} class(prLong) ## [1] \"PowerRelation\" class(pr) <- class(pr)[-which(class(pr) == \"SingleCharElements\")] pr ## {1, 2} > ({2} ~ {}) > {1} prAtts <- PowerRelation(list(   list(c(2,2,1,1,2)),   list(c(2,1), c()) )) ## Warning in createLookupTables(equivalenceClasses): Found 1 coalition that contain elements more than once. ##     - 1, 2 in the coalition {1, 1, 2, 2, 2} prAtts ## 11222 > (12 ~ {}) prAtts$elements ## [1] 1 2 prAtts$coalitionLookup(c(1,2)) ## [1] 2 prAtts$coalitionLookup(c(2,1)) ## [1] 2 prAtts$coalitionLookup(c(2,1,2,1,2)) ## [1] 1 prAtts$elementLookup(2) ## [[1]] ## [1] 1 1 ##  ## [[2]] ## [1] 1 1 ##  ## [[3]] ## [1] 1 1 ##  ## [[4]] ## [1] 2 1"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"manipulating-powerrelation-objects","dir":"Articles","previous_headings":"PowerRelation objects","what":"Manipulating PowerRelation objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"strongly discouraged directly manipulate PowerRelation objects, attributes tightly coupled. require updates multiple places. Instead, advisable simply create new PowerRelation objects. permutate order equivalence classes, possible take equivalence classes $eqs use vector indexes move around. permutating individual coalitions, using .PowerRelation.list() may convenient since doesn’t require nested list indexing.","code":"pr <- as.PowerRelation(\"12 > (1 ~ {}) > 2\") PowerRelation(pr$eqs[c(2, 3, 1)]) ## (1 ~ {}) > 2 > 12 PowerRelation(rev(pr$eqs)) ## 2 > (1 ~ {}) > 12 coalitions <- unlist(pr$eqs, recursive = FALSE) compares <- c(\">\", \"~\", \">\") as.PowerRelation(coalitions[c(2,1,3,4)], comparators = compares) ## 1 > (12 ~ {}) > 2 # notice that the length of comparators does not need to match # length(coalitions)-1 as.PowerRelation(rev(coalitions), comparators = c(\"~\", \">\")) ## (2 ~ {}) > (1 ~ 12) # not setting the comparators parameter turns it into a linear order as.PowerRelation(coalitions) ## 12 > 1 > {} > 2"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"appendmissingcoalitions","dir":"Articles","previous_headings":"PowerRelation objects > Manipulating PowerRelation objects","what":"appendMissingCoalitions()","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). may included possible coalitions, \\(\\mathcal{P} \\subset 2^N, \\mathcal{P} \\neq 2^N\\). appendMissingCoalitions() appends missing coalitions \\(2^N - \\mathcal{P}\\) single equivalence class end power relation.","code":"pr <- PowerRelation(list(   list(c(\"AT\", \"DE\"), \"FR\"),   list(\"DE\"),   list(c(\"AT\", \"FR\"), \"AT\") )) pr ## ({AT, DE} ~ {FR}) > {DE} > ({AT, FR} ~ {AT}) # since we have 3 elements, the super set 2^N should include 8 coalitions appendMissingCoalitions(pr) ## ({AT, DE} ~ {FR}) > {DE} > ({AT, FR} ~ {AT}) > ({AT, DE, FR} ~ {DE, FR} ~ {})"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"makepowerrelationmonotonic","dir":"Articles","previous_headings":"PowerRelation objects > Manipulating PowerRelation objects","what":"makePowerRelationMonotonic()","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) monotonic \\[ S \\succsim T \\quad \\Rightarrow \\quad T \\subset S \\] \\(S, T \\subseteq N\\). terms, given monotonic power relation, coalition, subsets ranked higher. makePowerRelationMonotonic() turns potentially non-monotonic power relation monotonic one moving (optionally) adding missing coalitions \\(2^N - \\mathcal{P}\\) corresponding equivalence classes.","code":"pr <- as.PowerRelation(\"a > b > c ~ ac > abc\") makePowerRelationMonotonic(pr) ## (abc ~ ab ~ ac ~ a) > (bc ~ b) > c makePowerRelationMonotonic(pr, addMissingCoalitions = FALSE) ## (abc ~ ac ~ a) > b > c # notice how an empty coalition in some equivalence class # causes all remaining coalitions to be moved there makePowerRelationMonotonic(as.PowerRelation(\"ab > c > {} > abc > a > b\")) ## (abc ~ ab) > (ac ~ bc ~ c) > (a ~ b ~ {})"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"creating-power-sets","dir":"Articles","previous_headings":"PowerRelation objects","what":"Creating power sets","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"number elements \\(n\\) increases, number possible coalitions increases \\(|2^N| = 2^n\\). createPowerset() convenient function creates power set \\(2^N\\) can used call PowerRelation .PowerRelation(), also formats function call way makes easy rearrange ordering coalitions. RStudio offers shortcuts Alt+Alt+(Option+Option+MacOS) move one multiple lines code (see fig. ). default, createPowerset() returns power set form list. list can passed directly .PowerRelation() create linear order.","code":"createPowerset(   c(\"a\", \"b\", \"c\"),   result = \"print\" ) ## as.PowerRelation(\" ##   abc ##   > ab ##   > ac ##   > bc ##   > a ##   > b ##   > c ##   > {} ## \") ps <- createPowerset(1:2, includeEmptySet = FALSE) ps ## [[1]] ## [1] 1 2 ##  ## [[2]] ## [1] 1 ##  ## [[3]] ## [1] 2 as.PowerRelation(ps) ## 12 > 1 > 2 # equivalent PowerRelation(list(ps)) ## (12 ~ 1 ~ 2) as.PowerRelation(createPowerset(letters[1:4])) ## abcd > abc > abd > acd > bcd > ab > ac > ad > bc > bd > cd > a > b > c > d > {}"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"generating-powerrelation-objects","dir":"Articles","previous_headings":"PowerRelation objects","what":"Generating PowerRelation objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"ease experimentation, possible power relations created automatically given list coalitions. Either, create random power relations using generateRandomPowerRelation(), generate sequence possible power relations powerRelationGenerator(). former, one may also specify generated power relation linear order (, ~ strict > relations) whether power relation monotonic (, \\(\\{1\\} \\succ \\{1,2\\}\\) monotonic \\(\\{1\\} \\subset \\{1,2\\}\\)). looping possible power relations, powerRelationGenerator() returns generator function , called repeatedly, returns one unique PowerRelation object . permutations exhausted, NULL returned. Permutations power relations can split two parts: generating partitions, , generating differently sized equivalence classes, moving coalitions partitions. code example , started single partition size three, wherein coalitions considered equally preferable. end, reached maximum number partitions, coalition put inside equivalence class size 1. partition generation can reversed, first receive linear power relations. Notice “moving coalitions” part reversed, order partitions come . Similarly, also able skip current partition. Note: number possible power relations grows tremendously fast number coalitions rises. get number, first consider many ways \\(n\\) coalitions can split \\(k\\) partitions, also known Stirling number second kind, \\[ S(n,k) = \\frac{1}{k!}\\ \\sum_{j=0}^k (-1)^j \\binom{k}{j}(k-j)^n. \\] number possible partitions given \\(n\\) coalitions known Bell number (see also numbers::bell()), \\[ B_n = \\sum_{j=0}^k S(n,k). \\] Given set coalitions \\(\\mathcal{P} \\2^N\\), number total preorders \\(\\mathcal{T}(\\mathcal{P})\\) \\[ |\\mathcal{T}(\\mathcal{P})| = \\sum_{k=0}^{|\\mathcal{P}|} k!\\ *\\ S(|\\mathcal{P}|, k) \\]","code":"set.seed(1) coalitions <- createPowerset(1:3) generateRandomPowerRelation(coalitions) ## 13 > (2 ~ 12) > {} > (1 ~ 123) > 23 > 3 generateRandomPowerRelation(coalitions) ## ({} ~ 1 ~ 2 ~ 12 ~ 123) > 3 > 13 > 23 generateRandomPowerRelation(coalitions, linearOrder = TRUE) ## 12 > 2 > 123 > 23 > 13 > 3 > {} > 1 generateRandomPowerRelation(coalitions, monotonic = TRUE) ## (123 ~ 23 ~ 12 ~ 13 ~ 1) > (2 ~ 3 ~ {}) generateRandomPowerRelation(coalitions, linearOrder = TRUE, monotonic = TRUE) ## 123 > 23 > 12 > 2 > 13 > 1 > 3 > {} coalitions <- list(c(1,2), 1, 2) gen <- powerRelationGenerator(coalitions) while(!is.null(pr <- gen())) {   print(pr) } ## (12 ~ 1 ~ 2) ## (12 ~ 1) > 2 ## (12 ~ 2) > 1 ## (1 ~ 2) > 12 ## 12 > (1 ~ 2) ## 1 > (12 ~ 2) ## 2 > (12 ~ 1) ## 12 > 1 > 2 ## 12 > 2 > 1 ## 1 > 12 > 2 ## 2 > 12 > 1 ## 1 > 2 > 12 ## 2 > 1 > 12 gen <- powerRelationGenerator(coalitions, startWithLinearOrder = TRUE) while(!is.null(pr <- gen())) {   print(pr) } ## 12 > 1 > 2 ## 12 > 2 > 1 ## 1 > 12 > 2 ## 2 > 12 > 1 ## 1 > 2 > 12 ## 2 > 1 > 12 ## 12 > (1 ~ 2) ## 1 > (12 ~ 2) ## 2 > (12 ~ 1) ## (12 ~ 1) > 2 ## (12 ~ 2) > 1 ## (1 ~ 2) > 12 ## (12 ~ 1 ~ 2) gen <- powerRelationGenerator(coalitions) # partition 3  gen <- generateNextPartition(gen) # partition 2+1  gen <- generateNextPartition(gen) # partition 1+2 gen() ## 12 > (1 ~ 2)"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"socialranking-objects","dir":"Articles","previous_headings":"","what":"SocialRanking Objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"main goal socialranking package rank elements based given power ranking. formally try map \\(R: \\mathcal{T}(\\mathcal{P}) \\rightarrow \\mathcal{T}(N)\\), associating power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) total preorder \\(R(\\succsim)\\) (\\(R^\\succsim\\)) elements \\(N\\). context \\(R^\\succsim j\\) tells us , given power relation \\(\\succsim\\) applying social ranking solution \\(R(\\succsim)\\), \\(\\) ranked higher equal \\(j\\). , > ~ also denote asymmetric symmetric part social ranking, respectively, \\(\\) > \\(j\\) indicating \\(\\) strictly better \\(j\\), whereas \\(\\) ~ \\(j\\), \\(\\) indifferent \\(j\\). literature, \\(^\\succsim j\\) \\(P^\\succsim j\\) often used denote symmetric asymmetric part, respectively. \\(^\\succsim j\\) therefore means \\(R^\\succsim j\\) \\(j R^\\succsim \\), whereas \\(P^\\succsim j\\) implies \\(R^\\succsim j\\) \\(j R^\\succsim j\\). section 3.1 show general SocialRanking object can constructed using doRanking function. following sections, introduce notion dominance[4], cumulative dominance[13] CP-Majority comparison[6] lets us compare two elements diving social ranking solutions Ordinal Banzhaf Index[5], Copeland-like Kramer-Simpson-like methods[10], lastly Lexicographical Excellence Solution[9] (Lexcel) Dual Lexicographical Excellence solution[14] (Dual Lexcel). Let \\(\\{,b\\} \\succ (\\{,c\\} \\sim \\{b,c\\}) \\succ (\\{\\} \\sim \\{c\\}) > (\\{,b,c\\} \\sim \\emptyset) \\succ \\{b\\}\\) power ranking. Using following social ranking solutions, get: > b > c lexcelRanking, L1Ranking L2Ranking > c > b dualLexcelRanking, ordinalBanzhafRanking LPSRanking > b ~ c copelandRanking kramerSimpsonRanking ~ c > b ordinalBanzhafRanking LPRanking","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"creating-socialranking-objects","dir":"Articles","previous_headings":"SocialRanking Objects","what":"Creating SocialRanking objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"SocialRanking object represents total preorder \\(\\mathcal{T}(N)\\) elements \\(N\\). Internally saved list vectors, containing players indifferent one another. somewhat similar equivalenceClasses attribute PowerRelation objects. function doRanking offers generic way creating SocialRanking objects. Given sortable vector list scores determines power relation players, names elements determined names() attribute scores. Hence, PowerRelation object necessary create SocialRanking object. working types sorted (.e., lists), function can passed compare parameter allows comparisons arbitrary elements. function must take two parameters (.e., b) return numeric value based comparison: compare(,b) > 0: scores higher b, compare(,b) < 0: scores lower b, compare(,b) == 0: b equivalent.","code":"# we define some arbitrary score vector where \"a\" scores highest. # \"b\" and \"c\" both score 1, thus they are indifferent. scores <- c(a = 100, b = 1, c = 1) doRanking(scores) ## a > b ~ c # we can also tell doRanking to punish higher scores doRanking(scores, decreasing = FALSE) ## b ~ c > a scores <- list(a = c(3, 3, 3), b = c(2, 3, 2), c = c(7, 0, 2)) doRanking(scores, compare = function(a, b) sum(a) - sum(b)) ## a ~ c > b # a and c are considered to be indifferent, because their sums are the same  doRanking(scores, compare = function(a,b) sum(a) - sum(b), decreasing = FALSE) ## b > a ~ c"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"comparison-functions","dir":"Articles","previous_headings":"SocialRanking Objects","what":"Comparison Functions","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Comparison functions compare two elements given power relation. offer social ranking solution. However cases CP-Majority comparison, comparison functions may used construct social ranking solution particular cases.","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ch:dominance","dir":"Articles","previous_headings":"SocialRanking Objects > Comparison Functions","what":"Dominance","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"(Dominance [4]) Given power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) two elements \\(,j \\N\\), \\(\\) dominates \\(j\\) \\(\\succsim\\) \\(S \\cup \\{\\} \\succsim S \\cup \\{j\\}\\) \\(S \\2^{N\\setminus \\{,j\\}}\\). \\(\\) also strictly dominates \\(j\\) exists \\(S \\2^{N\\setminus \\{,j\\}}\\) \\(S \\cup \\{\\} \\succ S \\cup \\{j\\}\\). implication every coalition \\(\\) \\(j\\) can join, \\(\\) least positive impact \\(j\\). function dominates(pr, e1, e2) returns logical value TRUE e1 dominates e2, else FALSE. Note e1 dominating e2 indicate e2 dominates e1, imply e1 indifferent e2. \\(S \\2^{N \\setminus \\{,j\\}}\\), can compare \\(S \\cup \\{\\} \\succsim S \\cup \\{j\\}\\) \\(S \\cup \\{\\}\\) \\(S \\cup \\{j\\}\\) take part power relation. Additionally, \\(S = \\emptyset\\), also want compare \\(\\{\\} \\succsim \\{j\\}\\). situations however comparison singletons desired. reason parameter includeEmptySet can set FALSE \\(\\emptyset \\cup \\{\\} \\succsim \\emptyset \\cup \\{j\\}\\) considered CP-Majority comparison.","code":"pr <- as.PowerRelation(\"3 > 1 > 2 > 12 > 13 > 23\")  # 1 clearly dominates 2 dominates(pr, 1, 2) ## [1] TRUE dominates(pr, 2, 1) ## [1] FALSE # 3 does not dominate 1, nor does 1 dominate 3, because # {}u3 > {}u1, but 2u1 > 2u3 dominates(pr, 1, 3) ## [1] FALSE dominates(pr, 3, 1) ## [1] FALSE # an element i dominates itself, but it does not strictly dominate itself # because there is no Sui > Sui dominates(pr, 1, 1) ## [1] TRUE dominates(pr, 1, 1, strictly = TRUE) ## [1] FALSE pr <- as.PowerRelation(\"ac > bc ~ b > a ~ abc > ab\")  # FALSE because ac > bc, whereas b > a dominates(pr, \"a\", \"b\") ## [1] FALSE # TRUE because ac > bc, ignoring b > a comparison dominates(pr, \"a\", \"b\", includeEmptySet = FALSE) ## [1] TRUE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ch:cumul","dir":"Articles","previous_headings":"SocialRanking Objects > Comparison Functions","what":"Cumulative Dominance","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"comparing two players \\(,j \\N\\), instead looking particular coalitions \\(S \\2^{N \\setminus \\{,j\\}}\\) can join, look many stronger coalitions can form point. property originally introduced [13] regular dominance axiom. given power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) corresponding quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), power player \\(\\) given vector \\(\\textrm{Score}_\\textrm{Cumul}() \\\\mathbb{N}^m\\) cumulatively sum amount times \\(\\) appears \\(\\sum_k\\) index \\(k\\). (Cumulative Dominance Score) Given power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), cumulative score vector \\(\\textrm{Score}_\\textrm{Cumul}() \\\\mathbb{N}^m\\) element \\(\\N\\) given : \\[\\begin{equation}     \\textrm{Score}_\\textrm{Cumul}() = \\Big( \\sum_{t=1}^k |\\{S \\\\textstyle \\sum_t : \\S\\}|\\Big)_{k \\\\{1, \\dots, m\\}} \\end{equation}\\] (Cumulative Dominance) Given two elements \\(,j \\N\\), \\(\\) cumulatively dominates \\(j\\) \\(\\succsim\\), \\(\\textrm{Score}_\\textrm{Cumul}()_k \\geq \\textrm{Score}_\\textrm{Cumul}(j)_k\\) \\(k \\\\{1, \\dots, m\\}\\). \\(\\) also strictly cumulatively dominates \\(j\\) exists \\(k\\) \\(\\textrm{Score}_\\textrm{Cumul}()_k > \\textrm{Score}_\\textrm{Cumul}(j)_k\\). given PowerRelation object pr two elements e1 e2, cumulativeScores(pr) returns vectors described definition 2 element, cumulativelyDominates(pr, e1, e2) returns TRUE FALSE based definition 3. Similar dominance property previous section, two elements dominating one indicate indifferent.","code":"pr <- as.PowerRelation(\"ab > (ac ~ bc) > (a ~ c) > {} > b\") cumulativeScores(pr) ## $a ## [1] 1 2 3 3 3 ##  ## $b ## [1] 1 2 2 2 3 ##  ## $c ## [1] 0 2 3 3 3 ##  ## attr(,\"class\") ## [1] \"CumulativeScores\" # for each index k, $a[k] >= $b[k] cumulativelyDominates(pr, \"a\", \"b\") ## [1] TRUE # $a[3] > $b[3], therefore a also strictly dominates b cumulativelyDominates(pr, \"a\", \"b\", strictly = TRUE) ## [1] TRUE # $b[1] > $c[1], but $c[3] > $b[3] # therefore neither b nor c dominate each other cumulativelyDominates(pr, \"b\", \"c\") ## [1] FALSE cumulativelyDominates(pr, \"c\", \"b\") ## [1] FALSE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"cp-majority-comparison","dir":"Articles","previous_headings":"SocialRanking Objects > Comparison Functions","what":"CP-Majority comparison","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Ceteris Paribus Majority (CP-Majority) relation somewhat relaxed version dominance property. Instead checking \\(S \\cup \\{\\} \\succsim S \\cup \\{j\\}\\) \\(S \\2^{N \\setminus \\{,j\\}}\\), CP-Majority relation \\(iR^\\succsim_\\textrm{CP}j\\) holds number times \\(S \\cup \\{\\} \\succsim S \\cup \\{j\\}\\) greater equal number times \\(S \\cup \\{j\\} \\succsim S \\cup \\{\\}\\). (CP-Majority [6]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). Ceteris Paribus majority relation binary relation \\(R^\\succsim_\\textrm{CP} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{CP}j \\Leftrightarrow d_{ij}(\\succsim) \\geq d_{ji}(\\succsim) \\end{equation}\\] \\(d_{ij}(\\succsim)\\) represents cardinality set \\(D_{ij}(\\succsim)\\), set coalitions \\(S \\2^{N \\setminus \\{,j\\}}\\) \\(S \\cup \\{\\} \\succsim S \\cup \\{j\\}\\). cpMajorityComparisonScore(pr, e1, e2) calculates two scores \\(d_{ij}(\\succsim)\\) \\(-d_{ji}(\\succsim)\\). Notice minus sign - way can use sum values determine relation e1 e2. slight variation logical parameter strictly calculates \\(d^*_{ij}(\\succsim)\\) \\(-d^*_{ji}(\\succsim)\\), number coalitions \\(S \\2^{N\\setminus \\{,j\\}}\\) \\(S\\cup\\{\\}\\succ S\\cup\\{j\\}\\). Coincidentally, cpMajorityComparisonScore strictly = TRUE can used determine e1 (strictly) dominates e2. cpMajorityComparisonScore used simple quick calculations. comprehensive function cpMajorityComparison(pr, e1, e2) calculations, process retains information comparisons might interesting user, .e., set \\(D_{ij}(\\succsim)\\) \\(D_{ji}(\\succsim)\\) well relation \\(iR^\\succsim_\\textrm{CP}j\\). See documentation full list available data. CP-Majority relation can generate cycles, reason offered social ranking solution. Instead, introduce Copeland-like method Kramer-Simpson-like method make use CP-Majority functions determine power relation elements. readings CP-Majority, see [7] [10].","code":"pr <- as.PowerRelation(\"ab > (ac ~ bc) > (a ~ c) > {} > b\") cpMajorityComparisonScore(pr, \"a\", \"b\") ## [1]  2 -1 cpMajorityComparisonScore(pr, \"b\", \"a\") ## [1]  1 -2 if(sum(cpMajorityComparisonScore(pr, \"a\", \"b\")) >= 0) {   print(\"a >= b\") } else {   print(\"b > a\") } ## [1] \"a >= b\" # Now (ac ~ bc) is not counted cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = TRUE) ## [1] 1 0 # Notice that the sum is still the same sum(cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = FALSE)) ==   sum(cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = TRUE)) ## [1] TRUE # extract more information in cpMajorityComparison cpMajorityComparison(pr, \"a\", \"b\") ## a > b ## D_ab = {c, {}} ## D_ba = {c} ## Score of a = 2 ## Score of b = 1 # with strictly set to TRUE, coalition c does # neither appear in D_ab nor in D_ba cpMajorityComparison(pr, \"a\", \"b\", strictly = TRUE) ## a > b ## D_ab = {{}} ## D_ba = {} ## Score of a = 1 ## Score of b = 0"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ordinal-banzhaf","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions","what":"Ordinal Banzhaf","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Ordinal Banzhaf Score vector defined principle marginal contributions. Intuitively speaking, player joining coalition causes move ranking, can interpreted positive contribution. contrary negative contribution means participating causes coalition go ranking. (Ordinal marginal contribution [5]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). given element \\(\\N\\), ordinal marginal contribution \\(m_i^S(\\succsim)\\) right coalition \\(S \\\\mathcal{P}\\) defined : \\[\\begin{equation}     m_i^S(\\succsim) = \\begin{cases}         \\hphantom{-}1 & \\textrm{} S \\cup \\{\\} \\succ S\\\\         -1 & \\textrm{} S \\succ S \\cup \\{\\}\\\\         \\hphantom{-}0 & \\textrm{otherwise}     \\end{cases} \\end{equation}\\] (Ordinal Banzhaf relation) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). Ordinal Banzhaf relation binary relation \\(R^\\succsim_\\textrm{Banz} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{Banz}j \\Leftrightarrow \\text{Score}_\\text{Banz}() \\geq \\text{Score}_\\text{Banz}(j), \\end{equation}\\] \\(\\text{Score}_\\text{Banz}() = \\sum_{S} m^S_i(\\succsim)\\) \\(S \\N\\setminus\\{\\}\\). Note \\(S \\notin \\mathcal{P}\\) \\(S \\cup \\{\\} \\notin \\mathcal{P}\\), \\(m_i^S(\\succsim) = 0\\). function ordinalBanzhafScores() returns three numbers element, number coalitions \\(S\\) player’s contribution positive impact, number coalitions \\(S\\) player’s contribution negative impact, number coalitions \\(S\\) information can gathered, \\(S \\notin \\mathcal{P}\\) \\(S \\cup \\{\\} \\notin \\mathcal{P}\\). sum first two numbers determines score player. Players higher scores rank higher.","code":"pr <- as.PowerRelation(list(c(1,2), c(1), c(2))) pr ## 12 > 1 > 2 # both players 1 and 2 have an Ordinal Banzhaf Score of 1 # therefore they are indifferent to one another # note that the empty set is missing, as such we cannot compare {}u{i} with {} ordinalBanzhafScores(pr) ## $`1` ## [1] 1 0 1 ##  ## $`2` ## [1] 1 0 1 ##  ## attr(,\"class\") ## [1] \"OrdinalBanzhafScores\" ordinalBanzhafRanking(pr) ## 1 ~ 2 pr <- as.PowerRelation(\"ab > a > {} > b\")  # player b has a negative impact on the empty set # -> player b's score is 1 - 1 = 0 # -> player a's score is 2 - 0 = 2 sapply(ordinalBanzhafScores(pr), function(score) sum(score[c(1,2)])) ## a b  ## 2 0 ordinalBanzhafRanking(pr) ## a > b"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ch:copeland","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions","what":"Copeland-like method","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Copeland-like method ranking elements based CP-Majority rule strongly inspired Copeland score social choice theory[15]. score element \\(\\N\\) determined amount pairwise CP-Majority winning comparisons \\(R^\\succsim_\\textrm{CP} j\\), minus number losing comparisons \\(j R^\\succsim_\\textrm{CP} \\) elements \\(j \\N \\setminus \\{\\}\\). (Copeland-like relation [10]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). Copeland-like relation binary relation \\(R^\\succsim_\\textrm{Cop} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{Cop}j \\Leftrightarrow \\text{Score}_\\text{Cop}() \\geq \\text{Score}_\\text{Cop}(j), \\end{equation}\\] \\(\\text{Score}_\\text{Cop}() = |\\{j \\N \\setminus \\{\\}: d_{ij}(\\succsim) \\geq d_{ji}(\\succsim)\\}| - |\\{j \\N \\setminus \\{\\}: d_{ij}(\\succsim) \\leq d_{ji}(\\succsim)\\}|\\) copelandScores(pr) returns two numerical values element, positive number winning comparisons (shown \\(\\text{Score}_\\text{Cop}()\\) left) negative number losing comparisons (\\(\\text{Score}_\\text{Cop}()\\) right).","code":"pr <- as.PowerRelation(\"(abc ~ ab ~ c ~ a) > (b ~ bc) > ac\") scores <- copelandScores(pr)  # Based on CP-Majority, a>=b and a>=c (+2), but b>=a (-1) scores$a ## [1]  2 -1 sapply(copelandScores(pr), sum) ##  a  b  c  ##  1  0 -1 copelandRanking(pr) ## a > b > c"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ch:kramerSimpson","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions","what":"Kramer-Simpson-like method","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Strongly inspired Kramer-Simpson method social choice theory[16, 17], elements ranked inversely greatest pairwise defeat possible CP-Majority comparisons. (Kramer-Simpson-like relation [10]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). Kramer-Simpson-like relation binary relation \\(R^\\succsim_\\textrm{KS} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{KS}j \\Leftrightarrow \\text{Score}_\\text{KS}() \\geq \\text{Score}_\\text{KS}(j), \\end{equation}\\] \\(\\text{Score}_\\text{KS}() = -\\max_j d^*_{ji}(\\succsim)\\) \\(j \\N \\setminus \\{\\}\\). Recall \\(d^*_{ji}(\\succsim)\\) returns number strict relations \\(S \\cup \\{j\\} \\succ S \\cup \\{\\}\\). kramerSimpsonScores(pr) returns vector single numerical value element , sorted highest lowest, gives us ranking solution.","code":"pr <- as.PowerRelation(\"(abc ~ ab ~ c ~ a) > (b ~ bc) > ac\") kramerSimpsonScores(pr) ##  a  b  c  ## -1 -1 -1  ## attr(,\"class\") ## [1] \"KramerSimpsonScores\" kramerSimpsonRanking(pr) ## a ~ b ~ c"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"lexicographical-excellence-solution","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > Lexcel and Dual Lexcel","what":"Lexicographical Excellence Solution","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"idea behind lexicographical excellence solution (Lexcel) reward elements appearing frequently higher ranked equivalence classes. given power relation \\(\\succsim\\) quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), denote \\(i_k\\) number coalitions \\(\\sum_k\\) containing \\(\\): \\[\\begin{equation}     i_k = |\\{S \\\\textstyle \\sum_k: \\S\\}| \\end{equation}\\] \\(k \\\\{1, \\dots, m\\}\\). Now, let \\(\\text{Score}_\\text{Lex}()\\) \\(m\\)-dimensional vector \\(\\text{Score}_\\text{Lex}() = (i_1, \\dots, i_m)\\) associated \\(\\succsim\\). Consider lexicographic order \\(\\geq_\\textrm{Lex}\\) among vectors \\(\\mathbf{}\\) \\(\\mathbf{j}\\): \\(\\mathbf{} \\geq_\\textrm{Lex} \\mathbf{j}\\) either \\(\\mathbf{} = \\mathbf{j}\\) exists \\(t : i_r = j_r, r \\\\{1,\\dots,t-1\\}\\), \\(i_t > j_t\\). (Lexicographic-Excellence relation [8]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) corresponding quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\). Lexicographic-Excellence relation binary relation \\(R^\\succsim_\\textrm{Lex} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{Lex}j \\Leftrightarrow \\text{Score}_\\text{Lex}() \\geq_{\\textrm{Lex}} \\text{Score}_\\text{Lex}(j) \\end{equation}\\] generalizations Lexcel solution see also [9]. Lexcel score vectors similar cumulative score vectors (see section Cumulative Dominance) number times element appears given equivalence class interest. fact, applying base function cumsum element’s lexcel score gives us cumulative score.","code":"pr <- as.PowerRelation(\"12 > (123 ~ 23 ~ 3) > (1 ~ 2) > 13\")  # show the number of times an element appears in each equivalence class # e.g. 3 appears 3 times in [[2]] and 1 time in [[4]] lapply(pr$equivalenceClasses, unlist) ## list() lexScores <- lexcelScores(pr) for(i in names(lexScores))   paste0(\"Lexcel score of element \", i, \": \", lexScores[i])  # at index 1, element 2 ranks higher than 3 lexScores['2'] > lexScores['3'] ## [1] TRUE # at index 2, element 2 ranks higher than 1 lexScores['2'] > lexScores['1'] ## [1] TRUE lexcelRanking(pr) ## 2 > 1 > 3 lexcelCumulated <- lapply(lexScores, cumsum) cumulScores <- cumulativeScores(pr)  paste0(names(lexcelCumulated), \": \", lexcelCumulated, collapse = ', ') ## [1] \"1: 1:4, 2: c(1, 3, 4, 4), 3: c(0, 3, 3, 4)\" paste0(names(cumulScores), \": \", cumulScores, collapse = ', ') ## [1] \"1: 1:4, 2: c(1, 3, 4, 4), 3: c(0, 3, 3, 4)\""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"dual-lexicographical-excellence-solution","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > Lexcel and Dual Lexcel","what":"Dual Lexicographical Excellence Solution","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Similar Lexcel ranking, Dual Lexcel also uses Lexcel score vectors definition 9 establish ranking. However, instead rewarding higher frequencies high ranking coalitions, punishes players appear frequently lower ranking equivalence classes. interpreted sense, punishes mediocrity. Take values \\(i_k\\) \\(k \\\\{1, \\dots, m\\}\\) Lexcel score vector \\(\\text{Score}_\\text{Lex}()\\) section . Consider dual lexicographical order \\(\\geq_\\textrm{DualLex}\\) among vectors \\(\\mathbf{}\\) \\(\\mathbf{j}\\): \\(\\mathbf{} \\geq_\\textrm{DualLex} \\mathbf{j}\\) either \\(\\mathbf{} = \\mathbf{j}\\) exists \\(t: i_t < j_t\\) \\(i_r = j_r, r\\\\{t+1, \\dots, m\\}\\). (Dual Lexicographical-Excellence relation [14]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). Dual Lexicographic-Excellence relation binary relation \\(R^\\succsim_\\textrm{DualLex} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{DualLex}j \\Leftrightarrow \\text{Score}_\\text{Lex}() \\geq_\\textrm{DualLex} \\text{Score}_\\text{Lex}(j) \\end{equation}\\] S3 class LexcelScores account Dual Lexcel comparisons. Instead -rev(x) called Lexcel score vector x resulting comparisons produces Dual Lexcel ranking solution.","code":"pr <- as.PowerRelation(\"12 > (123 ~ 23 ~ 3) > (1 ~ 2) > 13\")  lexScores <- lexcelScores(pr)  # in regular Lexcel, 1 scores higher than 3 lexScores['1'] > lexScores['3'] ## [1] TRUE # turn Lexcel score into Dual Lexcel score dualLexScores <- structure(   lapply(lexcelScores(pr), function(r) -rev(r)),   class = 'LexcelScores' )  # now 1 scores lower than 3 dualLexScores['1'] > dualLexScores['3'] ## [1] FALSE # element 2 comes out at the top in both Lexcel and Dual Lexcel lexcelRanking(pr) ## 2 > 1 > 3 dualLexcelRanking(pr) ## 2 > 3 > 1"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"l1-l2-lp-lp","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions","what":"\\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\), \\(L^{p^*}\\)","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"remaining social ranking solutions variation lexcel solutions previous section. rank individuals using lexicographical approach, consider equivalence classes, also size coalitions element appears . answering question player influence group others, may want attribute higher value smaller coalitions. given coalitional ranking \\(\\succsim\\) associated quotient order \\(\\Sigma_1 \\succ \\dots \\succ \\Sigma_m\\), \\(\\text{Score}_\\text{Lex}()\\) produced vector length \\(m\\) index signifying number times \\(\\) appears equivalence class. now extended function \\[M^\\succsim_i = \\text{Score}_\\text{L}() \\\\mathbb{N}^{|N| \\times m}\\] produces matrix. column \\(q\\) corresponds equivalence class, row \\(p\\) coalition size. values defined \\[(M^\\succsim_i)_{p,q} = |\\lbrace S \\\\Sigma_q: |S| = p \\text{ } \\S\\rbrace|.\\] ranking \\((\\{1, 2\\} \\sim \\{1\\} \\sim \\{2, 3\\}) \\succ N \\succ \\varnothing \\succ (\\{1, 3\\} \\sim \\{2\\} \\sim \\{3\\})\\) give use following three matrices. \\[M^\\succsim_1 = \\begin{bmatrix} 1 & 0 & 0 & 0\\\\ 1 & 0 & 0 & 1\\\\ 0 & 1 & 0 & 0 \\end{bmatrix} M^\\succsim_2 = \\begin{bmatrix} 0 & 0 & 0 & 1\\\\ 2 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0 \\end{bmatrix} M^\\succsim_3 = \\begin{bmatrix} 0 & 0 & 0 & 1\\\\ 1 & 0 & 0 & 1\\\\ 0 & 1 & 0 & 0 \\end{bmatrix}\\] matrices can created L1Scores() function. Comparing matrices builds foundation \\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\) \\(L^{p^*}\\) solutions.","code":"pr <- as.PowerRelation('(12 ~ 1 ~ 23) > 123 > {} > (13 ~ 2 ~ 3)') L1Scores(pr) ## $`1` ##      [,1] [,2] [,3] [,4] ## [1,]    1    0    0    0 ## [2,]    1    0    0    1 ## [3,]    0    1    0    0 ##  ## $`2` ##      [,1] [,2] [,3] [,4] ## [1,]    0    0    0    1 ## [2,]    2    0    0    0 ## [3,]    0    1    0    0 ##  ## $`3` ##      [,1] [,2] [,3] [,4] ## [1,]    0    0    0    1 ## [2,]    1    0    0    1 ## [3,]    0    1    0    0 ##  ## attr(,\"class\") ## [1] \"L1Scores\""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"l1","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > \\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\), \\(L^{p^*}\\)","what":"\\(L^{(1)}\\)","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"(\\(L^{(1)}\\) solution [9]) \\(, j \\N\\), \\(L^{(1)}\\) solution ranks \\(\\) \\(j\\) exists \\(p^0 \\\\{1, \\dots, n\\}\\) \\(q^0 \\\\{1, \\dots, m\\}\\) following conditions hold: \\((M^\\succsim_i)_{p,q\\hphantom{^0}} = (M^\\succsim_j)_{p,q\\hphantom{^0}}\\) \\(1 \\leq p \\leq n\\) \\(1 \\leq q < q^0\\), \\((M^\\succsim_i)_{p,q^0} = (M^\\succsim_j)_{p,q^0}\\) \\(1 \\leq p < p^0\\), \\((M^\\succsim_i)_{p^0,q^0} > (M^\\succsim_j)_{p^0,q^0}\\) Put simple terms, comparing two elements \\(\\) \\(j\\) corresponding matrices, first compare first column, top bottom. first row value one higher determines relation. columns , move forward next column. example , lexcel determines 1 ~ 2. However, matrices, 1 higher value first row first column. implies \\(L^{(1)}\\) prefers 1 > 2 simply singleton coalition \\(\\{1\\}\\) appears first equivalence class, whereas \\(\\{2\\}\\) .","code":"L1Ranking(pr) ## 1 > 2 > 3"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"l2","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > \\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\), \\(L^{p^*}\\)","what":"\\(L^{(2)}\\)","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Compared lexcel, \\(L^{(1)}\\) seen little strict enforcing relation based singular coalition discarding others equivalence class. Take instance \\((\\{1\\} \\sim \\{2, 3\\} \\sim \\{2, 4\\} \\sim \\{2, 3, 4\\}) \\succ \\dots\\). Even though \\(2\\) seems lot possibilities cooperate, \\(L^{(1)}\\) prefers \\(1\\) simply coalition appears smaller others. \\(L^{(2)}\\) tries find happy medium two solutions. given equivalence class, first compares total number times element appears (aka., lexcel score). scores , compare corresponding column according \\(L^{(1)}\\). (\\(L^{(2)}\\) solution [9]) \\(, j \\N\\), \\(L^{(2)}\\) solution ranks \\(\\) \\(j\\) exists \\(p^0 \\\\{1, \\dots, n\\}\\) \\(q^0 \\\\{1, \\dots, m\\}\\) following conditions hold: \\((M^\\succsim_i)_{p,q\\hphantom{^0}} = (M^\\succsim_j)_{p,q\\hphantom{^0}}\\) \\(1 \\leq p \\leq n\\) \\(1 \\leq q < q^0\\), Either (2.1) \\(\\text{Score}_\\text{Lex}()_{q^0} > \\text{Score}_\\text{Lex}(j)_{q^0}\\), (2.2) \\((M^\\succsim_i)_{p,q^0} = (M^\\succsim_j)_{p,q^0}\\) \\(1 \\leq p < p^0\\) \\((M^\\succsim_i)_{p^0,q^0} > (M^\\succsim_j)_{p^0,q^0}\\) Note \\(\\text{Score}_\\text{Lex}()_{q^0} = \\sum_{p=1}^{|N|} (M^\\succsim_i)_{p,q^0}\\). make finding sum column easier, values added extra row . also conveniently allows us use traditional \\(L^{(1)}\\) comparison matrices. solution \\(L^{(2)}\\) always coincide either lexcel \\(L^{(1)}\\) solution. example beginning section, comparing \\(1\\) \\(2\\), relation \\(L^{(2)}\\) coincides \\(L^{(1)}\\): sum first column \\(M^\\succsim_1\\) \\(M^\\succsim_2\\) equal \\(2\\), inducing row--row comparison, \\(L^{(1)}\\). latter example subsection, sum first column vectors \\(1\\) \\(2\\) vastly different, causing \\(L^{(2)}\\) coincide lexcel solution.","code":"L2Ranking(pr) ## 1 > 2 > 3 pr2 <- as.PowerRelation('1 ~ 23 ~ 24 ~ 234') pr2 <- appendMissingCoalitions(pr2) L1Ranking(pr2) ## 1 > 2 > 3 ~ 4 L2Ranking(pr2) ## 2 > 3 ~ 4 > 1"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"lp","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > \\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\), \\(L^{p^*}\\)","what":"\\(L^p\\)","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"\\(L^p\\) \\(L^{p^*}\\) differ drastically compare matrices row--row basis rather column--column. puts much higher value smaller coalitions, regardless equivalence class placed . solutions first consider singleton coalition. two given elements \\(\\) \\(j\\), \\(\\{\\} \\succ \\{j\\}\\), relation according \\(L^p\\) \\(L^{p^*}\\) already determined. \\(\\{\\} ~ \\{j\\}\\), every subsequent comparison done number coalitions rank strictly higher. may practical situation want individuals work small groups disregard coalitions ’d better alone. (\\(L^p\\) solution [11]) \\(, j \\N\\), social ranking solution \\(L^p\\) ranks \\(\\) \\(j\\) one following conditions hold: \\(\\lbrace \\rbrace \\succ \\lbrace j \\rbrace\\); \\(\\lbrace \\rbrace, \\lbrace j \\rbrace \\\\Sigma_k\\) exists row \\(p^0 \\\\lbrace 2, \\dots, |N|\\rbrace\\) : \\[\\sum_{q < k} (M^\\succsim_i)_{p,q} = \\sum_{q < k} (M^\\succsim_j)_{p,q}\\quad \\forall p < p^0,\\text{ }\\] \\[\\sum_{q < k} (M^\\succsim_i)_{p^0,q} > \\sum_{q < k} (M^\\succsim_j)_{p^0,q}.\\] \\(L^p\\) looks total number times element chance form better coalition singleton. Since lot information matrix element therefore redundant, LPScores() discards much save space. first value corresponds equivalence class index singleton appears , subsequent value number times able form coalitions size 2, 3, .","code":"LPScores(pr) ## $`1` ## [1] 1 0 0 ##  ## $`2` ## [1] 4 2 1 ##  ## $`3` ## [1] 4 1 1 ##  ## attr(,\"class\") ## [1] \"LPScores\" LPRanking(pr) ## 1 > 2 > 3"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"lp-1","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > \\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\), \\(L^{p^*}\\)","what":"\\(L^{p^*}\\)","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"taking sum coalitions certain size might informative enough. Similarly \\(L^{(1)}\\) builds granual comparison two elements incorporating coalition size, \\(L^{p^*}\\) can seen granual version \\(L^p\\) incorporating specific equivalence class element appears . (\\(L^{p^*}\\) solution [11]) \\(, j \\N\\), social ranking solution \\(L^{p^*}\\) ranks \\(\\) \\(j\\) one following conditions hold: \\(\\lbrace \\rbrace \\succ \\lbrace j \\rbrace\\); \\(\\lbrace \\rbrace, \\lbrace j \\rbrace \\\\Sigma_k\\) exists row \\(p^0 \\\\lbrace 2, \\dots, |N|\\rbrace\\) column \\(q^0 \\\\lbrace 1, \\dots, k-1\\rbrace\\) : \\[(M^\\succsim_i)_{p,q} = (M^\\succsim_j)_{p,q}\\quad \\forall p < p^0, q < k,\\] \\[(M^\\succsim_i)_{p^0,q} = (M^\\succsim_j)_{p^0,q}\\quad \\forall q < q^0,\\text{ }\\] \\[(M^\\succsim_i)_{p^0,q^0} > (M^\\succsim_j)_{p^0,q^0}.\\] score matrices LPSScores() look similar L1Scores() , difference number columns; equivalence class \\(\\{\\} \\\\Sigma_k\\) \\(\\Sigma_k \\succ \\Sigma_l\\) influence final ranking, columns discarded final matrix.","code":"L1Scores(pr) ## $`1` ##      [,1] [,2] [,3] [,4] ## [1,]    1    0    0    0 ## [2,]    1    0    0    1 ## [3,]    0    1    0    0 ##  ## $`2` ##      [,1] [,2] [,3] [,4] ## [1,]    0    0    0    1 ## [2,]    2    0    0    0 ## [3,]    0    1    0    0 ##  ## $`3` ##      [,1] [,2] [,3] [,4] ## [1,]    0    0    0    1 ## [2,]    1    0    0    1 ## [3,]    0    1    0    0 ##  ## attr(,\"class\") ## [1] \"L1Scores\" LPSScores(pr) ## $`1` ##      ## [1,] ## [2,] ##  ## $`2` ##      [,1] [,2] [,3] ## [1,]    2    0    0 ## [2,]    0    1    0 ##  ## $`3` ##      [,1] [,2] [,3] ## [1,]    1    0    0 ## [2,]    0    1    0 ##  ## attr(,\"class\") ## [1] \"LP*Scores\" LPSRanking(pr) ## 1 > 2 > 3"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"incidence-matrix","dir":"Articles","previous_headings":"Relations","what":"Incidence Matrix","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"vignette focused intuitive aspects power relations social ranking solutions. reiterate, power relation total preorder, reflexive transitive relation \\(\\succsim \\\\mathcal{P} \\times \\mathcal{P}\\), \\(\\sim\\) denotes symmetric part \\(\\succ\\) asymmetric part. power relation can represented incidence matrix \\((b_{ij}) = B \\\\{0,1\\}^{|\\mathcal{P}| \\times |\\mathcal{P}|}\\). Given two coalitions \\(, j \\\\mathcal{P}\\), \\(iRj\\) \\(b_{ij} = 1\\), else \\(0\\). help relations package, functions relations::.relation(pr) powerRelationMatrix(pr) turn PowerRelation object relation object. relations offers ways display relation object incidence matrix relation_incidence(rel) test basic properties relation_is_linear_order(rel), relation_is_acyclic(rel) relation_is_antisymmetric(rel) (see relations package [12]). Note columns rows sorted names relation_domain(rel), hence name preceded ordering number.","code":"pr <- as.PowerRelation(\"ab > a > {} > b\") rel <- relations::as.relation(pr)  relations::relation_incidence(rel) ## Incidences: ##    ab ​a ​​{} ​​​b ## ab  1 1  1 1 ## ​a   0 1  1 1 ## ​​{}  0 0  1 1 ## ​​​b   0 0  0 1 c(   relations::relation_is_acyclic(rel),   relations::relation_is_antisymmetric(rel),   relations::relation_is_linear_order(rel),   relations::relation_is_complete(rel),   relations::relation_is_reflexive(rel),   relations::relation_is_transitive(rel) ) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE # a power relation where coalitions {1} and {2} are indifferent pr <- as.PowerRelation(\"12 > (1 ~ 2)\") rel <- relations::as.relation(pr)  # we have both binary relations {1}R{2} as well as {2}R{1} relations::relation_incidence(rel) ## Incidences: ##    12 ​1 ​​2 ## 12  1 1 1 ## ​1   0 1 1 ## ​​2   0 1 1 # FALSE c(   relations::relation_is_acyclic(rel),   relations::relation_is_antisymmetric(rel),   relations::relation_is_linear_order(rel),   relations::relation_is_complete(rel),   relations::relation_is_reflexive(rel),   relations::relation_is_transitive(rel) ) ## [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"cycles-and-transitive-closure","dir":"Articles","previous_headings":"Relations","what":"Cycles and Transitive Closure","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"cycle power relation exists, one coalition \\(S \\2^N\\) appears twice. example, \\(\\{1,2\\} \\succ (\\{1\\} \\sim \\emptyset) \\succ \\{1,2\\}\\), coalition \\(\\{1,2\\}\\) appears beginning end power relation. Properly handling power relations calculating social ranking solutions cycles somewhat ill-defined, hence warning message shown soon one created. Recall power relation transitive, meaning three coalitions \\(x, y, z \\2^N\\), \\(xRy\\) \\(yRz\\), \\(xRz\\). introduce cycles, pretty much introduce symmetry. Assume power relation \\(x \\succ y \\succ x\\). , even though \\(xRy\\) \\(yRx\\) defined asymmetric part power relation \\(\\succsim\\), together form symmetric power relation \\(x \\sim y\\). transitiveClosure(pr) function turns power relation cycles one without one. process removing duplicate coalitions, turns asymmectric relations within cycle symmetric relations.","code":"as.PowerRelation(\"12 > 2 > (1 ~ 2) > 12\") ## Warning in createLookupTables(equivalenceClasses): Found 2 duplicate coalitions, listed below. This violates transitivity and can cause issues with certain ranking solutions. You may want to take a look at socialranking::transitiveClosure(). ##     - {2} ##     - {1, 2} ## 12 > 2 > (1 ~ 2) > 12 pr <- suppressWarnings(as.PowerRelation(list(1, 2, 1))) pr ## 1 > 2 > 1 transitiveClosure(pr) ## (1 ~ 2) # two cycles, (1>3>1) and (2>23>2) pr <- suppressWarnings(   as.PowerRelation(\"1 > 3 > 1 > 2 > 23 > 2\") )  transitiveClosure(pr) ## (1 ~ 3) > (2 ~ 23) # overlapping cycles pr <- suppressWarnings(   as.PowerRelation(\"c > ac > b > ac > (a ~ b) > abc\") )  transitiveClosure(pr) ## c > (ac ~ b ~ a) > abc"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"literature cooperative games, notion power index [1–3] widely studied analyze “influence” individuals taking account ability force decision within groups coalitions. practical situations, however, information concerning strength coalitions hardly quantifiable. , attempt numerically represent influence groups individuals clashes complex multi-attribute nature problem seems realistic represent collective decision-making mechanisms using ordinal coalitional framework based two main ingredients: binary relation groups coalitions ranking individuals. main objective package socialranking provide answers general problem compare elements finite set \\(N\\) given ranking elements power-set (set possible subsets \\(N\\)). , package socialranking implements portfolio solutions recent literature social rankings [4–11].","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"quick-start","dir":"Articles","previous_headings":"Introduction","what":"Quick start","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"power relation (.e, ranking subsets finite set \\(N\\); see Section PowerRelation objects formal definition) can constructed using functions PowerRelation() .PowerRelation(). Functions used analyze given PowerRelation object can grouped three main categories: Comparison functions, comparing two elements; Score functions, calculating scores element; Ranking functions, creating SocialRanking objects. Comparison score functions often used evaluate social ranking solution (see section PowerRelation objects formal definition). Listed prominent functions solutions introduced aforementioned papers. functions may called follows. Lastly, incidence matrix given coalitions can constructed using powerRelationMatrix(pr) .relation(pr) relations package [12]. incidence matrix may displayed using relations::relation_incidence().","code":"library(socialranking) PowerRelation(list(list(c(1,2)), list(1, c()), list(2))) ## 12 > (1 ~ {}) > 2 as.PowerRelation(\"12 > 1 ~ {} > 2\") ## 12 > (1 ~ {}) > 2 as.PowerRelation(\"ab > a ~ {} > b\") ## ab > (a ~ {}) > b as.PowerRelation(list(c(1,2), 1, c(), 2)) ## 12 > 1 > {} > 2 as.PowerRelation(list(c(1,2), 1, c(), 2), comparators = c(\">\", \"~\", \">\")) ## 12 > (1 ~ {}) > 2 pr <- as.PowerRelation(\"ab > abc ~ ac ~ bc > a ~ c > {} > b\")  # a dominates b, but b does not dominate a c(dominates(pr, \"a\", \"b\"),   dominates(pr, \"b\", \"a\")) ## [1]  TRUE FALSE # calculate cumulative scores scores <- cumulativeScores(pr) # show score of element a scores$a ## [1] 1 3 4 4 4 # performing a bunch of rankings lexcelRanking(pr) ## a > b > c L1Ranking(pr) ## a > b > c dualLexcelRanking(pr) ## a > c > b copelandRanking(pr) ## a > b ~ c kramerSimpsonRanking(pr) ## a > b ~ c ordinalBanzhafRanking(pr) ## a > c > b rel <- relations::as.relation(pr) rel ## A binary relation of size 8 x 8. relations::relation_incidence(rel) ## Incidences: ##     ab ​abc ​​ac ​​​bc ​​​​a ​​​​​c ​​​​​​{} ​​​​​​​b ## ab   1   1  1  1 1 1  1 1 ## ​abc  0   1  1  1 1 1  1 1 ## ​​ac   0   1  1  1 1 1  1 1 ## ​​​bc   0   1  1  1 1 1  1 1 ## ​​​​a    0   0  0  0 1 1  1 1 ## ​​​​​c    0   0  0  0 1 1  1 1 ## ​​​​​​{}   0   0  0  0 0 0  1 1 ## ​​​​​​​b    0   0  0  0 0 0  0 1"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"sec:prelim","dir":"Articles","previous_headings":"","what":"PowerRelation objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"first introduce basic definitions binary relations. Let \\(X\\) set. set \\(R \\subseteq X \\times X\\) said binary relation \\(X\\). two elements \\(x, y \\X\\), \\(xRy\\) refers relation, formally means \\((x,y) \\R\\). binary relation \\((x,y) \\R\\) said reflexive, \\(x \\X, xRx\\), transitive, \\(x, y, z \\X, xRy\\) \\(yRz \\Rightarrow xRz\\), total, \\(x,y \\X, x \\neq y \\Rightarrow xRy\\) \\(yRx\\), symmetric, \\(x,y \\X,xRy \\Leftrightarrow yRx\\), asymmetric, \\(x,y \\X,(x,y) \\R \\Rightarrow (y,x) \\notin R\\), antisymmetric, \\(x,y \\X,xRy \\cap yRx \\Rightarrow x=y\\). preorder defined reflexive transitive relation. total, called total preorder. Additionally antisymmetric, called linear order. Let \\(N = \\{1, 2, \\dots, n\\}\\) finite set elements, sometimes also called players. \\(p \\\\{1, \\ldots, 2^n\\}\\), let \\(\\mathcal{P} = \\{S_1, S_2, \\dots, S_{p}\\}\\) set coalitions \\(S_i \\subseteq N\\) \\(\\\\{1, \\ldots, p\\}\\). Thus \\(\\mathcal{P} \\subseteq 2^N\\), \\(2^N\\) denotes power set \\(N\\), set subsets coalitions \\(N\\). \\(\\mathcal{T}(N)\\) denotes set total preorders \\(N\\), \\(\\mathcal{T}(\\mathcal{P})\\) set total preorders \\(\\mathcal{P}\\). single total preorder \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) said power relation. given power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) \\(\\mathcal{P} \\subseteq 2^N\\), symmetric part denoted \\(\\sim\\) (.e., \\(S \\sim T\\) \\(S \\succsim T\\) \\(T \\succsim S\\)), whereas asymmetric part denoted \\(\\succ\\) (.e., \\(S \\succ T\\) \\(S \\succsim T\\) \\(T \\succsim S\\)). terms, \\(S \\sim T\\) say \\(S\\) indifferent \\(T\\), whereas \\(S \\succ T\\) say \\(S\\) strictly better \\(T\\). Lastly, given power relation form \\(S_1 \\succsim S_2 \\succsim \\ldots \\succsim S_m\\), coalitions indifferent one another can grouped equivalence classes \\(\\sum_i\\) get quotient order \\(\\sum_1 \\succ \\sum_2 \\succ \\ldots \\succ \\sum_m\\). Let \\(N=\\{1,2\\}\\) two players corresponding power set \\(2^N = \\{\\{1,2\\}, \\{1\\}, \\{2\\}, \\emptyset\\}\\). following power relation given: \\[ \\begin{array}{rrrr} \\succsim \\ =\\ \\{(\\{1,2\\},\\{1,2\\}), & (\\{1,2\\},\\{2\\}), & (\\{1,2\\},\\emptyset), & (\\{1,2\\},\\{1\\}),\\hphantom{\\}}\\\\ & (\\{2\\}, \\{2\\}), & (\\{2\\}, \\emptyset), & \\hphantom{1,}(\\{2\\}, \\{1\\}),\\hphantom{\\}}\\\\ & (\\emptyset, \\emptyset), & (\\emptyset, \\{2\\}), & (\\emptyset, \\{1\\}),\\hphantom{\\}}\\\\ & & & (\\{1\\}, \\{1\\})\\hphantom{,}\\} \\end{array} \\] power relation can rewritten consecutive order : \\(\\{1,2\\} \\succ \\{2\\} \\sim \\emptyset \\succ \\{1\\}\\). quotient order formed three equivalence classes \\(\\sum_1 = \\{\\{1,2\\}\\}, \\sum_2 = \\{\\{2\\}, \\emptyset\\},\\) \\(\\sum_3 = \\{\\{1\\}\\}\\); quotient order \\(\\succsim\\) \\(\\{\\{1,2\\}\\} \\succ \\{\\{2\\}, \\emptyset\\} \\succ \\{\\{1\\}\\}\\). Note way set \\(\\succsim\\) presented example somewhat deliberate better visualize occurring symmetries asymmetries. also lets us neatly represent power relation form incidence matrix.","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"creating-powerrelation-objects","dir":"Articles","previous_headings":"PowerRelation objects","what":"Creating PowerRelation objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"power relation socialranking package defined reflexive, transitive total. designing package deemed logical coalitions specified consecutive order, seen Example 1. coalition order split either \">\" (left side strictly better) \"~\" (two coalitions indifferent one another). following code chunk shows power relation Example 1 correlating PowerRelation object can constructed. Notice coalitions \\(\\{1,2\\}\\) written 12 improve readability. Similarly, passing string function .PowerRelation() saves typing user’s end interpreting character coalition separate element. Note spaces function ignored. compact notation done PowerRelation objects every element one digit one character long. case, curly braces commas added needed. may spotted \"SingleCharElements\" class missing class(prLong) class(pr). \"SingleCharElements\" influences coalitions printed. removed class(pr), output include curly braces commas displayed prLong. Internally PowerRelation list four attributes. coalitions formally defined sets, meaning order doesn’t matter element unique, package tries stay flexible. , coalitions sorted initialization, duplicate elements removed.","code":"library(socialranking) pr <- PowerRelation(list(   list(c(1,2)),   list(2, c()),   list(1) )) pr ## 12 > (2 ~ {}) > 1 class(pr) ## [1] \"PowerRelation\"      \"SingleCharElements\" as.PowerRelation(\"12 > 2~{} > 1\") ## 12 > (2 ~ {}) > 1 prLong <- PowerRelation(list(   list(c(\"Alice\", \"Bob\")),    list(\"Bob\", c()),   list(\"Alice\") )) prLong ## {Alice, Bob} > ({Bob} ~ {}) > {Alice} class(prLong) ## [1] \"PowerRelation\" class(pr) <- class(pr)[-which(class(pr) == \"SingleCharElements\")] pr ## {1, 2} > ({2} ~ {}) > {1} prAtts <- PowerRelation(list(   list(c(2,2,1,1,2)),   list(c(2,1), c()) )) ## Warning in createLookupTables(equivalenceClasses): Found 1 coalition that contain elements more than once. ##     - 1, 2 in the coalition {1, 1, 2, 2, 2} prAtts ## 11222 > (12 ~ {}) prAtts$elements ## [1] 1 2 prAtts$coalitionLookup(c(1,2)) ## [1] 2 prAtts$coalitionLookup(c(2,1)) ## [1] 2 prAtts$coalitionLookup(c(2,1,2,1,2)) ## [1] 1 prAtts$elementLookup(2) ## [[1]] ## [1] 1 1 ##  ## [[2]] ## [1] 1 1 ##  ## [[3]] ## [1] 1 1 ##  ## [[4]] ## [1] 2 1"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"manipulating-powerrelation-objects","dir":"Articles","previous_headings":"PowerRelation objects","what":"Manipulating PowerRelation objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"strongly discouraged directly manipulate PowerRelation objects, attributes tightly coupled. require updates multiple places. Instead, advisable simply create new PowerRelation objects. permutate order equivalence classes, possible take equivalence classes $eqs use vector indexes move around. permutating individual coalitions, using .PowerRelation.list() may convenient since doesn’t require nested list indexing.","code":"pr <- as.PowerRelation(\"12 > (1 ~ {}) > 2\") PowerRelation(pr$eqs[c(2, 3, 1)]) ## (1 ~ {}) > 2 > 12 PowerRelation(rev(pr$eqs)) ## 2 > (1 ~ {}) > 12 coalitions <- unlist(pr$eqs, recursive = FALSE) compares <- c(\">\", \"~\", \">\") as.PowerRelation(coalitions[c(2,1,3,4)], comparators = compares) ## 1 > (12 ~ {}) > 2 # notice that the length of comparators does not need to match # length(coalitions)-1 as.PowerRelation(rev(coalitions), comparators = c(\"~\", \">\")) ## (2 ~ {}) > (1 ~ 12) # not setting the comparators parameter turns it into a linear order as.PowerRelation(coalitions) ## 12 > 1 > {} > 2"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"appendmissingcoalitions","dir":"Articles","previous_headings":"PowerRelation objects > Manipulating PowerRelation objects","what":"appendMissingCoalitions()","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). may included possible coalitions, \\(\\mathcal{P} \\subset 2^N, \\mathcal{P} \\neq 2^N\\). appendMissingCoalitions() appends missing coalitions \\(2^N - \\mathcal{P}\\) single equivalence class end power relation.","code":"pr <- PowerRelation(list(   list(c(\"AT\", \"DE\"), \"FR\"),   list(\"DE\"),   list(c(\"AT\", \"FR\"), \"AT\") )) pr ## ({AT, DE} ~ {FR}) > {DE} > ({AT, FR} ~ {AT}) # since we have 3 elements, the super set 2^N should include 8 coalitions appendMissingCoalitions(pr) ## ({AT, DE} ~ {FR}) > {DE} > ({AT, FR} ~ {AT}) > ({AT, DE, FR} ~ {DE, FR} ~ {})"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"makepowerrelationmonotonic","dir":"Articles","previous_headings":"PowerRelation objects > Manipulating PowerRelation objects","what":"makePowerRelationMonotonic()","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) monotonic \\[ S \\succsim T \\quad \\Rightarrow \\quad T \\subset S \\] \\(S, T \\subseteq N\\). terms, given monotonic power relation, coalition, subsets ranked higher. makePowerRelationMonotonic() turns potentially non-monotonic power relation monotonic one moving (optionally) adding missing coalitions \\(2^N - \\mathcal{P}\\) corresponding equivalence classes.","code":"pr <- as.PowerRelation(\"a > b > c ~ ac > abc\") makePowerRelationMonotonic(pr) ## (abc ~ ab ~ ac ~ a) > (bc ~ b) > c makePowerRelationMonotonic(pr, addMissingCoalitions = FALSE) ## (abc ~ ac ~ a) > b > c # notice how an empty coalition in some equivalence class # causes all remaining coalitions to be moved there makePowerRelationMonotonic(as.PowerRelation(\"ab > c > {} > abc > a > b\")) ## (abc ~ ab) > (ac ~ bc ~ c) > (a ~ b ~ {})"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"creating-power-sets","dir":"Articles","previous_headings":"PowerRelation objects","what":"Creating power sets","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"number elements \\(n\\) increases, number possible coalitions increases \\(|2^N| = 2^n\\). createPowerset() convenient function creates power set \\(2^N\\) can used call PowerRelation .PowerRelation(), also formats function call way makes easy rearrange ordering coalitions. RStudio offers shortcuts Alt+Alt+(Option+Option+MacOS) move one multiple lines code (see fig. ). default, createPowerset() returns power set form list. list can passed directly .PowerRelation() create linear order.","code":"createPowerset(   c(\"a\", \"b\", \"c\"),   result = \"print\" ) ## as.PowerRelation(\" ##   abc ##   > ab ##   > ac ##   > bc ##   > a ##   > b ##   > c ##   > {} ## \") ps <- createPowerset(1:2, includeEmptySet = FALSE) ps ## [[1]] ## [1] 1 2 ##  ## [[2]] ## [1] 1 ##  ## [[3]] ## [1] 2 as.PowerRelation(ps) ## 12 > 1 > 2 # equivalent PowerRelation(list(ps)) ## (12 ~ 1 ~ 2) as.PowerRelation(createPowerset(letters[1:4])) ## abcd > abc > abd > acd > bcd > ab > ac > ad > bc > bd > cd > a > b > c > d > {}"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"generating-powerrelation-objects","dir":"Articles","previous_headings":"PowerRelation objects","what":"Generating PowerRelation objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"ease experimentation, possible power relations created automatically given list coalitions. Either, create random power relations using generateRandomPowerRelation(), generate sequence possible power relations powerRelationGenerator(). former, one may also specify generated power relation linear order (, ~ strict > relations) whether power relation monotonic (, \\(\\{1\\} \\succ \\{1,2\\}\\) monotonic \\(\\{1\\} \\subset \\{1,2\\}\\)). looping possible power relations, powerRelationGenerator() returns generator function , called repeatedly, returns one unique PowerRelation object . permutations exhausted, NULL returned. Permutations power relations can split two parts: generating partitions, , generating differently sized equivalence classes, moving coalitions partitions. code example , started single partition size three, wherein coalitions considered equally preferable. end, reached maximum number partitions, coalition put inside equivalence class size 1. partition generation can reversed, first receive linear power relations. Notice “moving coalitions” part reversed, order partitions come . Similarly, also able skip current partition. Note: number possible power relations grows tremendously fast number coalitions rises. get number, first consider many ways \\(n\\) coalitions can split \\(k\\) partitions, also known Stirling number second kind, \\[ S(n,k) = \\frac{1}{k!}\\ \\sum_{j=0}^k (-1)^j \\binom{k}{j}(k-j)^n. \\] number possible partitions given \\(n\\) coalitions known Bell number (see also numbers::bell()), \\[ B_n = \\sum_{j=0}^k S(n,k). \\] Given set coalitions \\(\\mathcal{P} \\2^N\\), number total preorders \\(\\mathcal{T}(\\mathcal{P})\\) \\[ |\\mathcal{T}(\\mathcal{P})| = \\sum_{k=0}^{|\\mathcal{P}|} k!\\ *\\ S(|\\mathcal{P}|, k) \\]","code":"set.seed(1) coalitions <- createPowerset(1:3) generateRandomPowerRelation(coalitions) ## 13 > (2 ~ 12) > {} > (1 ~ 123) > 23 > 3 generateRandomPowerRelation(coalitions) ## ({} ~ 1 ~ 2 ~ 12 ~ 123) > 3 > 13 > 23 generateRandomPowerRelation(coalitions, linearOrder = TRUE) ## 12 > 2 > 123 > 23 > 13 > 3 > {} > 1 generateRandomPowerRelation(coalitions, monotonic = TRUE) ## (123 ~ 23 ~ 12 ~ 13 ~ 1) > (2 ~ 3 ~ {}) generateRandomPowerRelation(coalitions, linearOrder = TRUE, monotonic = TRUE) ## 123 > 23 > 12 > 2 > 13 > 1 > 3 > {} coalitions <- list(c(1,2), 1, 2) gen <- powerRelationGenerator(coalitions) while(!is.null(pr <- gen())) {   print(pr) } ## (12 ~ 1 ~ 2) ## (12 ~ 1) > 2 ## (12 ~ 2) > 1 ## (1 ~ 2) > 12 ## 12 > (1 ~ 2) ## 1 > (12 ~ 2) ## 2 > (12 ~ 1) ## 12 > 1 > 2 ## 12 > 2 > 1 ## 1 > 12 > 2 ## 2 > 12 > 1 ## 1 > 2 > 12 ## 2 > 1 > 12 gen <- powerRelationGenerator(coalitions, startWithLinearOrder = TRUE) while(!is.null(pr <- gen())) {   print(pr) } ## 12 > 1 > 2 ## 12 > 2 > 1 ## 1 > 12 > 2 ## 2 > 12 > 1 ## 1 > 2 > 12 ## 2 > 1 > 12 ## 12 > (1 ~ 2) ## 1 > (12 ~ 2) ## 2 > (12 ~ 1) ## (12 ~ 1) > 2 ## (12 ~ 2) > 1 ## (1 ~ 2) > 12 ## (12 ~ 1 ~ 2) gen <- powerRelationGenerator(coalitions) # partition 3  gen <- generateNextPartition(gen) # partition 2+1  gen <- generateNextPartition(gen) # partition 1+2 gen() ## 12 > (1 ~ 2)"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"socialranking-objects","dir":"Articles","previous_headings":"","what":"SocialRanking Objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"main goal socialranking package rank elements based given power ranking. formally try map \\(R: \\mathcal{T}(\\mathcal{P}) \\rightarrow \\mathcal{T}(N)\\), associating power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) total preorder \\(R(\\succsim)\\) (\\(R^\\succsim\\)) elements \\(N\\). context \\(R^\\succsim j\\) tells us , given power relation \\(\\succsim\\) applying social ranking solution \\(R(\\succsim)\\), \\(\\) ranked higher equal \\(j\\). , > ~ also denote asymmetric symmetric part social ranking, respectively, \\(\\) > \\(j\\) indicating \\(\\) strictly better \\(j\\), whereas \\(\\) ~ \\(j\\), \\(\\) indifferent \\(j\\). literature, \\(^\\succsim j\\) \\(P^\\succsim j\\) often used denote symmetric asymmetric part, respectively. \\(^\\succsim j\\) therefore means \\(R^\\succsim j\\) \\(j R^\\succsim \\), whereas \\(P^\\succsim j\\) implies \\(R^\\succsim j\\) \\(j R^\\succsim j\\). section 3.1 show general SocialRanking object can constructed using doRanking function. following sections, introduce notion dominance[4], cumulative dominance[13] CP-Majority comparison[6] lets us compare two elements diving social ranking solutions Ordinal Banzhaf Index[5], Copeland-like Kramer-Simpson-like methods[10], lastly Lexicographical Excellence Solution[9] (Lexcel) Dual Lexicographical Excellence solution[14] (Dual Lexcel). Let \\(\\{,b\\} \\succ (\\{,c\\} \\sim \\{b,c\\}) \\succ (\\{\\} \\sim \\{c\\}) > (\\{,b,c\\} \\sim \\emptyset) \\succ \\{b\\}\\) power ranking. Using following social ranking solutions, get: > b > c lexcelRanking, L1Ranking L2Ranking > c > b dualLexcelRanking, ordinalBanzhafRanking LPSRanking > b ~ c copelandRanking kramerSimpsonRanking ~ c > b ordinalBanzhafRanking LPRanking","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"creating-socialranking-objects","dir":"Articles","previous_headings":"SocialRanking Objects","what":"Creating SocialRanking objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"SocialRanking object represents total preorder \\(\\mathcal{T}(N)\\) elements \\(N\\). Internally saved list vectors, containing players indifferent one another. somewhat similar equivalenceClasses attribute PowerRelation objects. function doRanking offers generic way creating SocialRanking objects. Given sortable vector list scores determines power relation players, names elements determined names() attribute scores. Hence, PowerRelation object necessary create SocialRanking object. working types sorted (.e., lists), function can passed compare parameter allows comparisons arbitrary elements. function must take two parameters (.e., b) return numeric value based comparison: compare(,b) > 0: scores higher b, compare(,b) < 0: scores lower b, compare(,b) == 0: b equivalent.","code":"# we define some arbitrary score vector where \"a\" scores highest. # \"b\" and \"c\" both score 1, thus they are indifferent. scores <- c(a = 100, b = 1, c = 1) doRanking(scores) ## a > b ~ c # we can also tell doRanking to punish higher scores doRanking(scores, decreasing = FALSE) ## b ~ c > a scores <- list(a = c(3, 3, 3), b = c(2, 3, 2), c = c(7, 0, 2)) doRanking(scores, compare = function(a, b) sum(a) - sum(b)) ## a ~ c > b # a and c are considered to be indifferent, because their sums are the same  doRanking(scores, compare = function(a,b) sum(a) - sum(b), decreasing = FALSE) ## b > a ~ c"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"comparison-functions","dir":"Articles","previous_headings":"SocialRanking Objects","what":"Comparison Functions","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Comparison functions compare two elements given power relation. offer social ranking solution. However cases CP-Majority comparison, comparison functions may used construct social ranking solution particular cases.","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ch:dominance","dir":"Articles","previous_headings":"SocialRanking Objects > Comparison Functions","what":"Dominance","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"(Dominance [4]) Given power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) two elements \\(,j \\N\\), \\(\\) dominates \\(j\\) \\(\\succsim\\) \\(S \\cup \\{\\} \\succsim S \\cup \\{j\\}\\) \\(S \\2^{N\\setminus \\{,j\\}}\\). \\(\\) also strictly dominates \\(j\\) exists \\(S \\2^{N\\setminus \\{,j\\}}\\) \\(S \\cup \\{\\} \\succ S \\cup \\{j\\}\\). implication every coalition \\(\\) \\(j\\) can join, \\(\\) least positive impact \\(j\\). function dominates(pr, e1, e2) returns logical value TRUE e1 dominates e2, else FALSE. Note e1 dominating e2 indicate e2 dominates e1, imply e1 indifferent e2. \\(S \\2^{N \\setminus \\{,j\\}}\\), can compare \\(S \\cup \\{\\} \\succsim S \\cup \\{j\\}\\) \\(S \\cup \\{\\}\\) \\(S \\cup \\{j\\}\\) take part power relation. Additionally, \\(S = \\emptyset\\), also want compare \\(\\{\\} \\succsim \\{j\\}\\). situations however comparison singletons desired. reason parameter includeEmptySet can set FALSE \\(\\emptyset \\cup \\{\\} \\succsim \\emptyset \\cup \\{j\\}\\) considered CP-Majority comparison.","code":"pr <- as.PowerRelation(\"3 > 1 > 2 > 12 > 13 > 23\")  # 1 clearly dominates 2 dominates(pr, 1, 2) ## [1] TRUE dominates(pr, 2, 1) ## [1] FALSE # 3 does not dominate 1, nor does 1 dominate 3, because # {}u3 > {}u1, but 2u1 > 2u3 dominates(pr, 1, 3) ## [1] FALSE dominates(pr, 3, 1) ## [1] FALSE # an element i dominates itself, but it does not strictly dominate itself # because there is no Sui > Sui dominates(pr, 1, 1) ## [1] TRUE dominates(pr, 1, 1, strictly = TRUE) ## [1] FALSE pr <- as.PowerRelation(\"ac > bc ~ b > a ~ abc > ab\")  # FALSE because ac > bc, whereas b > a dominates(pr, \"a\", \"b\") ## [1] FALSE # TRUE because ac > bc, ignoring b > a comparison dominates(pr, \"a\", \"b\", includeEmptySet = FALSE) ## [1] TRUE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ch:cumul","dir":"Articles","previous_headings":"SocialRanking Objects > Comparison Functions","what":"Cumulative Dominance","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"comparing two players \\(,j \\N\\), instead looking particular coalitions \\(S \\2^{N \\setminus \\{,j\\}}\\) can join, look many stronger coalitions can form point. property originally introduced [13] regular dominance axiom. given power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) corresponding quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), power player \\(\\) given vector \\(\\textrm{Score}_\\textrm{Cumul}() \\\\mathbb{N}^m\\) cumulatively sum amount times \\(\\) appears \\(\\sum_k\\) index \\(k\\). (Cumulative Dominance Score) Given power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), cumulative score vector \\(\\textrm{Score}_\\textrm{Cumul}() \\\\mathbb{N}^m\\) element \\(\\N\\) given : \\[\\begin{equation}     \\textrm{Score}_\\textrm{Cumul}() = \\Big( \\sum_{t=1}^k |\\{S \\\\textstyle \\sum_t : \\S\\}|\\Big)_{k \\\\{1, \\dots, m\\}} \\end{equation}\\] (Cumulative Dominance) Given two elements \\(,j \\N\\), \\(\\) cumulatively dominates \\(j\\) \\(\\succsim\\), \\(\\textrm{Score}_\\textrm{Cumul}()_k \\geq \\textrm{Score}_\\textrm{Cumul}(j)_k\\) \\(k \\\\{1, \\dots, m\\}\\). \\(\\) also strictly cumulatively dominates \\(j\\) exists \\(k\\) \\(\\textrm{Score}_\\textrm{Cumul}()_k > \\textrm{Score}_\\textrm{Cumul}(j)_k\\). given PowerRelation object pr two elements e1 e2, cumulativeScores(pr) returns vectors described definition 2 element, cumulativelyDominates(pr, e1, e2) returns TRUE FALSE based definition 3. Similar dominance property previous section, two elements dominating one indicate indifferent.","code":"pr <- as.PowerRelation(\"ab > (ac ~ bc) > (a ~ c) > {} > b\") cumulativeScores(pr) ## $a ## [1] 1 2 3 3 3 ##  ## $b ## [1] 1 2 2 2 3 ##  ## $c ## [1] 0 2 3 3 3 ##  ## attr(,\"class\") ## [1] \"CumulativeScores\" # for each index k, $a[k] >= $b[k] cumulativelyDominates(pr, \"a\", \"b\") ## [1] TRUE # $a[3] > $b[3], therefore a also strictly dominates b cumulativelyDominates(pr, \"a\", \"b\", strictly = TRUE) ## [1] TRUE # $b[1] > $c[1], but $c[3] > $b[3] # therefore neither b nor c dominate each other cumulativelyDominates(pr, \"b\", \"c\") ## [1] FALSE cumulativelyDominates(pr, \"c\", \"b\") ## [1] FALSE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"cp-majority-comparison","dir":"Articles","previous_headings":"SocialRanking Objects > Comparison Functions","what":"CP-Majority comparison","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Ceteris Paribus Majority (CP-Majority) relation somewhat relaxed version dominance property. Instead checking \\(S \\cup \\{\\} \\succsim S \\cup \\{j\\}\\) \\(S \\2^{N \\setminus \\{,j\\}}\\), CP-Majority relation \\(iR^\\succsim_\\textrm{CP}j\\) holds number times \\(S \\cup \\{\\} \\succsim S \\cup \\{j\\}\\) greater equal number times \\(S \\cup \\{j\\} \\succsim S \\cup \\{\\}\\). (CP-Majority [6]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). Ceteris Paribus majority relation binary relation \\(R^\\succsim_\\textrm{CP} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{CP}j \\Leftrightarrow d_{ij}(\\succsim) \\geq d_{ji}(\\succsim) \\end{equation}\\] \\(d_{ij}(\\succsim)\\) represents cardinality set \\(D_{ij}(\\succsim)\\), set coalitions \\(S \\2^{N \\setminus \\{,j\\}}\\) \\(S \\cup \\{\\} \\succsim S \\cup \\{j\\}\\). cpMajorityComparisonScore(pr, e1, e2) calculates two scores \\(d_{ij}(\\succsim)\\) \\(-d_{ji}(\\succsim)\\). Notice minus sign - way can use sum values determine relation e1 e2. slight variation logical parameter strictly calculates \\(d^*_{ij}(\\succsim)\\) \\(-d^*_{ji}(\\succsim)\\), number coalitions \\(S \\2^{N\\setminus \\{,j\\}}\\) \\(S\\cup\\{\\}\\succ S\\cup\\{j\\}\\). Coincidentally, cpMajorityComparisonScore strictly = TRUE can used determine e1 (strictly) dominates e2. cpMajorityComparisonScore used simple quick calculations. comprehensive function cpMajorityComparison(pr, e1, e2) calculations, process retains information comparisons might interesting user, .e., set \\(D_{ij}(\\succsim)\\) \\(D_{ji}(\\succsim)\\) well relation \\(iR^\\succsim_\\textrm{CP}j\\). See documentation full list available data. CP-Majority relation can generate cycles, reason offered social ranking solution. Instead, introduce Copeland-like method Kramer-Simpson-like method make use CP-Majority functions determine power relation elements. readings CP-Majority, see [7] [10].","code":"pr <- as.PowerRelation(\"ab > (ac ~ bc) > (a ~ c) > {} > b\") cpMajorityComparisonScore(pr, \"a\", \"b\") ## [1]  2 -1 cpMajorityComparisonScore(pr, \"b\", \"a\") ## [1]  1 -2 if(sum(cpMajorityComparisonScore(pr, \"a\", \"b\")) >= 0) {   print(\"a >= b\") } else {   print(\"b > a\") } ## [1] \"a >= b\" # Now (ac ~ bc) is not counted cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = TRUE) ## [1] 1 0 # Notice that the sum is still the same sum(cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = FALSE)) ==   sum(cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = TRUE)) ## [1] TRUE # extract more information in cpMajorityComparison cpMajorityComparison(pr, \"a\", \"b\") ## a > b ## D_ab = {c, {}} ## D_ba = {c} ## Score of a = 2 ## Score of b = 1 # with strictly set to TRUE, coalition c does # neither appear in D_ab nor in D_ba cpMajorityComparison(pr, \"a\", \"b\", strictly = TRUE) ## a > b ## D_ab = {{}} ## D_ba = {} ## Score of a = 1 ## Score of b = 0"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ordinal-banzhaf","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions","what":"Ordinal Banzhaf","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Ordinal Banzhaf Score vector defined principle marginal contributions. Intuitively speaking, player joining coalition causes move ranking, can interpreted positive contribution. contrary negative contribution means participating causes coalition go ranking. (Ordinal marginal contribution [5]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). given element \\(\\N\\), ordinal marginal contribution \\(m_i^S(\\succsim)\\) right coalition \\(S \\\\mathcal{P}\\) defined : \\[\\begin{equation}     m_i^S(\\succsim) = \\begin{cases}         \\hphantom{-}1 & \\textrm{} S \\cup \\{\\} \\succ S\\\\         -1 & \\textrm{} S \\succ S \\cup \\{\\}\\\\         \\hphantom{-}0 & \\textrm{otherwise}     \\end{cases} \\end{equation}\\] (Ordinal Banzhaf relation) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). Ordinal Banzhaf relation binary relation \\(R^\\succsim_\\textrm{Banz} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{Banz}j \\Leftrightarrow \\text{Score}_\\text{Banz}() \\geq \\text{Score}_\\text{Banz}(j), \\end{equation}\\] \\(\\text{Score}_\\text{Banz}() = \\sum_{S} m^S_i(\\succsim)\\) \\(S \\N\\setminus\\{\\}\\). Note \\(S \\notin \\mathcal{P}\\) \\(S \\cup \\{\\} \\notin \\mathcal{P}\\), \\(m_i^S(\\succsim) = 0\\). function ordinalBanzhafScores() returns three numbers element, number coalitions \\(S\\) player’s contribution positive impact, number coalitions \\(S\\) player’s contribution negative impact, number coalitions \\(S\\) information can gathered, \\(S \\notin \\mathcal{P}\\) \\(S \\cup \\{\\} \\notin \\mathcal{P}\\). sum first two numbers determines score player. Players higher scores rank higher.","code":"pr <- as.PowerRelation(list(c(1,2), c(1), c(2))) pr ## 12 > 1 > 2 # both players 1 and 2 have an Ordinal Banzhaf Score of 1 # therefore they are indifferent to one another # note that the empty set is missing, as such we cannot compare {}u{i} with {} ordinalBanzhafScores(pr) ## $`1` ## [1] 1 0 1 ##  ## $`2` ## [1] 1 0 1 ##  ## attr(,\"class\") ## [1] \"OrdinalBanzhafScores\" ordinalBanzhafRanking(pr) ## 1 ~ 2 pr <- as.PowerRelation(\"ab > a > {} > b\")  # player b has a negative impact on the empty set # -> player b's score is 1 - 1 = 0 # -> player a's score is 2 - 0 = 2 sapply(ordinalBanzhafScores(pr), function(score) sum(score[c(1,2)])) ## a b  ## 2 0 ordinalBanzhafRanking(pr) ## a > b"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ch:copeland","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions","what":"Copeland-like method","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Copeland-like method ranking elements based CP-Majority rule strongly inspired Copeland score social choice theory[15]. score element \\(\\N\\) determined amount pairwise CP-Majority winning comparisons \\(R^\\succsim_\\textrm{CP} j\\), minus number losing comparisons \\(j R^\\succsim_\\textrm{CP} \\) elements \\(j \\N \\setminus \\{\\}\\). (Copeland-like relation [10]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). Copeland-like relation binary relation \\(R^\\succsim_\\textrm{Cop} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{Cop}j \\Leftrightarrow \\text{Score}_\\text{Cop}() \\geq \\text{Score}_\\text{Cop}(j), \\end{equation}\\] \\(\\text{Score}_\\text{Cop}() = |\\{j \\N \\setminus \\{\\}: d_{ij}(\\succsim) \\geq d_{ji}(\\succsim)\\}| - |\\{j \\N \\setminus \\{\\}: d_{ij}(\\succsim) \\leq d_{ji}(\\succsim)\\}|\\) copelandScores(pr) returns two numerical values element, positive number winning comparisons (shown \\(\\text{Score}_\\text{Cop}()\\) left) negative number losing comparisons (\\(\\text{Score}_\\text{Cop}()\\) right).","code":"pr <- as.PowerRelation(\"(abc ~ ab ~ c ~ a) > (b ~ bc) > ac\") scores <- copelandScores(pr)  # Based on CP-Majority, a>=b and a>=c (+2), but b>=a (-1) scores$a ## [1]  2 -1 sapply(copelandScores(pr), sum) ##  a  b  c  ##  1  0 -1 copelandRanking(pr) ## a > b > c"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ch:kramerSimpson","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions","what":"Kramer-Simpson-like method","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Strongly inspired Kramer-Simpson method social choice theory[16, 17], elements ranked inversely greatest pairwise defeat possible CP-Majority comparisons. (Kramer-Simpson-like relation [10]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). Kramer-Simpson-like relation binary relation \\(R^\\succsim_\\textrm{KS} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{KS}j \\Leftrightarrow \\text{Score}_\\text{KS}() \\geq \\text{Score}_\\text{KS}(j), \\end{equation}\\] \\(\\text{Score}_\\text{KS}() = -\\max_j d^*_{ji}(\\succsim)\\) \\(j \\N \\setminus \\{\\}\\). Recall \\(d^*_{ji}(\\succsim)\\) returns number strict relations \\(S \\cup \\{j\\} \\succ S \\cup \\{\\}\\). kramerSimpsonScores(pr) returns vector single numerical value element , sorted highest lowest, gives us ranking solution.","code":"pr <- as.PowerRelation(\"(abc ~ ab ~ c ~ a) > (b ~ bc) > ac\") kramerSimpsonScores(pr) ##  a  b  c  ## -1 -1 -1  ## attr(,\"class\") ## [1] \"KramerSimpsonScores\" kramerSimpsonRanking(pr) ## a ~ b ~ c"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"lexicographical-excellence-solution","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > Lexcel and Dual Lexcel","what":"Lexicographical Excellence Solution","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"idea behind lexicographical excellence solution (Lexcel) reward elements appearing frequently higher ranked equivalence classes. given power relation \\(\\succsim\\) quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), denote \\(i_k\\) number coalitions \\(\\sum_k\\) containing \\(\\): \\[\\begin{equation}     i_k = |\\{S \\\\textstyle \\sum_k: \\S\\}| \\end{equation}\\] \\(k \\\\{1, \\dots, m\\}\\). Now, let \\(\\text{Score}_\\text{Lex}()\\) \\(m\\)-dimensional vector \\(\\text{Score}_\\text{Lex}() = (i_1, \\dots, i_m)\\) associated \\(\\succsim\\). Consider lexicographic order \\(\\geq_\\textrm{Lex}\\) among vectors \\(\\mathbf{}\\) \\(\\mathbf{j}\\): \\(\\mathbf{} \\geq_\\textrm{Lex} \\mathbf{j}\\) either \\(\\mathbf{} = \\mathbf{j}\\) exists \\(t : i_r = j_r, r \\\\{1,\\dots,t-1\\}\\), \\(i_t > j_t\\). (Lexicographic-Excellence relation [8]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) corresponding quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\). Lexicographic-Excellence relation binary relation \\(R^\\succsim_\\textrm{Lex} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{Lex}j \\Leftrightarrow \\text{Score}_\\text{Lex}() \\geq_{\\textrm{Lex}} \\text{Score}_\\text{Lex}(j) \\end{equation}\\] generalizations Lexcel solution see also [9]. Lexcel score vectors similar cumulative score vectors (see section Cumulative Dominance) number times element appears given equivalence class interest. fact, applying base function cumsum element’s lexcel score gives us cumulative score.","code":"pr <- as.PowerRelation(\"12 > (123 ~ 23 ~ 3) > (1 ~ 2) > 13\")  # show the number of times an element appears in each equivalence class # e.g. 3 appears 3 times in [[2]] and 1 time in [[4]] lapply(pr$equivalenceClasses, unlist) ## list() lexScores <- lexcelScores(pr) for(i in names(lexScores))   paste0(\"Lexcel score of element \", i, \": \", lexScores[i])  # at index 1, element 2 ranks higher than 3 lexScores['2'] > lexScores['3'] ## [1] TRUE # at index 2, element 2 ranks higher than 1 lexScores['2'] > lexScores['1'] ## [1] TRUE lexcelRanking(pr) ## 2 > 1 > 3 lexcelCumulated <- lapply(lexScores, cumsum) cumulScores <- cumulativeScores(pr)  paste0(names(lexcelCumulated), \": \", lexcelCumulated, collapse = ', ') ## [1] \"1: 1:4, 2: c(1, 3, 4, 4), 3: c(0, 3, 3, 4)\" paste0(names(cumulScores), \": \", cumulScores, collapse = ', ') ## [1] \"1: 1:4, 2: c(1, 3, 4, 4), 3: c(0, 3, 3, 4)\""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"dual-lexicographical-excellence-solution","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > Lexcel and Dual Lexcel","what":"Dual Lexicographical Excellence Solution","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Similar Lexcel ranking, Dual Lexcel also uses Lexcel score vectors definition 9 establish ranking. However, instead rewarding higher frequencies high ranking coalitions, punishes players appear frequently lower ranking equivalence classes. interpreted sense, punishes mediocrity. Take values \\(i_k\\) \\(k \\\\{1, \\dots, m\\}\\) Lexcel score vector \\(\\text{Score}_\\text{Lex}()\\) section . Consider dual lexicographical order \\(\\geq_\\textrm{DualLex}\\) among vectors \\(\\mathbf{}\\) \\(\\mathbf{j}\\): \\(\\mathbf{} \\geq_\\textrm{DualLex} \\mathbf{j}\\) either \\(\\mathbf{} = \\mathbf{j}\\) exists \\(t: i_t < j_t\\) \\(i_r = j_r, r\\\\{t+1, \\dots, m\\}\\). (Dual Lexicographical-Excellence relation [14]) Let \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\). Dual Lexicographic-Excellence relation binary relation \\(R^\\succsim_\\textrm{DualLex} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succsim_\\textrm{DualLex}j \\Leftrightarrow \\text{Score}_\\text{Lex}() \\geq_\\textrm{DualLex} \\text{Score}_\\text{Lex}(j) \\end{equation}\\] S3 class LexcelScores account Dual Lexcel comparisons. Instead -rev(x) called Lexcel score vector x resulting comparisons produces Dual Lexcel ranking solution.","code":"pr <- as.PowerRelation(\"12 > (123 ~ 23 ~ 3) > (1 ~ 2) > 13\")  lexScores <- lexcelScores(pr)  # in regular Lexcel, 1 scores higher than 3 lexScores['1'] > lexScores['3'] ## [1] TRUE # turn Lexcel score into Dual Lexcel score dualLexScores <- structure(   lapply(lexcelScores(pr), function(r) -rev(r)),   class = 'LexcelScores' )  # now 1 scores lower than 3 dualLexScores['1'] > dualLexScores['3'] ## [1] FALSE # element 2 comes out at the top in both Lexcel and Dual Lexcel lexcelRanking(pr) ## 2 > 1 > 3 dualLexcelRanking(pr) ## 2 > 3 > 1"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"l1-l2-lp-lp","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions","what":"\\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\), \\(L^{p^*}\\)","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"remaining social ranking solutions variation lexcel solutions previous section. rank individuals using lexicographical approach, consider equivalence classes, also size coalitions element appears . answering question player influence group others, may want attribute higher value smaller coalitions. given coalitional ranking \\(\\succsim\\) associated quotient order \\(\\Sigma_1 \\succ \\dots \\succ \\Sigma_m\\), \\(\\text{Score}_\\text{Lex}()\\) produced vector length \\(m\\) index signifying number times \\(\\) appears equivalence class. now extended function \\[M^\\succsim_i = \\text{Score}_\\text{L}() \\\\mathbb{N}^{|N| \\times m}\\] produces matrix. column \\(q\\) corresponds equivalence class, row \\(p\\) coalition size. values defined \\[(M^\\succsim_i)_{p,q} = |\\lbrace S \\\\Sigma_q: |S| = p \\text{ } \\S\\rbrace|.\\] ranking \\((\\{1, 2\\} \\sim \\{1\\} \\sim \\{2, 3\\}) \\succ N \\succ \\varnothing \\succ (\\{1, 3\\} \\sim \\{2\\} \\sim \\{3\\})\\) give use following three matrices. \\[M^\\succsim_1 = \\begin{bmatrix} 1 & 0 & 0 & 0\\\\ 1 & 0 & 0 & 1\\\\ 0 & 1 & 0 & 0 \\end{bmatrix} M^\\succsim_2 = \\begin{bmatrix} 0 & 0 & 0 & 1\\\\ 2 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0 \\end{bmatrix} M^\\succsim_3 = \\begin{bmatrix} 0 & 0 & 0 & 1\\\\ 1 & 0 & 0 & 1\\\\ 0 & 1 & 0 & 0 \\end{bmatrix}\\] matrices can created L1Scores() function. Comparing matrices builds foundation \\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\) \\(L^{p^*}\\) solutions.","code":"pr <- as.PowerRelation('(12 ~ 1 ~ 23) > 123 > {} > (13 ~ 2 ~ 3)') L1Scores(pr) ## $`1` ##      [,1] [,2] [,3] [,4] ## [1,]    1    0    0    0 ## [2,]    1    0    0    1 ## [3,]    0    1    0    0 ##  ## $`2` ##      [,1] [,2] [,3] [,4] ## [1,]    0    0    0    1 ## [2,]    2    0    0    0 ## [3,]    0    1    0    0 ##  ## $`3` ##      [,1] [,2] [,3] [,4] ## [1,]    0    0    0    1 ## [2,]    1    0    0    1 ## [3,]    0    1    0    0 ##  ## attr(,\"class\") ## [1] \"L1Scores\""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"l1","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > \\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\), \\(L^{p^*}\\)","what":"\\(L^{(1)}\\)","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"(\\(L^{(1)}\\) solution [9]) \\(, j \\N\\), \\(L^{(1)}\\) solution ranks \\(\\) \\(j\\) exists \\(p^0 \\\\{1, \\dots, n\\}\\) \\(q^0 \\\\{1, \\dots, m\\}\\) following conditions hold: \\((M^\\succsim_i)_{p,q\\hphantom{^0}} = (M^\\succsim_j)_{p,q\\hphantom{^0}}\\) \\(1 \\leq p \\leq n\\) \\(1 \\leq q < q^0\\), \\((M^\\succsim_i)_{p,q^0} = (M^\\succsim_j)_{p,q^0}\\) \\(1 \\leq p < p^0\\), \\((M^\\succsim_i)_{p^0,q^0} > (M^\\succsim_j)_{p^0,q^0}\\) Put simple terms, comparing two elements \\(\\) \\(j\\) corresponding matrices, first compare first column, top bottom. first row value one higher determines relation. columns , move forward next column. example , lexcel determines 1 ~ 2. However, matrices, 1 higher value first row first column. implies \\(L^{(1)}\\) prefers 1 > 2 simply singleton coalition \\(\\{1\\}\\) appears first equivalence class, whereas \\(\\{2\\}\\) .","code":"L1Ranking(pr) ## 1 > 2 > 3"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"l2","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > \\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\), \\(L^{p^*}\\)","what":"\\(L^{(2)}\\)","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Compared lexcel, \\(L^{(1)}\\) seen little strict enforcing relation based singular coalition discarding others equivalence class. Take instance \\((\\{1\\} \\sim \\{2, 3\\} \\sim \\{2, 4\\} \\sim \\{2, 3, 4\\}) \\succ \\dots\\). Even though \\(2\\) seems lot possibilities cooperate, \\(L^{(1)}\\) prefers \\(1\\) simply coalition appears smaller others. \\(L^{(2)}\\) tries find happy medium two solutions. given equivalence class, first compares total number times element appears (aka., lexcel score). scores , compare corresponding column according \\(L^{(1)}\\). (\\(L^{(2)}\\) solution [9]) \\(, j \\N\\), \\(L^{(2)}\\) solution ranks \\(\\) \\(j\\) exists \\(p^0 \\\\{1, \\dots, n\\}\\) \\(q^0 \\\\{1, \\dots, m\\}\\) following conditions hold: \\((M^\\succsim_i)_{p,q\\hphantom{^0}} = (M^\\succsim_j)_{p,q\\hphantom{^0}}\\) \\(1 \\leq p \\leq n\\) \\(1 \\leq q < q^0\\), Either (2.1) \\(\\text{Score}_\\text{Lex}()_{q^0} > \\text{Score}_\\text{Lex}(j)_{q^0}\\), (2.2) \\((M^\\succsim_i)_{p,q^0} = (M^\\succsim_j)_{p,q^0}\\) \\(1 \\leq p < p^0\\) \\((M^\\succsim_i)_{p^0,q^0} > (M^\\succsim_j)_{p^0,q^0}\\) Note \\(\\text{Score}_\\text{Lex}()_{q^0} = \\sum_{p=1}^{|N|} (M^\\succsim_i)_{p,q^0}\\). make finding sum column easier, values added extra row . also conveniently allows us use traditional \\(L^{(1)}\\) comparison matrices. solution \\(L^{(2)}\\) always coincide either lexcel \\(L^{(1)}\\) solution. example beginning section, comparing \\(1\\) \\(2\\), relation \\(L^{(2)}\\) coincides \\(L^{(1)}\\): sum first column \\(M^\\succsim_1\\) \\(M^\\succsim_2\\) equal \\(2\\), inducing row--row comparison, \\(L^{(1)}\\). latter example subsection, sum first column vectors \\(1\\) \\(2\\) vastly different, causing \\(L^{(2)}\\) coincide lexcel solution.","code":"L2Ranking(pr) ## 1 > 2 > 3 pr2 <- as.PowerRelation('1 ~ 23 ~ 24 ~ 234') pr2 <- appendMissingCoalitions(pr2) L1Ranking(pr2) ## 1 > 2 > 3 ~ 4 L2Ranking(pr2) ## 2 > 3 ~ 4 > 1"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"lp","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > \\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\), \\(L^{p^*}\\)","what":"\\(L^p\\)","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"\\(L^p\\) \\(L^{p^*}\\) differ drastically compare matrices row--row basis rather column--column. puts much higher value smaller coalitions, regardless equivalence class placed . solutions first consider singleton coalition. two given elements \\(\\) \\(j\\), \\(\\{\\} \\succ \\{j\\}\\), relation according \\(L^p\\) \\(L^{p^*}\\) already determined. \\(\\{\\} ~ \\{j\\}\\), every subsequent comparison done number coalitions rank strictly higher. may practical situation want individuals work small groups disregard coalitions ’d better alone. (\\(L^p\\) solution [11]) \\(, j \\N\\), social ranking solution \\(L^p\\) ranks \\(\\) \\(j\\) one following conditions hold: \\(\\lbrace \\rbrace \\succ \\lbrace j \\rbrace\\); \\(\\lbrace \\rbrace, \\lbrace j \\rbrace \\\\Sigma_k\\) exists row \\(p^0 \\\\lbrace 2, \\dots, |N|\\rbrace\\) : \\[\\sum_{q < k} (M^\\succsim_i)_{p,q} = \\sum_{q < k} (M^\\succsim_j)_{p,q}\\quad \\forall p < p^0,\\text{ }\\] \\[\\sum_{q < k} (M^\\succsim_i)_{p^0,q} > \\sum_{q < k} (M^\\succsim_j)_{p^0,q}.\\] \\(L^p\\) looks total number times element chance form better coalition singleton. Since lot information matrix element therefore redundant, LPScores() discards much save space. first value corresponds equivalence class index singleton appears , subsequent value number times able form coalitions size 2, 3, .","code":"LPScores(pr) ## $`1` ## [1] 1 0 0 ##  ## $`2` ## [1] 4 2 1 ##  ## $`3` ## [1] 4 1 1 ##  ## attr(,\"class\") ## [1] \"LPScores\" LPRanking(pr) ## 1 > 2 > 3"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"lp-1","dir":"Articles","previous_headings":"SocialRanking Objects > Social Ranking Solutions > \\(L^{(1)}\\), \\(L^{(2)}\\), \\(L^p\\), \\(L^{p^*}\\)","what":"\\(L^{p^*}\\)","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"taking sum coalitions certain size might informative enough. Similarly \\(L^{(1)}\\) builds granual comparison two elements incorporating coalition size, \\(L^{p^*}\\) can seen granual version \\(L^p\\) incorporating specific equivalence class element appears . (\\(L^{p^*}\\) solution [11]) \\(, j \\N\\), social ranking solution \\(L^{p^*}\\) ranks \\(\\) \\(j\\) one following conditions hold: \\(\\lbrace \\rbrace \\succ \\lbrace j \\rbrace\\); \\(\\lbrace \\rbrace, \\lbrace j \\rbrace \\\\Sigma_k\\) exists row \\(p^0 \\\\lbrace 2, \\dots, |N|\\rbrace\\) column \\(q^0 \\\\lbrace 1, \\dots, k-1\\rbrace\\) : \\[(M^\\succsim_i)_{p,q} = (M^\\succsim_j)_{p,q}\\quad \\forall p < p^0, q < k,\\] \\[(M^\\succsim_i)_{p^0,q} = (M^\\succsim_j)_{p^0,q}\\quad \\forall q < q^0,\\text{ }\\] \\[(M^\\succsim_i)_{p^0,q^0} > (M^\\succsim_j)_{p^0,q^0}.\\] score matrices LPSScores() look similar L1Scores() , difference number columns; equivalence class \\(\\{\\} \\\\Sigma_k\\) \\(\\Sigma_k \\succ \\Sigma_l\\) influence final ranking, columns discarded final matrix.","code":"L1Scores(pr) ## $`1` ##      [,1] [,2] [,3] [,4] ## [1,]    1    0    0    0 ## [2,]    1    0    0    1 ## [3,]    0    1    0    0 ##  ## $`2` ##      [,1] [,2] [,3] [,4] ## [1,]    0    0    0    1 ## [2,]    2    0    0    0 ## [3,]    0    1    0    0 ##  ## $`3` ##      [,1] [,2] [,3] [,4] ## [1,]    0    0    0    1 ## [2,]    1    0    0    1 ## [3,]    0    1    0    0 ##  ## attr(,\"class\") ## [1] \"L1Scores\" LPSScores(pr) ## $`1` ##      ## [1,] ## [2,] ##  ## $`2` ##      [,1] [,2] [,3] ## [1,]    2    0    0 ## [2,]    0    1    0 ##  ## $`3` ##      [,1] [,2] [,3] ## [1,]    1    0    0 ## [2,]    0    1    0 ##  ## attr(,\"class\") ## [1] \"LP*Scores\" LPSRanking(pr) ## 1 > 2 > 3"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"incidence-matrix","dir":"Articles","previous_headings":"Relations","what":"Incidence Matrix","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"vignette focused intuitive aspects power relations social ranking solutions. reiterate, power relation total preorder, reflexive transitive relation \\(\\succsim \\\\mathcal{P} \\times \\mathcal{P}\\), \\(\\sim\\) denotes symmetric part \\(\\succ\\) asymmetric part. power relation can represented incidence matrix \\((b_{ij}) = B \\\\{0,1\\}^{|\\mathcal{P}| \\times |\\mathcal{P}|}\\). Given two coalitions \\(, j \\\\mathcal{P}\\), \\(iRj\\) \\(b_{ij} = 1\\), else \\(0\\). help relations package, functions relations::.relation(pr) powerRelationMatrix(pr) turn PowerRelation object relation object. relations offers ways display relation object incidence matrix relation_incidence(rel) test basic properties relation_is_linear_order(rel), relation_is_acyclic(rel) relation_is_antisymmetric(rel) (see relations package [12]). Note columns rows sorted names relation_domain(rel), hence name preceded ordering number.","code":"pr <- as.PowerRelation(\"ab > a > {} > b\") rel <- relations::as.relation(pr)  relations::relation_incidence(rel) ## Incidences: ##    ab ​a ​​{} ​​​b ## ab  1 1  1 1 ## ​a   0 1  1 1 ## ​​{}  0 0  1 1 ## ​​​b   0 0  0 1 c(   relations::relation_is_acyclic(rel),   relations::relation_is_antisymmetric(rel),   relations::relation_is_linear_order(rel),   relations::relation_is_complete(rel),   relations::relation_is_reflexive(rel),   relations::relation_is_transitive(rel) ) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE # a power relation where coalitions {1} and {2} are indifferent pr <- as.PowerRelation(\"12 > (1 ~ 2)\") rel <- relations::as.relation(pr)  # we have both binary relations {1}R{2} as well as {2}R{1} relations::relation_incidence(rel) ## Incidences: ##    12 ​1 ​​2 ## 12  1 1 1 ## ​1   0 1 1 ## ​​2   0 1 1 # FALSE c(   relations::relation_is_acyclic(rel),   relations::relation_is_antisymmetric(rel),   relations::relation_is_linear_order(rel),   relations::relation_is_complete(rel),   relations::relation_is_reflexive(rel),   relations::relation_is_transitive(rel) ) ## [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"cycles-and-transitive-closure","dir":"Articles","previous_headings":"Relations","what":"Cycles and Transitive Closure","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"cycle power relation exists, one coalition \\(S \\2^N\\) appears twice. example, \\(\\{1,2\\} \\succ (\\{1\\} \\sim \\emptyset) \\succ \\{1,2\\}\\), coalition \\(\\{1,2\\}\\) appears beginning end power relation. Properly handling power relations calculating social ranking solutions cycles somewhat ill-defined, hence warning message shown soon one created. Recall power relation transitive, meaning three coalitions \\(x, y, z \\2^N\\), \\(xRy\\) \\(yRz\\), \\(xRz\\). introduce cycles, pretty much introduce symmetry. Assume power relation \\(x \\succ y \\succ x\\). , even though \\(xRy\\) \\(yRx\\) defined asymmetric part power relation \\(\\succsim\\), together form symmetric power relation \\(x \\sim y\\). transitiveClosure(pr) function turns power relation cycles one without one. process removing duplicate coalitions, turns asymmectric relations within cycle symmetric relations.","code":"as.PowerRelation(\"12 > 2 > (1 ~ 2) > 12\") ## Warning in createLookupTables(equivalenceClasses): Found 2 duplicate coalitions, listed below. This violates transitivity and can cause issues with certain ranking solutions. You may want to take a look at socialranking::transitiveClosure(). ##     - {2} ##     - {1, 2} ## 12 > 2 > (1 ~ 2) > 12 pr <- suppressWarnings(as.PowerRelation(list(1, 2, 1))) pr ## 1 > 2 > 1 transitiveClosure(pr) ## (1 ~ 2) # two cycles, (1>3>1) and (2>23>2) pr <- suppressWarnings(   as.PowerRelation(\"1 > 3 > 1 > 2 > 23 > 2\") )  transitiveClosure(pr) ## (1 ~ 3) > (2 ~ 23) # overlapping cycles pr <- suppressWarnings(   as.PowerRelation(\"c > ac > b > ac > (a ~ b) > abc\") )  transitiveClosure(pr) ## c > (ac ~ b ~ a) > abc"},{"path":[]},{"path":"https://jassler.github.io/socialranking/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Felix Fritz. Author, maintainer. Jochen Staudacher. Author, copyright holder, thesis advisor. Moretti Stefano. Author, copyright holder, thesis advisor.","code":""},{"path":"https://jassler.github.io/socialranking/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Fritz F, Staudacher J, Stefano M (2024). socialranking: Social Ranking Solutions Power Relations Coalitions. R package version 1.1.0, https://github.com/jassler/socialranking.","code":"@Manual{,   title = {socialranking: Social Ranking Solutions for Power Relations on Coalitions},   author = {Felix Fritz and Jochen Staudacher and Moretti Stefano},   year = {2024},   note = {R package version 1.1.0},   url = {https://github.com/jassler/socialranking}, }"},{"path":"https://jassler.github.io/socialranking/index.html","id":"socialranking","dir":"","previous_headings":"","what":"Social Ranking Solutions for Power Relations on Coalitions","title":"Social Ranking Solutions for Power Relations on Coalitions","text":"package socialranking offers functions represent ordinal information coalitions calculate power relation elements players.","code":""},{"path":"https://jassler.github.io/socialranking/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Social Ranking Solutions for Power Relations on Coalitions","text":"Install package directly CRAN : can also install development version socialranking GitHub :","code":"install.packages(\"socialranking\") # install.packages(\"devtools\") devtools::install_github(\"jassler/socialranking\")"},{"path":"https://jassler.github.io/socialranking/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Social Ranking Solutions for Power Relations on Coalitions","text":"package socialranking offers functions represent ordinal information coalitions calculate power relation elements players. installed, call library(socialranking) load package current environment. PowerRelation() .PowerRelation() creates PowerRelation object. createPowerset() convenient function generate PowerRelation() .PowerRelation() function call possible coalitions. functions used analyze power relations can grouped comparison functions, score functions ranking solutions. Ranking solutions produce SocialRankingSolution object. ^1 cpMajorityComparisonScore() faster alternative cpMajorityComparison(), produces less data. PowerRelation objects can turned relations objects relations package using powerRelationMatrix() .relation(). Use browseVignettes(\"socialranking\") information.","code":"library(socialranking) if(interactive()) {   createPowerset(1:3, copyToClipboard = TRUE) }  # pasted, rearranged, adjusted comparators as.PowerRelation(\"   123   > 12   ~ 13   > 2   ~ 23   > 1   > 3 \") #> 123 > (12 ~ 13) > (2 ~ 23) > 1 > 3  # equivalent pr <- as.PowerRelation(   list(c(1,2,3), c(1,2), c(1,3), c(2), c(2,3), c(1), c(3)),   comparators = c(\">\", \"~\", \">\", \"~\", \">\", \">\") )  # equivalent pr <- as.PowerRelation(\"123 > 12 ~ 13 > 2 ~ 23 > 1 > 3\") pr #> 123 > (12 ~ 13) > (2 ~ 23) > 1 > 3  pr$elements #> [1] 1 2 3 pr$eqs[[2]] #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 1 3 dominates(pr, 1, 2) #> [1] FALSE  copelandRanking(pr) #> 1 ~ 2 > 3  lexcelScores(pr, 1) #> $`1` #> [1] 1 2 0 1 0 #>  #> attr(,\"class\") #> [1] \"LexcelScores\""},{"path":"https://jassler.github.io/socialranking/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Social Ranking Solutions for Power Relations on Coalitions","text":"package licensed GPL-3.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L1Scores.html","id":null,"dir":"Reference","previous_headings":"","what":"L1 Ranking — L1Scores","title":"L1 Ranking — L1Scores","text":"Calculate \\(L^{(1)}\\) scores.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L1Scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"L1 Ranking — L1Scores","text":"","code":"L1Scores(powerRelation, elements = powerRelation$elements)  L1Ranking(powerRelation)  lexcel1Scores(powerRelation, elements = powerRelation$elements)  lexcel1Ranking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/L1Scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"L1 Ranking — L1Scores","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() elements Vector elements calculate scores. default, scores elements powerRelation$elements considered.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L1Scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"L1 Ranking — L1Scores","text":"Score function returns list type L1Scores length powerRelation$elements (unless parameter elements specified). index contains vector length powerRelation$eqs, number times given element appears equivalence class. Ranking function returns corresponding SocialRanking object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L1Scores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"L1 Ranking — L1Scores","text":"Similar lexcelRanking(), number times element appears equivalence class counted. addition, now also consider size coalitions. Let \\(N\\) set elements, \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) power relation, \\(\\Sigma_1 \\succ \\Sigma_2 \\succ \\dots \\succ \\Sigma_m\\) corresponding quotient order. element \\(\\N\\), construct matrix \\(M^\\succsim_i\\) \\(m\\) columns \\(|N|\\) rows. Whereas column \\(q\\) represents equivalence class, row \\(p\\) corresponds coalition size. $$(M^\\succsim_i)_{p,q} = |\\lbrace S \\\\Sigma_q: |S| = p \\text{ } \\S\\rbrace|$$ \\(L^{(1)}\\) rewards elements appear higher ranking coalitions well smaller coalitions. comparing two matrices power relation, \\(M^\\succsim_i >_{L^{(1)}} M^\\succsim_j\\), suggests exists \\(p^0 \\\\{1, \\dots, |N|\\}\\) \\(q^0 \\\\{1, \\dots, m\\}\\) following holds: \\((M^\\succsim_i)_{p^0,q^0} > (M^\\succsim_j)_{p^0,q^0}\\) \\((M^\\succsim_i)_{p,q^0} = (M^\\succsim_j)_{p,q^0}\\) \\(p < p^0\\) \\((M^\\succsim_i)_{p,q} = (M^\\succsim_j)_{p,q}\\) \\(q < q^0\\) \\(p \\\\{1, \\dots, |N|\\}\\)","code":""},{"path":"https://jassler.github.io/socialranking/reference/L1Scores.html","id":"example","dir":"Reference","previous_headings":"","what":"Example","title":"L1 Ranking — L1Scores","text":"Let \\(\\succsim: (123 \\sim 13 \\sim 2) \\succ (12 \\sim 1 \\sim 3) \\succ (23 \\sim \\{\\})\\). , get following three matrices: $$ M^\\succsim_1 = \\begin{bmatrix} 0 & 1 & 0\\\\ 1 & 1 & 0\\\\ 1 & 0 & 0 \\end{bmatrix} M^\\succsim_2 = \\begin{bmatrix} 1 & 0 & 0\\\\ 0 & 1 & 1\\\\ 1 & 0 & 0 \\end{bmatrix} M^\\succsim_3 = \\begin{bmatrix} 0 & 1 & 0\\\\ 1 & 0 & 1\\\\ 1 & 0 & 0 \\end{bmatrix} $$ \\((M^\\succsim_2)_{1,1} > (M^\\succsim_1)_{1,1}\\) \\((M^\\succsim_2)_{1,1} > (M^\\succsim_3)_{1,1}\\) immediately follows \\(2\\) ranked \\(1\\) \\(3\\) according \\(L^{(1)}\\). Comparing \\(1\\) \\(3\\) can set \\(p^0 = 2\\) \\(q^0 = 2\\). Following constraints definition , can verify entire column 1 identical. column 2, determine \\((M^\\succsim_1)_{1,q^0} = (M^\\succsim_3)_{1,q^0}\\), whereas \\((M^\\succsim_1)_{p^0,q^0} > (M^\\succsim_3)_{p^0,q^0}\\), indicating \\(1\\) ranked higher \\(3\\), hence \\(2 \\succ 1 \\succ 3\\) according \\(L^{(1)}\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/L1Scores.html","id":"aliases","dir":"Reference","previous_headings":"","what":"Aliases","title":"L1 Ranking — L1Scores","text":"better discoverability, lexcel1Scores() lexcel1Ranking() serve aliases L1Scores() L1Ranking(), respectively.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L1Scores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"L1 Ranking — L1Scores","text":"Algaba E, Moretti S, Rémila E, Solal P (2021). “Lexicographic solutions coalitional rankings.” Social Choice Welfare, 57(4), 1--33.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/L1Scores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"L1 Ranking — L1Scores","text":"","code":"pr <- as.PowerRelation(\"(123 ~ 13 ~ 2) > (12 ~ 1 ~ 3) > (23 ~ {})\") scores <- L1Scores(pr) scores$`1` #>      [,1] [,2] [,3] #> [1,]    0    1    0 #> [2,]    1    1    0 #> [3,]    1    0    0 #      [,1] [,2] [,3] # [1,]    0    1    0 # [2,]    1    1    0 # [3,]    1    0    0  L1Ranking(pr) #> 2 > 1 > 3 # 2 > 1 > 3"},{"path":"https://jassler.github.io/socialranking/reference/L2Scores.html","id":null,"dir":"Reference","previous_headings":"","what":"L2 Ranking — L2Scores","title":"L2 Ranking — L2Scores","text":"Calculate \\(L^{(2)}\\) scores.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L2Scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"L2 Ranking — L2Scores","text":"","code":"L2Scores(powerRelation, elements = powerRelation$elements)  L2Ranking(powerRelation)  lexcel2Scores(powerRelation, elements = powerRelation$elements)  lexcel2Ranking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/L2Scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"L2 Ranking — L2Scores","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() elements Vector elements calculate scores. default, scores elements powerRelation$elements considered.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L2Scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"L2 Ranking — L2Scores","text":"Score function returns list type L2Scores length powerRelation$elements (unless parameter elements specified). index contains matrix length(powerRelation$eqs) columns 1 + length(powerRelation$elements) rows. Ranking function returns corresponding SocialRanking object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L2Scores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"L2 Ranking — L2Scores","text":"Let \\(N\\) set elements, \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) power relation, \\(\\Sigma_1 \\succ \\Sigma_2 \\succ \\dots \\succ \\Sigma_m\\) corresponding quotient order. element \\(\\N\\), construct matrix \\(M^\\succsim_i\\) \\(m\\) columns \\(|N|\\) rows. Whereas column \\(q\\) represents equivalence class, row \\(p\\) corresponds coalition size. $$(M^\\succsim_i)_{p,q} = |\\lbrace S \\\\Sigma_q: |S| = p \\text{ } \\S\\rbrace|$$ Given two elements \\(, j \\N\\), \\(L^{(2)}\\) ranks \\(\\) strictly \\(j\\) row \\(p^0 \\\\lbrace 1, \\dots, |N| \\rbrace\\) column \\(q^0 \\\\lbrace 1, \\dots, m \\rbrace\\) \\(\\sum_{p = 1}^{|N|} (M^\\succsim_i)_{p,q} = \\sum_{p = 1}^{|N|} (M^\\succsim_j)_{p,q}\\text{ } q < q^0\\), \\(\\begin{cases} \\text{()\\hphantom{} either } & \\sum_{p=1}^{|N|} (M^\\succsim_i)_{p,q^0} > \\sum_{p=1}^{|N|} (M^\\succsim_j)_{p,q^0}\\\\[5pt] \\text{(ii) } & (M^\\succsim_i)_{p^0,q^0} > (M^\\succsim_j)_{p^0,q^0} \\text{ } (M^\\succsim_i)_{p,q^0} = (M^\\succsim_j)_{p,q^0} \\text{ } p < p^0 \\end{cases}\\) Note conditions similar L1Ranking(), difference condition 3.() also ranks element another simply appear often equivalence class, regardless coalition size. implies row \\(p^0\\) condition 3.(ii) satisfied may exist.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L2Scores.html","id":"example","dir":"Reference","previous_headings":"","what":"Example","title":"L2 Ranking — L2Scores","text":"Let \\(N = \\lbrace 1, 2, 3, 4 \\rbrace\\) \\(\\succsim: (123 \\sim 12 \\sim 13 \\sim 14 \\sim 2 \\sim 4) \\succ S\\), \\(S\\) every coalition present first equivalence class. , get following four matrices: $$ M^\\succsim_1 = \\begin{bmatrix} 0 & 1\\\\ 3 & 0\\\\ 1 & 2\\\\ 0 & 1 \\end{bmatrix} M^\\succsim_2 = \\begin{bmatrix} 1 & 0\\\\ 1 & 2\\\\ 1 & 2\\\\ 0 & 1 \\end{bmatrix} M^\\succsim_3 = \\begin{bmatrix} 0 & 1\\\\ 1 & 2\\\\ 1 & 2\\\\ 0 & 1 \\end{bmatrix} M^\\succsim_4 = \\begin{bmatrix} 1 & 0\\\\ 1 & 2\\\\ 0 & 3\\\\ 0 & 1 \\end{bmatrix} $$ sums column 1, get $$\\begin{aligned}\\sum_{p=1}^{4} (M^\\succsim_1)_{p,1} &= 4,\\\\\\sum_{p=1}^{4} (M^\\succsim_2)_{p,1} &= 3,\\\\\\sum_{p=1}^{4} (M^\\succsim_3)_{p,1} = \\sum_{p=1}^{4} (M^\\succsim_4)_{p,1} &= 2\\end{aligned}.$$ immediately puts \\(1\\) elements \\(2\\) \\(3\\) \\(4\\) according \\(L^{(2)}\\). \\(L^{(1)}\\) case prefer \\(2\\) \\(1\\), simply \\(2\\) appears coalition size 1 \\(1\\) . Since column sum \\(3\\) \\(4\\) , can next evaluate individual row values also . , since \\((M^\\succsim_4)_{1,1} > (M^\\succsim_3)_{1,1}\\), gives edge element \\(4\\) \\(3\\). Note , column identical \\(3\\) \\(4\\), go next column repeat process. Elements considered indifferent , entire matrix identical two.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L2Scores.html","id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"L2 Ranking — L2Scores","text":"matrices described Béal S, Rémila E, Solal P (2022). “Lexicographic solutions coalitional rankings based individual collective performances.” Journal Mathematical Economics, 102, 102738.  can investigated L1Scores() function. less complexity, another row prepended matrix showing sum column. , simple \\(L^{(1)}\\) comparison can applied.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L2Scores.html","id":"aliases","dir":"Reference","previous_headings":"","what":"Aliases","title":"L2 Ranking — L2Scores","text":"better discoverability, lexcel2Scores() lexcel2Ranking() serve aliases L2Scores() L2Ranking(), respectively.","code":""},{"path":"https://jassler.github.io/socialranking/reference/L2Scores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"L2 Ranking — L2Scores","text":"Algaba E, Moretti S, Rémila E, Solal P (2021). “Lexicographic solutions coalitional rankings.” Social Choice Welfare, 57(4), 1--33.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/L2Scores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"L2 Ranking — L2Scores","text":"","code":"pr <- as.PowerRelation(\"123 ~ 12 ~ 13 ~ 14 ~ 2 ~ 4\") pr <- appendMissingCoalitions(pr) scores <- L2Scores(pr) scores$`1` #>      [,1] [,2] #> [1,]    4    4 #> [2,]    0    1 #> [3,]    3    0 #> [4,]    1    2 #> [5,]    0    1 #      [,1] [,2] # [1,]    0    1 # [2,]    3    0 # [3,]    1    2 # [3,]    0    1  L2Ranking(pr) #> 1 > 2 > 4 > 3 # 1 > 2 > 4 > 3  L1Ranking(pr) #> 2 > 4 > 1 > 3 # 2 > 4 > 1 > 3"},{"path":"https://jassler.github.io/socialranking/reference/LPSScores.html","id":null,"dir":"Reference","previous_headings":"","what":"LP* Ranking — LPSScores","title":"LP* Ranking — LPSScores","text":"Calculate \\(L^{p^*}\\) scores.","code":""},{"path":"https://jassler.github.io/socialranking/reference/LPSScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LP* Ranking — LPSScores","text":"","code":"LPSScores(powerRelation, elements = powerRelation$elements)  LPSRanking(powerRelation)  lexcelPSScores(powerRelation, elements = powerRelation$elements)  lexcelPSRanking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/LPSScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LP* Ranking — LPSScores","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() elements Vector elements calculate scores. default, scores elements powerRelation$elements considered.","code":""},{"path":"https://jassler.github.io/socialranking/reference/LPSScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LP* Ranking — LPSScores","text":"Score function returns list type LP*Scores length powerRelation$elements (unless parameter elements specified). index contains matrix length(powerRelation$elements) rows variable number columns, depending equivalence class index containing singleton coalition element (matrix can 0 columns). Ranking function returns corresponding SocialRanking object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/LPSScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LP* Ranking — LPSScores","text":"Let \\(N\\) set elements, \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) power relation, \\(\\Sigma_1 \\succ \\Sigma_2 \\succ \\dots \\succ \\Sigma_m\\) corresponding quotient order. element \\(\\N\\), construct matrix \\(M^\\succsim_i\\) \\(m\\) columns \\(|N|\\) rows. Whereas column \\(q\\) represents equivalence class, row \\(p\\) corresponds coalition size. $$(M^\\succsim_i)_{p,q} = |\\lbrace S \\\\Sigma_q: |S| = p \\text{ } \\S\\rbrace|$$ \\(, j \\N\\), social ranking solution \\(L^{p^*}\\) ranks \\(\\) strictly \\(j\\) one following conditions hold: \\(\\lbrace \\rbrace \\succ \\lbrace j \\rbrace\\); \\(\\lbrace \\rbrace, \\lbrace j \\rbrace \\\\Sigma_k\\) exists row \\(p_0 \\\\lbrace 2, \\dots, |N|\\rbrace\\) column \\(q_0 \\\\lbrace 1, \\dots, k-1\\rbrace\\) : $$(M^\\succsim_i)_{p,q} = (M^\\succsim_j)_{p,q}\\quad \\forall p < p_0, q < k,$$ $$(M^\\succsim_i)_{p_0,q} = (M^\\succsim_j)_{p_0,q}\\quad \\forall q < q_0,\\text{ }$$ $$(M^\\succsim_i)_{p_0,q_0} > (M^\\succsim_j)_{p_0,q_0}.$$","code":""},{"path":"https://jassler.github.io/socialranking/reference/LPSScores.html","id":"example","dir":"Reference","previous_headings":"","what":"Example","title":"LP* Ranking — LPSScores","text":"Let \\(\\succsim: (123 \\sim 12 \\sim 2) \\succ (13 \\sim 23) \\succ (1 \\sim 3 \\sim \\{\\})\\). , get following three matrices: $$ M^\\succsim_1 = \\begin{bmatrix} 0 & 0 & 1\\\\ 1 & 1 & 0\\\\ 1 & 0 & 0 \\end{bmatrix} M^\\succsim_2 = \\begin{bmatrix} 1 & 0 & 0\\\\ 1 & 0 & 1\\\\ 1 & 0 & 0 \\end{bmatrix} M^\\succsim_3 = \\begin{bmatrix} 0 & 0 & 1\\\\ 0 & 2 & 0\\\\ 1 & 0 & 0 \\end{bmatrix} $$ \\((M^\\succsim_2)_{2,3}\\) context refers value second row third column element 2, case \\(1\\). example, \\(2\\) immediately put \\(1\\) \\(3\\) \\(\\lbrace 2 \\rbrace \\succ \\lbrace 1 \\rbrace\\) \\(\\lbrace 2 \\rbrace \\succ \\lbrace 3 \\rbrace\\). Since \\(\\lbrace 1 \\rbrace \\sim \\lbrace 3 \\rbrace\\), next consider coalitions size 2. , turns \\((M^\\succsim_1)_{2,1} = 1 > 0 = (M^\\succsim_3)_{2,1}\\), setting \\(3\\) least preferred option (opposed \\(L^p\\) relation, strict preference \\(1\\) \\(3\\)). alluded , \\(L^{p^*}\\) similar \\(L^p\\), LPRanking(), first considers singleton coalitions, sequentially every coalition size 2 ranks better corresponding singleton. can assumed, however, \\(L^{p^*}\\) granular, throw away information equivalence class bigger coalitions belong .","code":""},{"path":"https://jassler.github.io/socialranking/reference/LPSScores.html","id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"LP* Ranking — LPSScores","text":"matrices described Béal S, Rémila E, Solal P (2022). “Lexicographic solutions coalitional rankings based individual collective performances.” Journal Mathematical Economics, 102, 102738.  can investigated L1Scores() function. LPSScores() discards redundant information, notably columns element's singleton class ones thereafter. first row also removed, values guaranteed 0. example , actually result matrices","code":"matrix(c(1,1, 1,0), nrow=2) matrix(numeric(), nrow=2) matrix(c(0,1, 2,0), nrow=2)"},{"path":"https://jassler.github.io/socialranking/reference/LPSScores.html","id":"aliases","dir":"Reference","previous_headings":"","what":"Aliases","title":"LP* Ranking — LPSScores","text":"better discoverability, lexcelPSScores() lexcelPSRanking() serve aliases LPSScores() LPSRanking(), respectively.","code":""},{"path":"https://jassler.github.io/socialranking/reference/LPSScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"LP* Ranking — LPSScores","text":"Béal S, Rémila E, Solal P (2022). “Lexicographic solutions coalitional rankings based individual collective performances.” Journal Mathematical Economics, 102, 102738.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/LPSScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LP* Ranking — LPSScores","text":"","code":"pr <- as.PowerRelation(\"(123 ~ 12 ~ 2) > (13 ~ 23) > (1 ~ 3 ~ {})\") scores <- LPSScores(pr) scores$`1` #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    0 #      [,1] [,2] # [1,]    1    1 # [2,]    1    0  scores$`2` #>      #> [1,] #> [2,] # # [1,] # [2,]  LPSRanking(pr) #> 2 > 1 > 3 # 2 > 1 > 3"},{"path":"https://jassler.github.io/socialranking/reference/LpScores.html","id":null,"dir":"Reference","previous_headings":"","what":"LP Ranking — LPScores","title":"LP Ranking — LPScores","text":"Calculate \\(L^{p}\\) scores.","code":""},{"path":"https://jassler.github.io/socialranking/reference/LpScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LP Ranking — LPScores","text":"","code":"LPScores(powerRelation, elements = powerRelation$elements)  LPRanking(powerRelation)  lexcelPScores(powerRelation, elements = powerRelation$elements)  lexcelPRanking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/LpScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LP Ranking — LPScores","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() elements Vector elements calculate scores. default, scores elements powerRelation$elements considered.","code":""},{"path":"https://jassler.github.io/socialranking/reference/LpScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LP Ranking — LPScores","text":"Score function returns list type LPScores length powerRelation$elements (unless parameter elements specified). index contains vector length length(powerRelation$elements). Ranking function returns corresponding SocialRanking object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/LpScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LP Ranking — LPScores","text":"Let \\(N\\) set elements, \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\) power relation, \\(\\Sigma_1 \\succ \\Sigma_2 \\succ \\dots \\succ \\Sigma_m\\) corresponding quotient order. element \\(\\N\\), construct matrix \\(M^\\succsim_i\\) \\(m\\) columns \\(|N|\\) rows. Whereas column \\(q\\) represents equivalence class, row \\(p\\) corresponds coalition size. $$(M^\\succsim_i)_{p,q} = |\\lbrace S \\\\Sigma_q: |S| = p \\text{ } \\S\\rbrace|$$ \\(, j \\N\\), social ranking solution \\(L^p\\) ranks \\(\\) strictly \\(j\\) one following conditions hold: \\(\\lbrace \\rbrace \\succ \\lbrace j \\rbrace\\); \\(\\lbrace \\rbrace, \\lbrace j \\rbrace \\\\Sigma_k\\) exists row \\(p_0 \\\\lbrace 2, \\dots, |N|\\rbrace\\) : $$\\sum_{q < k} (M^\\succsim_i)_{p,q} = \\sum_{q < k} (M^\\succsim_j)_{p,q}\\quad \\forall p < p_0,\\text{ }$$ $$\\sum_{q < k} (M^\\succsim_i)_{p_0,q} > \\sum_{q < k} (M^\\succsim_j)_{p_0,q}.$$ R, given two matrices M_i M_j, comparison expressed ","code":"# function that returns TRUE if i should be ranked strictly above j k_i <- which(M_i[1,] == 1) k_j <- which(M_j[1,] == 1) if(k_i != k_j) return(k_i < k_j) if(k_i == 1)   return(FALSE) # get sum for each row # removing the first row implies that we start in row 2 sums_i <- apply(M_i[-1,seq(k_i-1)], 1, sum) sums_j <- apply(M_j[-1,seq(k_j-1)], 1, sum) # apply lexcel comparison i <- which(a != b) return(length(i) > 0 && a[i[1]] > b[i[1]])"},{"path":"https://jassler.github.io/socialranking/reference/LpScores.html","id":"example","dir":"Reference","previous_headings":"","what":"Example","title":"LP Ranking — LPScores","text":"Let \\(\\succsim: (123 \\sim 12 \\sim 2) \\succ (13 \\sim 23) \\succ (1 \\sim 3 \\sim \\{\\})\\). , get following three matrices: $$ M^\\succsim_1 = \\begin{bmatrix} 0 & 0 & 1\\\\ 1 & 1 & 0\\\\ 1 & 0 & 0 \\end{bmatrix} M^\\succsim_2 = \\begin{bmatrix} 1 & 0 & 0\\\\ 1 & 0 & 1\\\\ 1 & 0 & 0 \\end{bmatrix} M^\\succsim_3 = \\begin{bmatrix} 0 & 0 & 1\\\\ 0 & 2 & 0\\\\ 1 & 0 & 0 \\end{bmatrix} $$ \\((M^\\succsim_2)_{2,3}\\) context refers value second row third column element 2, case \\(1\\). example, \\(2\\) immediately put \\(1\\) \\(3\\) \\(\\lbrace 2 \\rbrace \\succ \\lbrace 1 \\rbrace\\) \\(\\lbrace 2 \\rbrace \\succ \\lbrace 3 \\rbrace\\). Since \\(\\lbrace 1 \\rbrace \\sim \\lbrace 3 \\rbrace\\), next consider coalitions size 2. , turns \\((M^\\succsim_1)_{2,1} + (M^\\succsim_1)_{2,2} = 1 + 1\\) equal \\((M^\\succsim_3)_{2,1} + (M^\\succsim_3)_{2,2} = 0 + 2\\). obvious reasons grand coalition considered, thus \\(1\\) \\(3\\) considered equally powerful \\(L^p\\) solution. \\(L^{p}\\) social ranking solution belonging family lexicographical ranking functions. related L1Ranking(), incorporates property \"standardness\", stating singleton coalition \\(\\lbrace \\rbrace \\succ \\lbrace j\\rbrace\\), ranking solution also prefer \\(\\) \\(j\\). \\(\\lbrace \\rbrace \\sim \\lbrace j\\rbrace\\), coalitions size 2 upward inspected, giving higher precedence coalitions lower number elements. preference similar \\(L^{(1)}\\), differs two notable ways: \\(\\lbrace \\rbrace, \\lbrace j\\rbrace \\\\Sigma_k\\), coalitions \\(S \\succsim (\\lbrace \\rbrace \\sim \\lbrace j \\rbrace)\\) considered, subset coalitions, consider total number coalitions \\(\\) (\\(j\\)) belongs , given coalition size. may ignore information distribution coalitions within different equivalence classes, \\(L^{(1)}\\) slight variation \\(L^{p^*}\\) \\(L^p\\) solution take account.","code":""},{"path":"https://jassler.github.io/socialranking/reference/LpScores.html","id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"LP Ranking — LPScores","text":"matrices described Béal S, Rémila E, Solal P (2022). “Lexicographic solutions coalitional rankings based individual collective performances.” Journal Mathematical Economics, 102, 102738.  can investigated L1Scores() function. efficiency, LPScores() discards much redundant information. Instead matrix element, returns vector size \\(|N|\\). Given score vector v element , v[1] position singleton coalition {}. implies v[1] < w[1], w score vector element j, ranked strictly j. v[2], v[3], ..., v[n] indicates number coalitions size 2, 3, ..., n element appears .","code":""},{"path":"https://jassler.github.io/socialranking/reference/LpScores.html","id":"aliases","dir":"Reference","previous_headings":"","what":"Aliases","title":"LP Ranking — LPScores","text":"better discoverability, lexcelPScores() lexcelPRanking() serve aliases LPScores() LPRanking(), respectively.","code":""},{"path":"https://jassler.github.io/socialranking/reference/LpScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"LP Ranking — LPScores","text":"Béal S, Rémila E, Solal P (2022). “Lexicographic solutions coalitional rankings based individual collective performances.” Journal Mathematical Economics, 102, 102738.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/LpScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LP Ranking — LPScores","text":"","code":"pr <- as.PowerRelation(\"(123 ~ 13 ~ 2) > (12 ~ 1 ~ 3) > (23 ~ {})\") scores <- LPScores(pr) scores$`2` #> [1] 1 0 0 # [1] 1 0 0  LPRanking(pr) #> 2 > 1 ~ 3 # 2 > 1 ~ 3  # Since L^(1) also the relation {1,2}, which ranks above {2,3}, it will place 1 above 3 L1Ranking(pr) #> 2 > 1 > 3 # 2 > 1 > 3"},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":null,"dir":"Reference","previous_headings":"","what":"PowerRelation object — PowerRelation","title":"PowerRelation object — PowerRelation","text":"Create PowerRelation object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PowerRelation object — PowerRelation","text":"","code":"PowerRelation(   equivalenceClasses,   elements = NULL,   coalitionLookup = NULL,   elementLookup = NULL )  is.PowerRelation(x, ...)  # S3 method for PowerRelation print(x, ...)"},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PowerRelation object — PowerRelation","text":"equivalenceClasses nested list lists, containing coalitions groups represented vectors equivalence class. elements Vector elements power relation. set value know . See Details . coalitionLookup function taking vector parameter returning index. See return value details. set value know . elementLookup function taking element returning list 2-sized tuples. See return value details. set value know . x R object. ... Additional arguments passed methods.","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PowerRelation object — PowerRelation","text":"PowerRelation object containing following values: $elements: vector elements $eqs: equivalence classes. Nested list lists, containing vectors representing groups elements equivalence class $coalitionLookup: function(v) taking coalition vector v returning equivalence class belongs . See coalitionLookup() . $elementLookup: function(e) taking element e returning list 2-sized tuples. See elementLookup() .","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"PowerRelation object — PowerRelation","text":"power relation describes ordinal information elements. specifically, interested power relation coalitions, groups elements. coalition assumed vector containing zero (empty coalition), one (singleton) elements. createPowerset() offers convenient way creating power set set elements can used call PowerRelation() .PowerRelation(). Trying figure equivalence class certain coalitions elements belong quite common. sets problems, functions $coalitionLookup(v) $elementLookup(e) utilized. use redundancy speed lookup methods. , highly discouraged edit PowerRelation object directly, different power relation representations fall sync. information, see vignette: vignette(package = 'socialranking') PowerRelation() function expects nested list coalitions input. alternatives, see .PowerRelation().","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"mathematical-background","dir":"Reference","previous_headings":"","what":"Mathematical background","title":"PowerRelation object — PowerRelation","text":"Let \\(N = \\lbrace 1, ..., n \\rbrace\\) finite set elements (also called players). subset \\(S \\subseteq N\\) considered group coalition elements, \\(\\{\\}\\) referred empty coalition, \\(\\{\\}\\) singleton (coalition size 1), \\(N\\) grand coalition. power set \\(2^N\\) denotes set subsets \\(N\\). Let \\(\\mathcal{P} \\subseteq 2^N\\) collection coalitions. power relation \\(\\mathcal{P}\\) total preorder \\(\\succsim \\subseteq \\mathcal{P} \\times \\mathcal{P}\\). , two coalitions \\(S, T \\\\mathcal{P}\\), either \\((S,T) \\\\succsim\\), \\((T,S) \\\\succsim\\), . words, can compare two groups elements \\(\\mathcal{P}\\) determine, one group better , worse , equivalent . commonly, relation \\((S,T) \\\\succsim\\) notated \\(S \\succsim T\\). \\(\\mathcal{T}(\\mathcal{P})\\) denotes family power relations every collection \\(\\mathcal{P} \\subseteq 2^N\\). Given power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\), \\(\\sim\\) denotes symmetric part whereas \\(\\succ\\) asymmetric part. Let \\(S, T \\\\mathcal{P}\\). , $$ S \\sim T \\textrm{ } S \\succsim T \\textrm{ } T \\succsim S,\\\\ S \\succ T \\textrm{ } S \\succsim T \\textrm{ } T \\succsim S. $$ Coalitions deemed equivalent (\\(S \\sim T\\)) can collected equivalence class \\(\\Sigma_i\\). list equivalence classes forms linear order, \\(\\Sigma_1 \\succ \\Sigma_2 \\succ \\dots \\succ \\Sigma_m\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"mathematical-example","dir":"Reference","previous_headings":"","what":"Mathematical example","title":"PowerRelation object — PowerRelation","text":"example, consider elements \\(N = \\{\\textrm{apple}, \\textrm{banana}, \\textrm{chocolate}\\}\\). individually may go well pancakes, also interested combination condiments. consider possibilities, compare sets $$\\mathcal{P} = 2^N = \\{\\{,b,c\\}, \\{,b\\}, \\{,c\\}, \\{b,c\\}, \\{\\}, \\{b\\}, \\{c\\}, \\{\\}\\}.$$ Looking way rank group objects, one may arrive following total preorder \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\): $$\\{b,c\\} \\succ (\\{\\} \\sim \\{c\\}) \\succ \\{b\\} \\succ \\{\\} \\succ (\\{,b,c\\} \\sim \\{,b\\} \\sim \\{, c\\}).$$ particular case, get five equivalence classes. $$\\Sigma_1 = \\{\\{b,c\\}\\}\\\\ \\Sigma_2 = \\{\\{\\}, \\{c\\}\\}\\\\ \\Sigma_3 = \\{\\{b\\}\\}\\\\ \\Sigma_4 = \\{\\{\\}\\}\\\\ \\Sigma_5 = \\{\\{,b,c\\},\\{,b\\},\\{,c\\}\\} $$ power relation \\(\\succsim\\) can copy-pasted character string .PowerRelation() function (accept special characters \\(\\succsim\\) \\(\\sim\\)). .PowerRelation(\"{b,c} > ({} ~ {c}) > {b} > {} > ({,b,c} ~ {,b} ~ {,c})\")","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"PowerRelation object — PowerRelation","text":"Moretti S, Öztürk M (2017). “axiomatic algorithmic perspectives social ranking problem.” International Conference Algorithmic Decision Theory, 166--181. Springer. Bernardi G, Lucchetti R, Moretti S (2019). “Ranking objects preference relation subsets.” Social Choice Welfare, 52(4), 589--606. Algaba E, Moretti S, Rémila E, Solal P (2021). “Lexicographic solutions coalitional rankings.” Social Choice Welfare, 57(4), 1--33.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PowerRelation object — PowerRelation","text":"","code":"pr <- PowerRelation(list(   list(c(1,2,3)),   list(c(1, 2), 2, 3),   list(c(2, 3), c()),   list(c(1, 3)),   list(1) ))  pr #> 123 > (12 ~ 2 ~ 3) > (23 ~ {}) > 13 > 1 # 123 > (12 ~ 2 ~ 3) > (23 ~ {}) > 13 > 1  stopifnot(pr$elements == 1:3) stopifnot(pr$coalitionLookup(1) == 5) stopifnot(pr$coalitionLookup(c()) == 3) stopifnot(pr$coalitionLookup(c(1,2)) == 2)  # find coalitions an element appears in for(t in pr$elementLookup(2)) {   stopifnot(2 %in% pr$eqs[[t[1]]][[t[2]]]) }  # use createPowerset to help generate a valid function call if(interactive())   createPowerset(letters[1:3], result = \"copy\")  # pasted, rearranged using alt+up / alt+down in RStudio  # note that the function call looks different if elements are multiple characters long if(interactive())   createPowerset(c(\"apple\", \"banana\", \"chocolate\"), result = \"copy\")  # pasted clipboard PowerRelation(rlang::list2(   list(c(\"banana\", \"chocolate\")),   list(c(\"apple\"),        c(\"chocolate\")),   list(c(\"banana\")),   list(c()),   list(c(\"apple\", \"banana\", \"chocolate\"),        c(\"apple\", \"banana\"),        c(\"apple\", \"chocolate\")), )) #> {banana, chocolate} > ({apple} ~ {chocolate}) > {banana} > {} > ({apple, banana, chocolate} ~ {apple, banana} ~ {apple, chocolate}) # {banana, chocolate} > ({apple} ~ {chocolate}) > {banana} > {} > ..."},{"path":"https://jassler.github.io/socialranking/reference/appendMissingCoalitions.html","id":null,"dir":"Reference","previous_headings":"","what":"Append missing coalitions — appendMissingCoalitions","title":"Append missing coalitions — appendMissingCoalitions","text":"Append equivalence class power relation coalitions elements appear power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/appendMissingCoalitions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Append missing coalitions — appendMissingCoalitions","text":"","code":"appendMissingCoalitions(powerRelation, includeEmptySet = TRUE)"},{"path":"https://jassler.github.io/socialranking/reference/appendMissingCoalitions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Append missing coalitions — appendMissingCoalitions","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() includeEmptySet TRUE, include empty set last equivalence class missing power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/appendMissingCoalitions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Append missing coalitions — appendMissingCoalitions","text":"PowerRelation object containing following values: $elements: vector elements $eqs: equivalence classes. Nested list lists, containing vectors representing groups elements equivalence class $coalitionLookup: function(v) taking coalition vector v returning equivalence class belongs . See coalitionLookup() . $elementLookup: function(e) taking element e returning list 2-sized tuples. See elementLookup() .","code":""},{"path":"https://jassler.github.io/socialranking/reference/appendMissingCoalitions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Append missing coalitions — appendMissingCoalitions","text":"given set elements \\(N = \\lbrace 1, ..., n \\rbrace\\), PowerRelation object describes total preorder subsets, coalitions, \\(\\mathcal{P} \\subseteq 2^N\\), \\(2^N\\) superset elements. \\(\\mathcal{P} \\neq 2^N\\), means coalitions \\(S \\2^N, S \\notin \\mathcal{P}\\), compare \\(S \\succsim T\\) \\(T \\succsim S\\) every \\(T \\\\mathcal{P}\\). may caused \\(2^N\\) many coalitions consider. certain cases, may interesting consider top ranking coalitions \"shoving\" remaining coalitions back. use-case, appendMissingCoalitions() takes set \\(2^N \\setminus \\mathcal{P}\\) attaches form equivalence class back power relation. .e., take example \\(12 \\succ 13 \\succ (1 \\sim 2)\\). , $$ \\begin{aligned} 2^N &= \\lbrace 123, 12, 13, 23, 1, 2, 3, \\emptyset \\rbrace\\\\ \\mathcal{P} &= \\lbrace 12, 13, 1, 2 \\rbrace\\\\ 2^N \\setminus \\mathcal{P} &= \\lbrace 123, 23, 3, \\emptyset \\rbrace . \\end{aligned} $$ Adding missing coalitions power relation gives us \\(12 \\succ 13 \\succ (1 \\sim 2) \\succ (123 \\sim 23 \\sim 3 \\sim \\emptyset)\\).","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/appendMissingCoalitions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Append missing coalitions — appendMissingCoalitions","text":"","code":"pr <- as.PowerRelation(list(c(1,2), 3)) # 12 > 3  appendMissingCoalitions(pr) #> 12 > 3 > (123 ~ 13 ~ 23 ~ 1 ~ 2 ~ {}) # 12 > 3 > (123 ~ 13 ~ 23 ~ 1 ~ 2 ~ {})  appendMissingCoalitions(pr, includeEmptySet = FALSE) #> 12 > 3 > (123 ~ 13 ~ 23 ~ 1 ~ 2) # 12 > 3 > (123 ~ 13 ~ 23 ~ 1 ~ 2)"},{"path":"https://jassler.github.io/socialranking/reference/as.PowerRelation.html","id":null,"dir":"Reference","previous_headings":"","what":"Create PowerRelation object — as.PowerRelation","title":"Create PowerRelation object — as.PowerRelation","text":"Alternative ways creating PowerRelation objects.","code":""},{"path":"https://jassler.github.io/socialranking/reference/as.PowerRelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create PowerRelation object — as.PowerRelation","text":"","code":"as.PowerRelation(x, ...)  # S3 method for character as.PowerRelation(x, ...)  # S3 method for list as.PowerRelation(x, ..., comparators = c(\">\"))"},{"path":"https://jassler.github.io/socialranking/reference/as.PowerRelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create PowerRelation object — as.PowerRelation","text":"x object ... Optional additional parameters comparators Vector \">\" \"~\" characters","code":""},{"path":"https://jassler.github.io/socialranking/reference/as.PowerRelation.html","id":"using-a-character-string","dir":"Reference","previous_headings":"","what":"Using a character string","title":"Create PowerRelation object — as.PowerRelation","text":"way power relation \\(\\succsim\\) may represented literature (printed PowerRelation object), simple string containing letters, numbers, > ~ can used input new power relation. Every special character ignored, exception \\(\\succsim\\) (\"\\u227B\") \\(\\sim\\) (\"\\u223C\"). Every letter number assumed individual element. \"abc > ac\" therefore represent two coalitions, first one size 3 elements , b, c. method allow elements entered supposed multiple characters long. empty coalitions can simply left blank (.e., \"abc > ~ ac\"), though often clearer curly braces used indicate (.e., \"abc > {} ~ ac\").","code":""},{"path":"https://jassler.github.io/socialranking/reference/as.PowerRelation.html","id":"using-a-list","dir":"Reference","previous_headings":"","what":"Using a list","title":"Create PowerRelation object — as.PowerRelation","text":"Create PowerRelation object unnested list coalition vectors. default, linear order assumed coalitions. .e., given list(c(1,2),1,2), three coalitions put equivalence class, producing 12 > 1 > 2. comparators -can adjusted indicate whether relation two coalitions strict preference > indifference ~.","code":""},{"path":"https://jassler.github.io/socialranking/reference/as.PowerRelation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create PowerRelation object — as.PowerRelation","text":"","code":"# Using character strings as.PowerRelation(\"abc > ab > ({} ~ c) > (a ~ b ~ ac) > bc\") #> abc > ab > ({} ~ c) > (a ~ b ~ ac) > bc # abc > ab > ({} ~ c) > (a ~ b ~ ac) > bc  # using createPowerset(), then shifting coalitions up and down using Alt+Up and Alt+Down if(interactive()) {   createPowerset(1:2, result = \"copy\") } as.PowerRelation(\"   12   > 1   ~ {}   > 2 \") #> 12 > (1 ~ {}) > 2  # Using lists as.PowerRelation(list(c(1,2), 2, c(), 1)) #> 12 > 2 > {} > 1 # 12 > 2 > {} > 1  as.PowerRelation(list(c(1,2), 2, c(), 1), comparators = c(\"~\", \">\", \">\")) #> (12 ~ 2) > {} > 1 # (12 ~ 2) > {} > 1  # the length of comparators doesn't necessarily matter. # If comparators are missing, the existing ones are simply repeated... as.PowerRelation(list(c(1,2), 2, c(), 1), comparators = \"~\") #> (12 ~ 2 ~ {} ~ 1) # (12 ~ 2 ~ {} ~ 1)  as.PowerRelation(list(c(1,2), 2, c(), 1), comparators = c(\"~\", \">\")) #> (12 ~ 2) > ({} ~ 1) # (12 ~ 2) > ({} ~ 1)  # ... or the rest is cut off as.PowerRelation(list(c(1,2), 2, c(), 1), comparators = c(\"~\", \">\", \"~\", \"~\", \">\")) #> (12 ~ 2) > ({} ~ 1) # (12 ~ 2) > ({} ~ 1)"},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":null,"dir":"Reference","previous_headings":"","what":"Are coalitions indifferent — coalitionsAreIndifferent","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"Check coalitions indifferent one another, , words, appear equivalence class.","code":""},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"","code":"coalitionsAreIndifferent(powerRelation, c1, c2)"},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() c1 Coalition vector c2 Coalition vector","code":""},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"Logical value TRUE c1 c2 equivalence class, else FALSE.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"","code":"pr <- PowerRelation(list(list(c(1,2)), list(1, 2)))  stopifnot(coalitionsAreIndifferent(pr, c(1,2), c(1)) == FALSE) stopifnot(coalitionsAreIndifferent(pr, 2, 1) == TRUE)  # Note that it doesn't fail with non-existing power relations stopifnot(coalitionsAreIndifferent(pr, 1, c()) == FALSE) stopifnot(coalitionsAreIndifferent(pr, 3, c(1,2,3)) == TRUE)"},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Copeland-like method — copelandScores","title":"Copeland-like method — copelandScores","text":"Based cpMajorityComparison(), add subtract scores based element fares others. copelandRanking() returns corresponding ranking.","code":""},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copeland-like method — copelandScores","text":"","code":"copelandScores(powerRelation, elements = powerRelation$elements)  copelandRanking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copeland-like method — copelandScores","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() elements Vector elements calculate scores. default, scores elements powerRelation$elements considered.","code":""},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copeland-like method — copelandScores","text":"Score function returns list type CopelandScores length powerRelation$elements (unless parameter elements specified). element vector 2 numbers, number pairwise winning comparisons number pairwise losing comparisons. two numbers summed together gives us actual ordinal Copeland score. Ranking function returns corresponding SocialRanking object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Copeland-like method — copelandScores","text":"Strongly inspired Copeland score social choice theory (Copeland 1951) , Copeland-like solution based net flow CP-majority graph (Allouche et al. 2020) . Individuals ordered according number pairwise winning comparisons, minus number pairwise losing comparisons, set CP-comparisons. formally, given PowerRelation pr element \\(\\), count number elements \\(j \\N \\setminus \\lbrace \\rbrace\\) cpMajorityComparison(pr, , j) >= 0 subtract cpMajorityComparison(pr, , j) <= 0.","code":""},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Copeland-like method — copelandScores","text":"Allouche T, Escoffier B, Moretti S, Öztürk M (2020). “Social Ranking Manipulability CP-Majority, Banzhaf Lexicographic Excellence Solutions.” Bessiere C (ed.), Proceedings Twenty-Ninth International Joint Conference Artificial Intelligence, IJCAI-20, 17--23. doi:10.24963/ijcai.2020/3 , Main track. Copeland AH (1951). “reasonable social welfare function.” mimeo, 1951. University Michigan.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Copeland-like method — copelandScores","text":"","code":"# (123 ~ 12 ~ 3 ~ 1) > (2 ~ 23) > 13 pr <- PowerRelation(list(   list(c(1,2,3), c(1,2), 3, 1),   list(c(2,3), 2),   list(c(1,3)) ))  copelandScores(pr) #> $`1` #> [1]  2 -1 #>  #> $`2` #> [1]  2 -2 #>  #> $`3` #> [1]  1 -2 #>  #> attr(,\"class\") #> [1] \"CopelandScores\" # `1` = c(2, -1) # `2` = c(2, -2) # `3` = c(1, -2)  # only calculate results for two elements copelandScores(pr, c(1,3)) #> $`1` #> [1]  2 -1 #>  #> $`3` #> [1]  1 -2 #>  #> attr(,\"class\") #> [1] \"CopelandScores\" # `1` = c(2, -1) # `3` = c(1, -2)  # or just one element copelandScores(pr, 2) #> $`2` #> [1]  2 -2 #>  #> attr(,\"class\") #> [1] \"CopelandScores\" # `2` = c(2, -2)  # 1 > 2 > 3 copelandRanking(pr) #> 1 > 2 > 3"},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":null,"dir":"Reference","previous_headings":"","what":"CP-Majority relation — cpMajorityComparison","title":"CP-Majority relation — cpMajorityComparison","text":"Ceteris Paribus-majority relation compares relative success two players joining coalition. cpMajorityComparisonScore() returns two numbers, positive number coalitions e1 beats e2, negative number coalitions e1 beaten e2.","code":""},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CP-Majority relation — cpMajorityComparison","text":"","code":"cpMajorityComparison(   powerRelation,   e1,   e2,   strictly = FALSE,   includeEmptySet = TRUE )  cpMajorityComparisonScore(   powerRelation,   e1,   e2,   strictly = FALSE,   includeEmptySet = TRUE )"},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CP-Majority relation — cpMajorityComparison","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() e1, e2 Elements powerRelation$elements strictly include \\(D_{ij}(\\succ)\\) \\(D_{ji}(\\succ)\\), .e., coalitions \\(S \\2^{N \\setminus \\lbrace ,j\\rbrace}\\) \\(S \\cup \\lbrace \\rbrace \\succ S \\cup \\lbrace j\\rbrace\\) vice versa. includeEmptySet TRUE, check \\(\\lbrace \\rbrace \\succsim \\lbrace j \\rbrace\\) even empty set part power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CP-Majority relation — cpMajorityComparison","text":"cpMajorityComparison() returns list elements described details. cpMajorityComparisonScore() returns vector two numbers, positive number coalitions e1 beats e2 (\\(d_{ij}(\\succsim)\\)), negative number coalitions e1 beaten e2 (\\(-d_{ji}(\\succsim)\\)).","code":""},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CP-Majority relation — cpMajorityComparison","text":"Given two elements \\(\\) \\(j\\), go coalition \\(S \\2^{N \\setminus \\lbrace , j \\rbrace}\\). \\(D_{ij}(\\succsim)\\) contains coalitions \\(S\\) \\(S \\cup \\lbrace \\rbrace \\succsim S \\cup \\lbrace j \\rbrace\\) \\(D_{ji}(\\succsim)\\) contains coalitions \\(S \\cup \\lbrace j \\rbrace \\succsim S \\cup \\lbrace \\rbrace\\). cardinalities \\(d_{ij}(\\succsim) = |D_{ij}|\\) \\(d_{ji}(\\succsim) = |D_{ji}|\\) represent score two elements, \\(\\succ j\\)    \\(d_{ij}(\\succsim)   >  d_{ji}(\\succsim)\\) \\(\\sim  j\\)    \\(d_{ij}(\\succsim)  ==  d_{ji}(\\succsim)\\). cpMajorityComparison() tries retain information. list returned contains following information. Note context two elements \\(\\) \\(j\\) refer element 1 element 2 respectively. $e1: list information element 1 $e1$name: name element 1 $e1$score: score \\(d_{ij}(\\succsim)\\). \\(d_{ij}(\\succ)\\) strictly == TRUE $e1$winningCoalitions: list coalition vectors \\(S \\D_{ij}(\\succsim)\\). \\(S \\D_{ij}(\\succ)\\) strictly == TRUE $e2: list information element 2 $e2$name: name element 2 $e1$score: score \\(d_{ji}(\\succsim)\\). \\(d_{ji}(\\succ)\\) strictly == TRUE $e1$winningCoalitions: list coalition vectors \\(S \\D_{ji}(\\succsim)\\).  \\(S \\D_{ji}(\\succ)\\) strictly == TRUE $winner: name higher scoring element. NULL indifferent. $loser: name lower scoring element. NULL indifferent. $tuples: list coalitions \\(S \\2^{N \\setminus \\lbrace , j \\rbrace }\\) : $tuples[[x]]$coalition: vector, coalition \\(S\\) $tuples[[x]]$included: logical, TRUE \\(S \\cup \\lbrace \\rbrace\\) \\(S \\cup \\lbrace j \\rbrace\\) power relation $tuples[[x]]$winner: name winning element \\(\\) \\(S \\cup \\lbrace \\rbrace \\succ S \\cup \\lbrace j \\rbrace\\). NULL \\(S \\cup \\lbrace \\rbrace \\sim S \\cup \\lbrace j \\rbrace\\) $tuples[[x]]$e1: index \\(x_1\\) \\(S \\cup \\lbrace \\rbrace \\\\sum_{x_1}\\) $tuples[[x]]$e2: index \\(x_2\\) \\(S \\cup \\lbrace j \\rbrace \\\\sum_{x_2}\\) much efficient cpMajorityComparisonScore() calculates $e1$score. Unlike Lexcel, Ordinal Banzhaf, etc., power relation can introduce cycles. reason function cpMajorityComparison() cpMajorityComparisonScore() offers direct comparisons two elements ranking players. See CP-majority based functions offer way rank players.","code":""},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"CP-Majority relation — cpMajorityComparison","text":"Haret , Khani H, Moretti S, Öztürk M (2018). “Ceteris paribus majority social ranking.” 27th International Joint Conference Artificial Intelligence (IJCAI-ECAI-18), 303--309. Fayard N, Escoffier MÖ (2018). “Ordinal Social ranking: simulation CP-majority rule.” DA2PL'2018 (Multiple Criteria Decision Aid Preference Learning).","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CP-Majority relation — cpMajorityComparison","text":"","code":"pr <- as.PowerRelation(\"ac > (a ~ b) > (c ~ bc)\")  scores <- cpMajorityComparison(pr, \"a\", \"b\") scores #> a > b #> D_ab = {c, {}} #> D_ba = {{}} #> Score of a = 2 #> Score of b = 1 # a > b # D_ab = {c, {}} # D_ba = {{}} # Score of a = 2 # Score of b = 1  stopifnot(scores$e1$name == \"a\") stopifnot(scores$e2$name == \"b\") stopifnot(scores$e1$score == 2) stopifnot(scores$e2$score == 1) stopifnot(scores$e1$score == length(scores$e1$winningCoalitions)) stopifnot(scores$e2$score == length(scores$e2$winningCoalitions))  # get tuples with coalitions S in 2^(N - {i,j}) emptySetTuple <- Filter(function(x) identical(x$coalition, c()), scores$tuples)[[1]] playerCTuple  <- Filter(function(x) identical(x$coalition, \"c\"), scores$tuples)[[1]]  # because {}u{a} ~ {}u{b}, there is no winner stopifnot(is.null(emptySetTuple$winner)) stopifnot(emptySetTuple$e1 == emptySetTuple$e2)  # because {c}u{a} > {c}u{b}, player \"a\" gets the score stopifnot(playerCTuple$winner == \"a\") stopifnot(playerCTuple$e1 < playerCTuple$e2) stopifnot(playerCTuple$e1 == 1L) stopifnot(playerCTuple$e2 == 3L)  cpMajorityComparisonScore(pr, \"a\", \"b\") # c(1,0) #> [1]  2 -1 cpMajorityComparisonScore(pr, \"b\", \"a\") # c(0,-1) #> [1]  1 -2"},{"path":"https://jassler.github.io/socialranking/reference/createPowerset.html","id":null,"dir":"Reference","previous_headings":"","what":"Create powerset — createPowerset","title":"Create powerset — createPowerset","text":"Given vector elements generate power set.","code":""},{"path":"https://jassler.github.io/socialranking/reference/createPowerset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create powerset — createPowerset","text":"","code":"createPowerset(   elements,   includeEmptySet = TRUE,   result = c(\"return\", \"print\", \"copy\", \"printCompact\", \"copyCompact\") )"},{"path":"https://jassler.github.io/socialranking/reference/createPowerset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create powerset — createPowerset","text":"elements vector elements includeEmptySet TRUE, empty vector added end result result. Can either: \"return\": return list object \"print\": create valid string call PowerRelation() .PowerRelation() print \"copy\": create valid string call PowerRelation() .PowerRelation() copy clipboard \"printCompact\" \"copyCompact\": \"print\" \"copy\" without newlines","code":""},{"path":"https://jassler.github.io/socialranking/reference/createPowerset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create powerset — createPowerset","text":"List power set vectors. parameter result set \"print\" \"copy\", nothing returned. Instead, character string generated can used R call create new PowerRelation object. string either printed copied clipboard (see argument result).","code":""},{"path":"https://jassler.github.io/socialranking/reference/createPowerset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create powerset — createPowerset","text":"","code":"# normal return type is a list of vectors createPowerset(c(\"Alice\", \"Bob\"), includeEmptySet = FALSE) #> [[1]] #> [1] \"Alice\" \"Bob\"   #>  #> [[2]] #> [1] \"Alice\" #>  #> [[3]] #> [1] \"Bob\" #>  ## [[1]] ## [1] \"Alice\" \"Bob\" ## ## [[2]] ## [1] \"Alice\" ## ## [[3]] ## [1] \"Bob\"  # instead of creating a list, print the power set such that it can be copy-pasted # and used to create a new PowerRelation object createPowerset(letters[1:4], result = \"print\") #> as.PowerRelation(\" #>   abcd #>   > abc #>   > abd #>   > acd #>   > bcd #>   > ab #>   > ac #>   > ad #>   > bc #>   > bd #>   > cd #>   > a #>   > b #>   > c #>   > d #>   > {} #> \") # prints # as.PowerRelation(\" #   abcd #   > abc #   > abd #   > acd #   > bcd #   > ab #   ... #   > {} # \")  createPowerset(letters[1:3], includeEmptySet = FALSE, result = \"printCompact\") #> as.PowerRelation(\"abc > ab > ac > bc > a > b > c\") # as.PowerRelation(\"abc > ab > ac > bc > a > b > c\")  # create the same string as before, but now copy it to the clipboard instead if(interactive()) {   createPowerset(1:3, result = \"copyCompact\") }  # Note that as.PowerRelation(character) only assumes single-char elements. # As such, the generated function call string with multi-character names # looks a little different. createPowerset(c(\"Alice\", \"Bob\"), result = \"print\") #> PowerRelation(rlang::list2( #>   list(c(\"Alice\", \"Bob\")), #>   list(c(\"Alice\")), #>   list(c(\"Bob\")), #>   list(c()), #> )) # PowerRelation(rlang::list2( #   list(c(\"Alice\", \"Bob\")), #   list(c(\"Alice\")), #   list(c(\"Bob\")), #   list(c()), # ))"},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative scores — cumulativeScores","title":"Cumulative scores — cumulativeScores","text":"Calculate cumulative score vectors element.","code":""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative scores — cumulativeScores","text":"","code":"cumulativeScores(powerRelation, elements = powerRelation$elements)  cumulativelyDominates(powerRelation, e1, e2, strictly = FALSE)"},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative scores — cumulativeScores","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() elements Vector elements calculate scores. default, scores elements powerRelation$elements considered. e1, e2 Elements powerRelation$elements strictly TRUE, check p1 strictly dominates p2","code":""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative scores — cumulativeScores","text":"Score function returns list type CumulativeScores length powerRelation$elements (unless parameter elements specified). index contains vector length powerRelation$eqs, cumulatively counting number times given element appears equivalence class. cumulativelyDominates() returns TRUE e1 cumulatively dominates e2, else FALSE.","code":""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative scores — cumulativeScores","text":"element's cumulative score vector calculated cumulatively adding amount times appears equivalence class powerRelation. .e., linear power relation eight coalitions, element 1 appears coalitions placed 1, 3, 6, score vector [1, 1, 2, 2, 2, 3, 3, 3].","code":""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"dominance","dir":"Reference","previous_headings":"","what":"Dominance","title":"Cumulative scores — cumulativeScores","text":"\\(\\) dominates \\(j\\) , index \\(x, \\textrm{Score}()_x \\geq \\textrm{Score}(j)_x\\). \\(\\) strictly dominates \\(j\\) exists \\(x\\) \\(\\textrm{Score}()_x > \\textrm{Score}(j)_x\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cumulative scores — cumulativeScores","text":"Moretti S (2015). “axiomatic approach social ranking coalitional power relations.” Homo Oeconomicus, 32(2), 183--208. Moretti S, Öztürk M (2017). “axiomatic algorithmic perspectives social ranking problem.” International Conference Algorithmic Decision Theory, 166--181. Springer.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative scores — cumulativeScores","text":"","code":"pr <- as.PowerRelation(\"12 > 1 > 2\")  # `1`: c(1, 2, 2) # `2`: c(1, 1, 2) cumulativeScores(pr) #> $`1` #> [1] 1 2 2 #>  #> $`2` #> [1] 1 1 2 #>  #> attr(,\"class\") #> [1] \"CumulativeScores\"  # calculate for selected number of elements cumulativeScores(pr, c(2)) #> $`2` #> [1] 1 1 2 #>  #> attr(,\"class\") #> [1] \"CumulativeScores\"  # TRUE d1 <- cumulativelyDominates(pr, 1, 2)  # TRUE d2 <- cumulativelyDominates(pr, 1, 1)  # FALSE d3 <- cumulativelyDominates(pr, 1, 1, strictly = TRUE)  stopifnot(all(d1, d2, !d3))"},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a SocialRanking object — doRanking","title":"Create a SocialRanking object — doRanking","text":"Rank elements based scores.","code":""},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a SocialRanking object — doRanking","text":"","code":"doRanking(scores, compare = NULL, decreasing = TRUE)"},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a SocialRanking object — doRanking","text":"scores vector list representing element's score. names(scores) NULL, used element names. Else number sequence corresponding elements generated. compare Optional comparison function taking two elements returning numerical value based relation two elements. set NULL, default order() function called. See details information. decreasing TRUE (default), elements higher scores ranked higher.","code":""},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a SocialRanking object — doRanking","text":"list type SocialRanking. element list contains vector elements powerRelation$elements indifferent one another.","code":""},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a SocialRanking object — doRanking","text":"ranking solutions package tied scores score vectors elements. kinds solutions, doRanking() offers simple way turns (named) vector list scores element SocialRanking object. example, doRanking(c(=1,b=2)) produces b > (\\(b P^\\succsim \\)), b score 2 placed higher score 1. Ranking solutions package include lexcelRanking(), ordinalBanzhafRanking() L1Ranking(), among others. functions take power relation, calculate scores element returns SocialRanking object. R natively supports sorting vectors, lists. use lists necessary, native sort method vectors produce desired results, two possible ways solve : introduction custom S3 classes, setting compare parameter doRanking(). S3 classes, class score object set == > ([ lists) operators overloaded. .e., lexcelScores() returns list custom class LexcelScores implements ==.LexcelScores, >.LexcelScores, [.LexcelScores .na.LexcelScores. cases want experiment, introducing new S3 classes can cumbersome. alternative, compare parameter can assigned function. function must take two parameters, .e., function(, b), b scores two arbitrary elements. function must return one following: > 0 (positive value) score ranked higher score b, < 0 (negative value) score ranked lower score b, = 0 scores b considered equal. doRanking(c(=3,b=2,c=2), compare = function(,b) - b), compare function returns positive value first parameter larger second. highest value ranked highest, > b ~ c. Conversely, doRanking(c(=3,b=2,c=2), compare = function(,b) b - ) favors elements lower scores, resulting element ranking b ~ c > .","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a SocialRanking object — doRanking","text":"","code":"doRanking(c(a=1,b=2)) #> b > a # b > a  doRanking(c(a=2,b=2)) #> a ~ b # a ~ b  # a custom ranking function. Here, we implement the following ranking solution: # disregard any big coalitions and only rank elements based on their individual performances # iRj if and only if {i} >= {j} singletonRanking <- function(pr) {   scores <- sapply(pr$elements, equivalenceClassIndex, powerRelation = pr)   # note that coalitions in higher indexed equivalence classes are less preferable   # hence, scores should be sorted in an increasing order   doRanking(scores, decreasing = FALSE) }  pr <- as.PowerRelation(\"abc > ab > ac > b ~ c ~ bc > a\") singletonRanking(pr) #> b ~ c > a # b ~ c > a  # a reverse lexcel ranking, where vectors are compared right to left # here, we introduce a compare function. It returns: # * 0, if a and b are identical # * a positive value, if a[i] > b[i] and every value after that is equal # * a negative value, if a[i] < b[i] and every value after that is equal reverseLexcelCompare <- function(a, b) {   i <- which(a != b) |> rev()   if(length(i) == 0) 0   else a[i[1]] - b[i[1]] }  scores <- unclass(cumulativeScores(pr))  # R cannot natively sort a class. Instead: # Method 1 - utilize the compare parameter doRanking(scores, compare = reverseLexcelCompare) #> b > c > a   # Method 2 - introduce S3 class `[.RevLex` <- function(x, i, ...) structure(unclass(x)[i], class = \"RevLex\") `==.RevLex` <- function(a, b) reverseLexcelCompare(a[[1]],b[[1]]) == 0 `>.RevLex` <- function(a, b) reverseLexcelCompare(a[[1]],b[[1]]) > 0 is.na.RevLex <- function(x) FALSE doRanking(structure(scores, class = \"RevLex\")) #> Error in rank(x, ties.method = \"min\", na.last = \"keep\"): unimplemented type 'list' in 'greater'  stopifnot(   doRanking(scores, compare = reverseLexcelCompare) ==   doRanking(structure(scores, class = \"RevLex\")) ) #> Error in rank(x, ties.method = \"min\", na.last = \"keep\"): unimplemented type 'list' in 'greater'"},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":null,"dir":"Reference","previous_headings":"","what":"Dominance — dominates","title":"Dominance — dominates","text":"Check one element dominates .","code":""},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dominance — dominates","text":"","code":"dominates(powerRelation, e1, e2, strictly = FALSE, includeEmptySet = TRUE)"},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dominance — dominates","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() e1, e2 Elements powerRelation$elements strictly TRUE, check p1 strictly dominates p2 includeEmptySet TRUE, check \\(\\lbrace \\rbrace \\succsim \\lbrace j \\rbrace\\) even empty set part power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dominance — dominates","text":"Logical value TRUE e1 dominates e2, else FALSE.","code":""},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dominance — dominates","text":"\\(\\) said dominate \\(j\\) \\(S \\cup \\lbrace \\rbrace \\succsim S \\cup \\lbrace j \\rbrace\\) \\(S \\2^{N \\setminus \\lbrace ,j \\rbrace}\\). \\(\\) strictly dominates \\(j\\) also exists \\(S \\2^{N \\setminus \\lbrace ,j \\rbrace}\\) \\(S \\cup \\lbrace \\rbrace \\succ S \\cup \\lbrace j \\rbrace\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dominance — dominates","text":"","code":"pr <- as.PowerRelation(\"12 > 1 > 2\")  # TRUE d1 <- dominates(pr, 1, 2)  # FALSE d2 <- dominates(pr, 2, 1)  # TRUE (because it's not strict dominance) d3 <- dominates(pr, 1, 1)  # FALSE d4 <- dominates(pr, 1, 1, strictly = TRUE)  stopifnot(all(d1, !d2, d3, !d4))"},{"path":"https://jassler.github.io/socialranking/reference/elementLookup.html","id":null,"dir":"Reference","previous_headings":"","what":"Element lookup — elementLookup","title":"Element lookup — elementLookup","text":"List coalitions element appears .","code":""},{"path":"https://jassler.github.io/socialranking/reference/elementLookup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Element lookup — elementLookup","text":"","code":"elementLookup(powerRelation, element)"},{"path":"https://jassler.github.io/socialranking/reference/elementLookup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Element lookup — elementLookup","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() element element powerRelation$elements","code":""},{"path":"https://jassler.github.io/socialranking/reference/elementLookup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Element lookup — elementLookup","text":"List tuples, size 2. First value tuple indicates equivalence class index, second value index inside equivalence class coalition containing element. Returns NULL element exist.","code":""},{"path":"https://jassler.github.io/socialranking/reference/elementLookup.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Element lookup — elementLookup","text":"function calls powerRelation$elementLookup(element). returned list contains tuples containing index find corresponding coalitions powerRelation$eqs.  elementLookup(powerRelation, 2) returns list(c(1,1), c(1,2), c(3,1)), can determine element 2 appears twice equivalence class 1 equivalence class 3. specific coalition can accessed powerRelation$eqs[[]][[j]], equivalence class index j coalition equivalence class containing element.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/elementLookup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Element lookup — elementLookup","text":"","code":"pr <- as.PowerRelation(\"12 > 2 ~ 1\")  l <- elementLookup(pr, 1) l #> [[1]] #> [1] 1 1 #>  #> [[2]] #> [1] 2 2 #>  # (1,1), (2,2)  sapply(l, function(tuple) 1 %in% pr$eqs[[tuple[1]]][[tuple[2]]]) |> all() |> stopifnot()  # if element does not exist, it returns NULL elementLookup(pr, 3) |> is.null() |> stopifnot()"},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":null,"dir":"Reference","previous_headings":"","what":"Get index of equivalence class containing a coalition — equivalenceClassIndex","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"Given coalition vector, return equivalence class index appears .","code":""},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"","code":"equivalenceClassIndex(powerRelation, coalition)  coalitionLookup(powerRelation, coalition)"},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() coalition coalition vector part powerRelation","code":""},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"Numeric value, equivalence class index containing coalition. NULL coalition exist. powerRelation contains cycles, possible multiple values returned.","code":""},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"function calls powerRelation$coalitionLookup(coalition). equivalenceClassIndex() serves alias coalitionLookup().","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"","code":"pr <- as.PowerRelation(\"12 > 2 ~ 1\")  (e1 <- equivalenceClassIndex(pr, c(1, 2))) #> [1] 1 # 1  (e2 <- equivalenceClassIndex(pr, c(1))) #> [1] 2 # 2  (e3 <- equivalenceClassIndex(pr, c(2))) #> [1] 2 # 2  (e4 <- equivalenceClassIndex(pr, c())) #> NULL # NULL <- empty set does not exist  stopifnot(all(c(e1,e2,e3,e4) == c(1,2,2)))"},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Kramer-Simpson-like method — kramerSimpsonScores","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"Calculate Kramer-Simpson-like scores. Higher scores better. kramerSimpsonRanking() returns corresponding ranking.","code":""},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"","code":"kramerSimpsonScores(powerRelation, elements = powerRelation$elements)  kramerSimpsonRanking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() elements Vector elements calculate scores. default, scores elements powerRelation$elements considered.","code":""},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"Score function returns vector type KramerSimpsonScores length powerRelation$elements (unless parameter elements specified). Higher scoring elements ranked higher. Ranking function returns corresponding SocialRanking object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"Inspired Kramer-Simpson method social choice theory (Simpson 1969)  (Kramer 1975) , Kramer-Simpson-like method compares element elements using CP-Majority rule. given element \\(\\), calculate cpMajorityComparisonScore() elements \\(j\\), \\(d_{ji}(\\succsim)\\) (notice \\(\\) \\(j\\) reverse order). \\(-\\max_{j \\N \\setminus \\lbrace \\rbrace}(d_{ji}(\\succsim))\\) determines final score, higher scoring elements ranked higher (notice negative symbol front \\(\\max\\) statement). implementation slightly differs original definition Allouche T, Escoffier B, Moretti S, Öztürk M (2020). “Social Ranking Manipulability CP-Majority, Banzhaf Lexicographic Excellence Solutions.” Bessiere C (ed.), Proceedings Twenty-Ninth International Joint Conference Artificial Intelligence, IJCAI-20, 17--23. doi:10.24963/ijcai.2020/3 , Main track. . ranking solution , scores package intentionally multiplied -1, significantly improves performance sorting elements, well making simple comparisons elements logical user.","code":""},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"Allouche T, Escoffier B, Moretti S, Öztürk M (2020). “Social Ranking Manipulability CP-Majority, Banzhaf Lexicographic Excellence Solutions.” Bessiere C (ed.), Proceedings Twenty-Ninth International Joint Conference Artificial Intelligence, IJCAI-20, 17--23. doi:10.24963/ijcai.2020/3 , Main track. Simpson PB (1969). “defining areas voter choice: Professor Tullock stable voting.” Quarterly Journal Economics, 83(3), 478--490. Kramer GH (1975). “dynamical model political equilibrium.” Journal Economic Theory, 16(2), 310--334.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"","code":"# 2 > (1 ~ 3) > 12 > (13 ~ 23) > {} > 123 pr <- as.PowerRelation(\"2 > (1~3) > 12 > (13~23) > {} > 123\")  # get scores for all elements # cpMajorityComparisonScore(pr, 2, 1, strictly = TRUE)[1] = 1 # cpMajorityComparisonScore(pr, 3, 1, strictly = TRUE)[1] = 0 # therefore the Kramer-Simpson-Score for element # `1` = -max(0, 1) = -1 # # Score analogous for the other elements # `2` = 0 # `3` = -2 kramerSimpsonScores(pr) #>  1  2  3  #> -1  0 -2  #> attr(,\"class\") #> [1] \"KramerSimpsonScores\"  # get scores for two elements # `1` = 1 # `3` = 2 kramerSimpsonScores(pr, c(1,3)) #>  1  3  #> -1 -2  #> attr(,\"class\") #> [1] \"KramerSimpsonScores\"  # or single element # result is still a list kramerSimpsonScores(pr, 2) #> 2  #> 0  #> attr(,\"class\") #> [1] \"KramerSimpsonScores\"  # 2 > 1 > 3 kramerSimpsonRanking(pr) #> 2 > 1 > 3"},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Lexicographical Excellence — lexcelScores","title":"Lexicographical Excellence — lexcelScores","text":"Calculate Lexicographical Excellence (Lexcel) score. lexcelRanking() returns corresponding ranking. dualLexcelRanking() uses score vectors instead rewarding participation, punishes mediocrity.","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lexicographical Excellence — lexcelScores","text":"","code":"lexcelScores(powerRelation, elements = powerRelation$elements)  lexcelRanking(powerRelation)  dualLexcelRanking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lexicographical Excellence — lexcelScores","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() elements Vector elements calculate scores. default, scores elements powerRelation$elements considered.","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lexicographical Excellence — lexcelScores","text":"Score function returns list type LexcelScores length powerRelation$elements (unless parameter elements specified). index contains vector length powerRelation$eqs, number times given element appears equivalence class. Ranking function returns corresponding SocialRanking object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lexicographical Excellence — lexcelScores","text":"equivalence class \\(\\sum_i\\) contains coalitions indifferent one another. given power relation created PowerRelation() .PowerRelation(), equivalence classes saved $eqs. example, consider power relation \\(\\succsim: 123 \\succ (12 \\sim 13 \\sim 1 \\sim \\emptyset) \\succ (23 \\sim 1 \\sim 2)\\). corresponding equivalence classes : $$ \\sum_1 = \\lbrace 123 \\rbrace, \\sum_2 = \\lbrace 12, 13, 1, \\emptyset \\rbrace, \\sum_3 = \\lbrace 23, 1, 2 \\rbrace. $$ lexcel score element vector wherein index indicates number times element appears equivalence class. example, get $$\\textrm{lexcel}(1) = [ 1, 3, 1 ], \\textrm{lexcel}(2) = [ 1, 1, 2 ], \\textrm{lexcel}(3) = [ 1, 1, 1 ].$$","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"lexcel-ranking","dir":"Reference","previous_headings":"","what":"Lexcel Ranking","title":"Lexicographical Excellence — lexcelScores","text":"\"excellent contribution\" element determines ranking elements. Given two Lexcel score vectors \\(\\textrm{Score}()\\) \\(\\textrm{Score}(j)\\), first index \\(x\\) \\(\\textrm{Score}()_x \\neq \\textrm{Score}(j)_x\\) determines element ranked higher. previous example \\(1 > 2 > 3\\), : \\(\\textrm{Score}(1)_2 = 3 > \\textrm{Score}(2)_2 = \\textrm{Score}(3)_2 = 1\\), \\(\\textrm{Score}(2)_3 = 2 > \\textrm{Score}(3)_3 = 1\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"dual-lexcel-ranking","dir":"Reference","previous_headings":"","what":"Dual Lexcel Ranking","title":"Lexicographical Excellence — lexcelScores","text":"dual lexcel works reverse order , instead rewarding high scores, punishes mediocrity. case get \\(3 > 1 > 2\\) : \\(\\textrm{Score}(3)_3 < \\textrm{Score}(2)_3\\) \\(\\textrm{Score}(3)_2 < \\textrm{Score}(1)_2\\), \\(\\textrm{Score}(1)_3 < \\textrm{Score}(2)_3\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lexicographical Excellence — lexcelScores","text":"Bernardi G, Lucchetti R, Moretti S (2019). “Ranking objects preference relation subsets.” Social Choice Welfare, 52(4), 589--606. Algaba E, Moretti S, Rémila E, Solal P (2021). “Lexicographic solutions coalitional rankings.” Social Choice Welfare, 57(4), 1--33. Serramia M, López-Sánchez M, Moretti S, Rodríguez-Aguilar JA (2021). “dominant set selection problem application value alignment.” Autonomous Agents Multi-Agent Systems, 35(2), 1--38.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lexicographical Excellence — lexcelScores","text":"","code":"# note that the coalition {1} appears twice # 123 > 12 ~ 13 ~ 1 ~ {} > 23 ~ 1 ~ 2 # E = {123} > {12, 13, 1, {}} > {23, 1, 2} pr <- suppressWarnings(as.PowerRelation(   \"123 > (12 ~ 13 ~ 1 ~ {}) > (23 ~ 1 ~ 2)\" ))  # lexcel scores for all elements # `1` = c(1, 3, 1) # `2` = c(1, 1, 2) # `3` = c(1, 1, 1) lexcelScores(pr) #> $`1` #> [1] 1 3 1 #>  #> $`2` #> [1] 1 1 2 #>  #> $`3` #> [1] 1 1 1 #>  #> attr(,\"class\") #> [1] \"LexcelScores\"  # lexcel scores for a subset of all elements lexcelScores(pr, c(1, 3)) #> $`1` #> [1] 1 3 1 #>  #> $`3` #> [1] 1 1 1 #>  #> attr(,\"class\") #> [1] \"LexcelScores\" lexcelScores(pr, 2) #> $`2` #> [1] 1 1 2 #>  #> attr(,\"class\") #> [1] \"LexcelScores\"  # 1 > 2 > 3 lexcelRanking(pr) #> 1 > 2 > 3  # 3 > 1 > 2 dualLexcelRanking(pr) #> 3 > 1 > 2"},{"path":"https://jassler.github.io/socialranking/reference/makePowerRelationMonotonic.html","id":null,"dir":"Reference","previous_headings":"","what":"Make Power Relation monotonic — makePowerRelationMonotonic","title":"Make Power Relation monotonic — makePowerRelationMonotonic","text":"Given powerRelation object, make order monotonic.","code":""},{"path":"https://jassler.github.io/socialranking/reference/makePowerRelationMonotonic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make Power Relation monotonic — makePowerRelationMonotonic","text":"","code":"makePowerRelationMonotonic(powerRelation, addMissingCoalitions = TRUE)"},{"path":"https://jassler.github.io/socialranking/reference/makePowerRelationMonotonic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make Power Relation monotonic — makePowerRelationMonotonic","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() addMissingCoalitions TRUE, also include coalitions power set powerRelation$elements present current power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/makePowerRelationMonotonic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make Power Relation monotonic — makePowerRelationMonotonic","text":"PowerRelation object containing following values: $elements: vector elements $eqs: equivalence classes. Nested list lists, containing vectors representing groups elements equivalence class $coalitionLookup: function(v) taking coalition vector v returning equivalence class belongs . See coalitionLookup() . $elementLookup: function(e) taking element e returning list 2-sized tuples. See elementLookup() .","code":""},{"path":"https://jassler.github.io/socialranking/reference/makePowerRelationMonotonic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make Power Relation monotonic — makePowerRelationMonotonic","text":"power relation monotonic $$T \\subset S \\Leftrightarrow S \\succsim T.$$ every coalition \\(S \\subseteq N\\). Calling makePowerRelationMonotonic() PowerRelation object moves adds coalitions certain equivalence classes power relation becomes monotonic.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/makePowerRelationMonotonic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make Power Relation monotonic — makePowerRelationMonotonic","text":"","code":"pr <- as.PowerRelation(\"ab > ac > abc > b > a > {} > c > bc\") makePowerRelationMonotonic(pr) #> (abc ~ ab) > ac > (bc ~ b) > a > (c ~ {}) # (abc ~ ab) > ac > (bc ~ b) > a > (c ~ {})  # notice that missing coalitions are automatically added, # except for the empty set pr <- as.PowerRelation(\"a > b > c\") makePowerRelationMonotonic(pr) #> (abc ~ ab ~ ac ~ a) > (bc ~ b) > c # (abc ~ ab ~ ac ~ a) > (bc ~ b) > c  # setting addMissingCoalitions to FALSE changes this behavior pr <- as.PowerRelation(\"a > ab > c ~ {} > b\") makePowerRelationMonotonic(pr, addMissingCoalitions = FALSE) #> (ab ~ a) > (b ~ c ~ {}) # (ab ~ a) > (b ~ c ~ {})  # notice that an equivalence class containing an empty coalition # automatically moves all remaining coalitions to that equivalence class. pr <- as.PowerRelation(\"a > {} > b > c\") makePowerRelationMonotonic(pr) #> (abc ~ ab ~ ac ~ a) > (bc ~ b ~ c ~ {}) # (abc ~ ab ~ ac ~ a) > (bc ~ b ~ c ~ {})"},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":null,"dir":"Reference","previous_headings":"","what":"New Power Relation — newPowerRelation","title":"New Power Relation — newPowerRelation","text":"Deprecated. Use PowerRelation() instead.","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"New Power Relation — newPowerRelation","text":"","code":"newPowerRelation(...)"},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"New Power Relation — newPowerRelation","text":"... parameter.","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"New Power Relation — newPowerRelation","text":"return value.","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelationFromString.html","id":null,"dir":"Reference","previous_headings":"","what":"New PowerRelation object — newPowerRelationFromString","title":"New PowerRelation object — newPowerRelationFromString","text":"Deprecated. Use .PowerRelation() instead.","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelationFromString.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"New PowerRelation object — newPowerRelationFromString","text":"","code":"newPowerRelationFromString(...)"},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelationFromString.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"New PowerRelation object — newPowerRelationFromString","text":"... parameter.","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelationFromString.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"New PowerRelation object — newPowerRelationFromString","text":"return value.","code":""},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Ordinal Banzhaf ranking — ordinalBanzhafScores","title":"Ordinal Banzhaf ranking — ordinalBanzhafScores","text":"Calculate Ordinal Banzhaf scores, number positive number negative marginal contributions. ordinalBanzhafRanking() returns corresponding ranking.","code":""},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ordinal Banzhaf ranking — ordinalBanzhafScores","text":"","code":"ordinalBanzhafScores(powerRelation, elements = powerRelation$elements)  ordinalBanzhafRanking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ordinal Banzhaf ranking — ordinalBanzhafScores","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() elements Vector elements calculate scores. default, scores elements powerRelation$elements considered.","code":""},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ordinal Banzhaf ranking — ordinalBanzhafScores","text":"Score function returns list class type OrdinalBanzhafScores length powerRelation$elements. index contains vector three numbers, number positive marginal contributions, number negative marginal contributions, number coalitions comparison done. first two numbers summed together gives us actual ordinal Banzhaf score. Ranking function returns corresponding SocialRanking object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ordinal Banzhaf ranking — ordinalBanzhafScores","text":"Inspired Banzhaf index (Banzhaf III 1964) , Ordinal Banzhaf determines score element \\(\\) adding amount coalitions \\(S \\subseteq N \\setminus \\lbrace \\rbrace\\) contribution impacts positively (\\(S \\cup \\lbrace \\rbrace \\succ S\\)) subtracting amount coalitions contribution negative impact (\\(S \\succ S \\cup \\lbrace \\rbrace\\))(Khani et al. 2019) . original definition takes total power relations account, either \\(S \\succsim T\\) \\(T \\succsim S\\) every \\(S,T \\subseteq N\\). coalitions missing power relation, may able perform certain comparisons. indicate missing comparisons, ordinal Banzhaf score element \\(\\) also includes number index 3. .e., ordinal Banzhaf score element c(4, -2, 1), means contributed positively 4 coalitions negatively 2 others. one coalition, comparison made.","code":""},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Ordinal Banzhaf ranking — ordinalBanzhafScores","text":"Khani H, Moretti S, Öztürk M (2019). “ordinal banzhaf index social ranking.” 28th International Joint Conference Artificial Intelligence (IJCAI 2019), 378--384. Banzhaf III JF (1964). “Weighted voting work: mathematical analysis.” Rutgers L. Rev., 19, 317.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ordinal Banzhaf ranking — ordinalBanzhafScores","text":"","code":"pr <- as.PowerRelation(\"12 > (2 ~ {}) > 1\")  # Player 1 contributes positively to {2} # Player 1 contributes negatively to {empty set} # Therefore player 1 has a score of 1 - 1 = 0 # # Player 2 contributes positively to {1} # Player 2 does NOT have an impact on {empty set} # Therefore player 2 has a score of 1 - 0 = 0 ordinalBanzhafScores(pr) #> $`1` #> [1]  1 -1  0 #>  #> $`2` #> [1] 1 0 0 #>  #> attr(,\"class\") #> [1] \"OrdinalBanzhafScores\" # `1` = c(1, -1, 0) # `2` = c(1, 0, 0)  ordinalBanzhafRanking(pr) #> 2 > 1 # 1 > 2"},{"path":"https://jassler.github.io/socialranking/reference/powerRelationGenerator.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate power relations — powerRelationGenerator","title":"Generate power relations — powerRelationGenerator","text":"Based list coalitions, create generator function returns new PowerRelation object every call. NULL returned every possible power relation generated. Alternatively, use generateRandomPowerRelation() create random power relations.","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationGenerator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate power relations — powerRelationGenerator","text":"","code":"powerRelationGenerator(coalitions, startWithLinearOrder = FALSE)  generateNextPartition(gen)  generateRandomPowerRelation(coalitions, linearOrder = FALSE, monotonic = FALSE)"},{"path":"https://jassler.github.io/socialranking/reference/powerRelationGenerator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate power relations — powerRelationGenerator","text":"coalitions List coalition vectors. empty coalition can set c(). startWithLinearOrder set TRUE, first PowerRelation object generated linear order order list coalitions given. set FALSE, first PowerRelation object generated single equivalence class containing coalitions, , every coalition equally powerful. gen generator object returned powerRelationGenerator(). linearOrder logical, TRUE, linear orders generated. monotonic logical, TRUE, monotonic power relations created (see makePowerRelationMonotonic()).","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationGenerator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate power relations — powerRelationGenerator","text":"generator function. Every time generator function called, different PowerRelation object returned. possible power relations generated, generator function returns NULL. generator function. generator already last partition, throw error. Use generateNextPartition(gen) skip next partition generator.","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationGenerator.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate power relations — powerRelationGenerator","text":"Using partitions library, partitions::compositions() used create possible partitions set coalitions. every partition, partitions::multinomial() used create permutations order coalitions. Note number power relations (total preorders) grows incredibly fast. Stirling number second kind \\(S(n,k)\\) gives us number \\(k\\) partitions \\(n\\) elements. $$S(n,k) = \\frac{1}{k!}\\sum_{j=0}^{k} (-1)^j \\binom{k}{j}(k-j)^n$$ example, 4 coalitions (n = 4) 6 ways split k = 3 partitions. sum partitions size also known Bell number (\\(B_n = \\sum_{k=0}^n S(n,k)\\), see also numbers::bell()). Regarding total preorders \\(\\mathcal{T}(X)\\) set \\(X\\), Stirling number second kind can used determine number possible total preorders \\(|\\mathcal{T}(X)|\\). $$|\\mathcal{T}(X)| = \\sum_{k=0}^{|X|} k! * S(|X|, k)$$ literature, referred ordered Bell number Fubini number. context social rankings may consider total preorders set coalitions \\(2^N\\) given set elements players \\(N\\). , number coalitions doubles every new element. number preorders :","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationGenerator.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate power relations — powerRelationGenerator","text":"Due implementation, randomPowerRelation() create weak orders uniformly. .e., much less likely generate linear orders even though proportionally highest representation set weak orders.","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationGenerator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate power relations — powerRelationGenerator","text":"","code":"coalitions <- createPowerset(c('a','b'), includeEmptySet = FALSE) # list(c('a','b'), 'a', 'b')  gen <- powerRelationGenerator(coalitions)  while(!is.null(pr <- gen())) {   print(pr) } #> (ab ~ a ~ b) #> (ab ~ a) > b #> (ab ~ b) > a #> (a ~ b) > ab #> ab > (a ~ b) #> a > (ab ~ b) #> b > (ab ~ a) #> ab > a > b #> ab > b > a #> a > ab > b #> b > ab > a #> a > b > ab #> b > a > ab # (ab ~ a ~ b) # (ab ~ a) > b # (ab ~ b) > a # (a ~ b) > ab # ab > (a ~ b) # a > (ab ~ b) # b > (ab ~ a) # ab > a > b # ab > b > a # a > ab > b # b > ab > a # a > b > ab # b > a > ab  # from now on, gen() always returns NULL gen() #> NULL # NULL  # Use generateNextPartition() to skip certain partitions gen <- powerRelationGenerator(coalitions)  gen <- generateNextPartition(gen) gen <- generateNextPartition(gen) gen() #> ab > (a ~ b) # ab > (a ~ b)  gen <- generateNextPartition(gen) gen() #> ab > a > b # ab > a > b  coalitions <- createPowerset(c('a','b'), includeEmptySet = FALSE) # list(c('a','b'), 'a', 'b')  gen <- powerRelationGenerator(coalitions) gen() #> (ab ~ a ~ b) # (ab ~ a ~ b)  gen() #> (ab ~ a) > b # (ab ~ b) > a  # skipping partition of size two, where the first partition has # 2 coalitions and the second partition has 1 coalition gen <- generateNextPartition(gen) gen() #> ab > (a ~ b) # ab > (a ~ b)  # only remaining partition is one of size 3, wherein each # equivalence class is of size 1 gen <- generateNextPartition(gen) gen() #> ab > a > b # ab > a > b  # went through all partitions, it will only generate NULL now gen <- generateNextPartition(gen) stopifnot(is.null(gen()))   # create random power relation generateRandomPowerRelation(coalitions) #> b > ab > a  # make sure it's monotonic, i.e., {1} > {1,2} cannot exist # because {1} is a subset of {1,2} generateRandomPowerRelation(coalitions, monotonic = TRUE) #> ab > b > a"},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create relation matrix — powerRelationMatrix","title":"Create relation matrix — powerRelationMatrix","text":"given PowerRelation object create relations::relation() object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create relation matrix — powerRelationMatrix","text":"","code":"powerRelationMatrix(   powerRelation,   domainNames = c(\"pretty\", \"numericPrec\", \"numeric\") )  # S3 method for PowerRelation as.relation(x, ...)"},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create relation matrix — powerRelationMatrix","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() domainNames row column names formatted? pretty: Coalitions c(1,2) formatted 12. ensure correctly sorted alphabetically, every name preceded certain amount invisible Unicode character \\u200b numericPrec: Coalitions c(1,2) formatted 1{12}, number front curly brace marking sorted spot. less pretty, use Unicode characters. numeric: Drop coalition names, count 1 upwards. number corresponds index TODO powerRelation$rankingCoalitions function(x): custom function passed number 1 length(powerRelation$rankingCoalitions). Must return character object. x PowerRelation object ... parameters (ignored)","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create relation matrix — powerRelationMatrix","text":"relations::relation() object corresponding power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create relation matrix — powerRelationMatrix","text":"Turn PowerRelation object relations::relation() object. incidence matrix can viewed relations::relation_incidence(). columns rows PowerRelation object ordered TODO powerRelation$rankingCoalitions. relations package automatically sorts columns rows domain names, reason parameter domainNames included. way ensure columns rows sorted order power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"cycles","dir":"Reference","previous_headings":"","what":"Cycles","title":"Create relation matrix — powerRelationMatrix","text":"PowerRelation object defined transitive. power relation includes cycle, meaning coalition appears twice ranking, coalitions within cycle considered indifferent one another. example, given power relation \\(1 \\succ 2 \\succ 3 \\succ 1 \\succ 12\\), relation somewhat equivalent \\(1 \\sim 2 \\sim 3 \\succ 12\\). way check cycles incidence matrix . Call transitiveClosure() remove cycles PowerRelation object.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create relation matrix — powerRelationMatrix","text":"","code":"pr <- as.PowerRelation(\"12 > 1 > 2\") relation <- powerRelationMatrix(pr)  # do relation stuff # Incidence matrix # 111 # 011 # 001 relations::relation_incidence(relation) #> Incidences: #>    12 ​1 ​​2 #> 12  1 1 1 #> ​1   0 1 1 #> ​​2   0 0 1  # all TRUE stopifnot(all(   relations::relation_is_acyclic(relation),   relations::relation_is_antisymmetric(relation),   relations::relation_is_linear_order(relation),   relations::relation_is_complete(relation),   relations::relation_is_reflexive(relation),   relations::relation_is_transitive(relation) ))   # a power relation where coalitions {1} and {2} are indifferent pr <- as.PowerRelation(\"12 > (1 ~ 2)\") relation <- powerRelationMatrix(pr)  # Incidence matrix # 111 # 011 # 011 relations::relation_incidence(relation) #> Incidences: #>    12 ​1 ​​2 #> 12  1 1 1 #> ​1   0 1 1 #> ​​2   0 1 1  # FALSE stopifnot(!any(   relations::relation_is_acyclic(relation),   relations::relation_is_antisymmetric(relation),   relations::relation_is_linear_order(relation) )) # TRUE stopifnot(all(   relations::relation_is_complete(relation),   relations::relation_is_reflexive(relation),   relations::relation_is_transitive(relation) ))   # a pr with cycles pr <- suppressWarnings(as.PowerRelation(\"12 > 1 > 2 > 1\")) relation <- powerRelationMatrix(pr)  # Incidence matrix # 1111 # 0111 # 0111 # 0111 relations::relation_incidence(relation) #> Incidences: #>    12 ​1 ​​2 ​​​1 #> 12  1 1 1 1 #> ​1   0 1 1 1 #> ​​2   0 1 1 1 #> ​​​1   0 1 1 1  # custom naming convention relation <- powerRelationMatrix(   pr,   function(x) paste0(letters[x], \":\", paste(pr$rankingCoalitions[[x]], collapse = \"|\")) )  relations::relation_incidence(relation) #> Incidences: #>    a: b: c: d: #> a:  1  1  1  1 #> b:  0  1  1  1 #> c:  0  1  1  1 #> d:  0  1  1  1 # Incidences: #       a:1|2 b:1 c:2 d:1 # a:1|2     1   1   1   1 # b:1       0   1   1   1 # c:2       0   1   1   1 # d:1       0   1   1   1"},{"path":"https://jassler.github.io/socialranking/reference/socialranking-package.html","id":null,"dir":"Reference","previous_headings":"","what":"socialranking: A package for constructing ordinal power relations and evaluating social ranking solutions — socialranking-package","title":"socialranking: A package for constructing ordinal power relations and evaluating social ranking solutions — socialranking-package","text":"package socialranking offers functions represent ordinal information coalitions calculate power relation elements.","code":""},{"path":"https://jassler.github.io/socialranking/reference/socialranking-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"socialranking: A package for constructing ordinal power relations and evaluating social ranking solutions — socialranking-package","text":"Use browseVignettes(\"socialranking\") information.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/socialranking-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"socialranking: A package for constructing ordinal power relations and evaluating social ranking solutions — socialranking-package","text":"Maintainer: Felix Fritz felix.fritz@dauphine.eu Authors: Jochen Staudacher jochen.staudacher@hs-kempten.de [copyright holder, thesis advisor] Moretti Stefano stefano.moretti@lamsade.dauphine.fr [copyright holder, thesis advisor]","code":""},{"path":"https://jassler.github.io/socialranking/reference/socialranking.html","id":null,"dir":"Reference","previous_headings":"","what":"SocialRanking object — SocialRanking","title":"SocialRanking object — SocialRanking","text":"Create SocialRanking object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/socialranking.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SocialRanking object — SocialRanking","text":"","code":"SocialRanking(l)"},{"path":"https://jassler.github.io/socialranking/reference/socialranking.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SocialRanking object — SocialRanking","text":"l list vectors","code":""},{"path":"https://jassler.github.io/socialranking/reference/socialranking.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SocialRanking object — SocialRanking","text":"list type SocialRanking. element list contains vector elements powerRelation$elements indifferent one another.","code":""},{"path":"https://jassler.github.io/socialranking/reference/socialranking.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SocialRanking object — SocialRanking","text":"Similar PowerRelation(), SocialRanking expects expects list represent power relation. Unlike PowerRelation() however, list nested contain vectors, vector containing elements deemed equally preferable. Use doRanking() rank elements based arbitrary score objects. social ranking solution, ranking solution, solution, maps power relation coalitions power relation elements. .e., power relation \\(\\succsim: \\{1,2\\} \\succ \\{2\\} \\succ \\{1\\}\\), may expect result ranking solution \\(R^\\succsim\\) rank element 2 1. Therefore \\(2 R^\\succsim 1\\) present, \\(1 R^\\succsim 2\\). Formally, ranking solution \\(R: \\mathcal{T}(\\mathcal{P}) \\rightarrow \\mathcal{T}(N)\\) function , given power relation \\(\\succsim \\\\mathcal{T}(\\mathcal{P})\\), always produces power relation \\(R(\\succsim)\\) (\\(R^\\succsim\\)) set elements. two elements \\(, j \\N\\), \\(R^\\succsim j\\) means applying solution \\(R\\) ranking \\(\\succsim\\) makes \\(\\) least preferable \\(j\\). Often times \\(iI^\\succsim j\\) \\(iP^\\succsim j\\) used indicate symmetric asymmetric part, respectively. , \\(iI^\\succsim j\\) implies \\(iR^\\succsim j\\) \\(jR^\\succsim \\), whereas \\(iP^\\succsim j\\) implies \\(iR^\\succsim j\\) \\(jR^\\succsim \\).","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/socialranking.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SocialRanking object — SocialRanking","text":"","code":"SocialRanking(list(c(\"a\", \"b\"), \"f\", c(\"c\", \"d\"))) #> a ~ b > f > c ~ d # a ~ b > f > c ~ d"},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":null,"dir":"Reference","previous_headings":"","what":"Test relation between two elements — testRelation","title":"Test relation between two elements — testRelation","text":"given PowerRelation object pr, check e1 relates e2 based given social ranking solution.","code":""},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test relation between two elements — testRelation","text":"","code":"testRelation(powerRelation, e1)  powerRelation %:% e1  pr_e1 %>=dom% e2  pr_e1 %>dom% e2  pr_e1 %>=cumuldom% e2  pr_e1 %>cumuldom% e2  pr_e1 %>=cp% e2  pr_e1 %>cp% e2  pr_e1 %>=banz% e2  pr_e1 %>banz% e2  pr_e1 %>=cop% e2  pr_e1 %>cop% e2  pr_e1 %>=ks% e2  pr_e1 %>ks% e2  pr_e1 %>=lex% e2  pr_e1 %>lex% e2  pr_e1 %>=duallex% e2  pr_e1 %>duallex% e2  pr_e1 %>=L1% e2  pr_e1 %>L1% e2  pr_e1 %>=L2% e2  pr_e1 %>L2% e2  pr_e1 %>=LP% e2  pr_e1 %>LP% e2  pr_e1 %>=LPS% e2  pr_e1 %>LPS% e2"},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test relation between two elements — testRelation","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation() e1, e2 Elements powerRelation$elements pr_e1 PowerRelation e1 element, packed list using pr %:% e1","code":""},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test relation between two elements — testRelation","text":"testRelation() %:% returns list(powerRelation, e1). Followed %>=comparison% %>comparison% returns TRUE FALSE, depending relation e1 e2.","code":""},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test relation between two elements — testRelation","text":"function testRelation somewhat used make offered comparison operators package better discoverable. testRelation(pr, e1) equivalent pr %:% e1 list(pr, e1). used together one comparison operators listed usage section.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test relation between two elements — testRelation","text":"","code":"pr <- as.PowerRelation(\"123 > 12 ~ 13 ~ 23 > 3 > 1 ~ 2 > {}\")  # Dominance stopifnot(pr %:% 1 %>=dom% 2)  # Strict dominance stopifnot((pr %:% 1 %>dom% 2) == FALSE)  # Cumulative dominance stopifnot(pr %:% 1 %>=cumuldom% 2)  # Strict cumulative dominance stopifnot((pr %:% 1 %>cumuldom% 2) == FALSE)  # CP-Majority relation stopifnot(pr %:% 1 %>=cp% 2)  # Strict CP-Majority relation stopifnot((pr %:% 1 %>cp% 2) == FALSE)  # Ordinal banzhaf relation stopifnot(pr %:% 1 %>=banz% 2)  # Strict ordinal banzhaf relation # (meaning 1 had a strictly higher positive contribution than 2) stopifnot((pr %:% 1 %>banz% 2) == FALSE)  # Copeland-like method stopifnot(pr %:% 1 %>=cop% 2) stopifnot(pr %:% 2 %>=cop% 1)  # Strict Copeland-like method # (meaning pairwise winning minus pairwise losing comparison of # 1 is strictly higher than of 2) stopifnot((pr %:% 1 %>cop% 2) == FALSE) stopifnot((pr %:% 2 %>cop% 1) == FALSE) stopifnot(pr %:% 3 %>cop% 1)  # Kramer-Simpson-like method stopifnot(pr %:% 1 %>=ks% 2) stopifnot(pr %:% 2 %>=ks% 1)  # Strict Kramer-Simpson-like method # (meaning ks-score of 1 is actually higher than 2) stopifnot((pr %:% 2 %>ks% 1) == FALSE) stopifnot((pr %:% 1 %>ks% 2) == FALSE) stopifnot(pr %:% 3 %>ks% 1)  # Lexicographical and dual lexicographical excellence stopifnot(pr %:% 3 %>=lex% 1) stopifnot(pr %:% 3 %>=duallex% 1)  # Strict lexicographical and dual lexicographical excellence # (meaning their lexicographical scores don't match) stopifnot(pr %:% 3 %>lex% 1) stopifnot(pr %:% 3 %>duallex% 1)  # L^(1) and L^(2) stopifnot(pr %:% 1 %>=L1% 2) stopifnot(pr %:% 1 %>=L2% 2)  # Strict L^(1) and L^(2) stopifnot((pr %:% 1 %>L1% 2) == FALSE) stopifnot(pr %:% 3 %>L1% 1)  stopifnot((pr %:% 1 %>L2% 2) == FALSE) stopifnot(pr %:% 3 %>L2% 1)  # L^p and L^p* stopifnot(pr %:% 1 %>=LP% 2) stopifnot(pr %:% 1 %>=LPS% 2)  # Strict L^(1) and L^(2) stopifnot((pr %:% 1 %>LP% 2) == FALSE) stopifnot(pr %:% 3 %>LP% 1)  stopifnot((pr %:% 1 %>LPS% 2) == FALSE) stopifnot(pr %:% 3 %>LPS% 1)"},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":null,"dir":"Reference","previous_headings":"","what":"Transitive Closure — transitiveClosure","title":"Transitive Closure — transitiveClosure","text":"Apply transitive closure power relation cycles.","code":""},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transitive Closure — transitiveClosure","text":"","code":"transitiveClosure(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transitive Closure — transitiveClosure","text":"powerRelation PowerRelation object created PowerRelation() .PowerRelation()","code":""},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transitive Closure — transitiveClosure","text":"PowerRelation object cycles.","code":""},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transitive Closure — transitiveClosure","text":"power relation binary relationship coalitions transitive. coalitions \\(, b, c \\2^N\\), means \\(\\succ b\\) \\(b \\succ c\\), \\(\\succ c\\). power relation cycles transitive. transitive closure power relation removes cycles turns transitive relation, placing coalitions within cycle equivalence class. \\(\\succ b \\succ \\), symmetric definition PowerRelation() therefore assume \\(\\sim b\\). Similarly, \\(\\succ b_1 \\succ b_2 \\succ \\dots \\succ b_n \\succ \\), transitive closure turns \\(\\sim b_1 \\sim b_2 \\sim \\dots \\sim b_n\\). transitiveClosure() transforms PowerRelation object cycles PowerRelation object without cycles. described , coalitions within cycle put equivalence class duplicate coalitions removed.","code":""},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transitive Closure — transitiveClosure","text":"","code":"pr <- as.PowerRelation(\"1 > 2\")  # nothing changes transitiveClosure(pr) #> 1 > 2   pr <- suppressWarnings(as.PowerRelation(\"1 > 2 > 1\"))  # 1 ~ 2 transitiveClosure(pr) #> (1 ~ 2)   pr <- suppressWarnings(   as.PowerRelation(\"1 > 3 > 1 > 2 > 23 > 2\") )  # 1 > 3 > 1 > 2 > 23 > 2 => # 1 ~ 3 > 2 ~ 23 transitiveClosure(pr) #> (1 ~ 3) > (2 ~ 23)"},{"path":"https://jassler.github.io/socialranking/news/index.html","id":"socialranking-120","dir":"Changelog","previous_headings":"","what":"socialranking 1.2.0","title":"socialranking 1.2.0","text":"Added generateRandomPowerRelation() Added S3 class DualLexcelScores","code":""},{"path":"https://jassler.github.io/socialranking/news/index.html","id":"socialranking-110-2023-11-29","dir":"Changelog","previous_headings":"","what":"socialranking 1.1.0 (2023-11-29)","title":"socialranking 1.1.0 (2023-11-29)","text":"CRAN release: 2023-11-29 Added L2Scores() L2Ranking(), along aliases lexcel2...() Added LPScores() LPRanking(), along aliases lexcelP...() Added LPSScores() LPSRanking(), along aliases lexcelPS...() Fixed kramerSimpsonScores() implementation line official definition Changed succeq succsim notation documentation reflect modern literature","code":""},{"path":"https://jassler.github.io/socialranking/news/index.html","id":"socialranking-101-2023-08-23","dir":"Changelog","previous_headings":"","what":"socialranking 1.0.1 (2023-08-23)","title":"socialranking 1.0.1 (2023-08-23)","text":"CRAN release: 2023-08-23 Added -package alias package description (fixing problem listed ).","code":""},{"path":"https://jassler.github.io/socialranking/news/index.html","id":"socialranking-100-2023-03-13","dir":"Changelog","previous_headings":"","what":"socialranking 1.0.0 (2023-03-13)","title":"socialranking 1.0.0 (2023-03-13)","text":"CRAN release: 2023-03-13 major update brings lot breaking changes hopefully justified. $elements , previous version, vector sorted, unique elements $equivalenceClasses renamed $eqs $rankingCoalitions $rankingComparators removed, served particular purpose Added $coalitionLookup() make easy (fast) find equivalence class indexes coalition appears Added $elementLookup() make easy (fast) find coalitions element appears Changed coalitions longer sets::set objects, just normal vectors. allows one element appear multiple times coalition, consistent ability coalition appear multiple times PowerRealtion object. Added PowerRelation() .PowerRelation() Added SocialRanking() Added coalitionLookup() elementLookup() Added L1Scores() L1Ranking(), along aliases lexcel1...() Added makePowerRelationMonotonic() appendMissingCoalitions() Added powerRelationGenerator() generateNextPartition() Changed createPowerset(), replaced parameters logicals copyToClipboard writeLines character result Changed ordinalBanzhafScores() returns third value indicating many comparisons made Deprecated newPowerRelation() newPowerRelationFromString() Deprecated SocialRankingSolution class Removed mathjaxr sets dependencies","code":""},{"path":"https://jassler.github.io/socialranking/news/index.html","id":"socialranking-012-2022-10-11","dir":"Changelog","previous_headings":"","what":"socialranking 0.1.2 (2022-10-11)","title":"socialranking 0.1.2 (2022-10-11)","text":"CRAN release: 2022-10-27 Changed maintainer’s email address","code":""},{"path":"https://jassler.github.io/socialranking/news/index.html","id":"socialranking-011-2022-04-25","dir":"Changelog","previous_headings":"","what":"socialranking 0.1.1 (2022-04-25)","title":"socialranking 0.1.1 (2022-04-25)","text":"CRAN release: 2022-04-25 Added parameter equivalenceClasses newPowerRelation()","code":""}]
