[{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"literature cooperative games, notion power index [1–3] widely studied analyze ``influence” individuals taking account ability force decision within groups coalitions. practical situations, however, information concerning strength coalitions hardly quantifiable. , attempt numerically represent influence groups individuals clashes complex multi-attribute nature problem seems realistic represent collective decision-making mechanisms using ordinal coalitional framework based two main ingredients: binary relation groups coalitions ranking individuals. main objective package socialranking provide answers general problem compare elements finite set \\(N\\) given ranking elements power-set (set possible subsets \\(N\\)). , package socialranking implements portfolio solutions recent literature social rankings [4–10].","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"quick-start","dir":"Articles","previous_headings":"Introduction","what":"Quick Start","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"power relation (.e, ranking subsets finite set \\(N\\); see Section PowerRelation objects formal definition) can constructed using newPowerRelation() newPowerRelationFromString() functions. Functions used analyze given PowerRelation object can grouped three main categories: Comparison functions, comparing two elements; Score functions, calculating scores element; Ranking functions, creating SocialRankingSolution objects. Comparison score functions often used evaluate social ranking solution (see section PowerRelation objects formal definition). Listed prominent functions solutions introduced aforementioned papers. functions may called follows. Finally incidence matrix given coalitions can constructed using powerRelationMatrix(pr) .relation(pr) relations package [11]. incidence matrix may displayed using relations::relation_incidence().","code":"library(socialranking) newPowerRelation(c(1,2), \">\", 1, \"~\", c(), \">\", 2) ## Elements: 1 2 ## 12 > (1 ~ {}) > 2 newPowerRelationFromString(\"ab > a ~ {} > b\") ## Elements: a b ## ab > (a ~ {}) > b newPowerRelationFromString(\"12 > 1 ~ {} > 2\", asWhat = as.numeric) ## Elements: 1 2 ## 12 > (1 ~ {}) > 2 pr <- newPowerRelationFromString(\"ab > ac ~ bc > a ~ c > {} > b\")  # a dominates b -> TRUE dominates(pr, \"a\", \"b\") ## [1] TRUE # b does not dominate a -> FALSE dominates(pr, \"b\", \"a\") ## [1] FALSE # calculate cumulative scores scores <- cumulativeScores(pr) # show score of element a scores$a ## [1] 1 2 3 3 3 # performing a bunch of rankings lexcelRanking(pr) ## a > b > c dualLexcelRanking(pr) ## a > c > b copelandRanking(pr) ## a > b ~ c kramerSimpsonRanking(pr) ## a > b ~ c ordinalBanzhafRanking(pr) ## a ~ c > b rel <- relations::as.relation(pr) rel ## A binary relation of size 7 x 7. relations::relation_incidence(rel) ## Incidences: ##    ab ​ac ​​bc ​​​a ​​​​c ​​​​​{} ​​​​​​b ## ab  1  1  1 1 1  1 1 ## ​ac  0  1  1 1 1  1 1 ## ​​bc  0  1  1 1 1  1 1 ## ​​​a   0  0  0 1 1  1 1 ## ​​​​c   0  0  0 1 1  1 1 ## ​​​​​{}  0  0  0 0 0  1 1 ## ​​​​​​b   0  0  0 0 0  0 1"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"sec:prelim","dir":"Articles","previous_headings":"","what":"PowerRelation Objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"first introduce basic definitions binary relations. Let \\(X\\) set. set \\(R \\subseteq X \\times X\\) said binary relation \\(X\\). two elements \\(x, y \\X\\), \\(xRy\\) refers relation, formally means \\((x,y) \\R\\). binary relation \\((x,y) \\R\\) said : reflexive, \\(x \\X, xRx\\) transitive, \\(x, y, z \\X, xRy\\) \\(yRz \\Rightarrow xRz\\) total, \\(x,y \\X, x \\neq y \\Rightarrow xRy\\) \\(yRx\\) symmetric, \\(x,y \\X,xRy \\Leftrightarrow yRx\\) asymmetric, \\(x,y \\X,(x,y) \\R \\Rightarrow (y,x) \\notin R\\) antisymmetric, \\(x,y \\X,xRy \\cap yRx \\Rightarrow x=y\\) preorder defined reflexive transitive relation. total, called total preorder. Additionally antisymmetric, called linear order. Let \\(N = \\{1, 2, \\dots, n\\}\\) finite set elements, sometimes also called players. \\(p \\\\{1, \\ldots, 2^n\\}\\), let \\(\\mathcal{P} = \\{S_1, S_2, \\dots, S_{p}\\}\\) set coalitions \\(S_i \\subseteq N\\) \\(\\\\{1, \\ldots, p\\}\\). Thus \\(\\mathcal{P} \\subseteq 2^N\\), \\(2^N\\) denotes power set \\(N\\) (.e., set subsets coalitions \\(N\\)). \\(\\mathcal{T}(N)\\) denotes set total preorders \\(N\\), \\(\\mathcal{T}(\\mathcal{P})\\) set total preorders \\(\\mathcal{P}\\). single total preorder \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) said power relation. given power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) \\(\\mathcal{P} \\subseteq 2^N\\), symmetric part denoted \\(\\sim\\) (.e., \\(S \\sim T\\) \\(S \\succeq T\\) \\(T \\succeq S\\)), whereas asymmetric part denoted \\(\\succ\\) (.e., \\(S \\succ T\\) \\(S \\succeq T\\) \\(T \\succeq S\\)). terms, \\(S \\sim T\\) say \\(S\\) indifferent \\(T\\), whereas \\(S \\succ T\\) say \\(S\\) strictly better \\(T\\). Lastly given power relation form \\(S_1 \\succeq S_2 \\succeq \\ldots \\succeq S_m\\), coalitions indifferent one another can grouped equivalence classes \\(\\sum_i\\) get quotient order \\(\\sum_1 \\succ \\sum_2 \\succ \\ldots \\succ \\sum_m\\). Let \\(N=\\{1,2\\}\\) two players corresponding power set \\(2^N = \\{\\{1,2\\}, \\{1\\}, \\{2\\}, \\emptyset\\}\\). following power relation given: \\(\\succeq = \\{(\\{1,2\\},\\{2\\}), (\\{2\\}, \\emptyset), (\\emptyset, \\{2\\}), (\\emptyset, \\{1\\})\\}\\). power relation can rewritten consecutive order : \\(\\{1,2\\} \\succ \\{2\\} \\sim \\emptyset \\succ \\{1\\}\\). quotient order formed three equivalence classes \\(\\sum_1 = \\{\\{1,2\\}\\}, \\sum_2 = \\{\\{2\\}, \\emptyset\\},\\) \\(\\sum_3 = \\{\\{1\\}\\}\\); quotient order \\(\\succeq\\) \\(\\{\\{1,2\\}\\} \\succ \\{\\{2\\}, \\emptyset\\} \\succ \\{\\{1\\}\\}\\). social ranking solution (also called social ranking , simply, solution) \\(N\\), function \\(R: \\mathcal{T}(\\mathcal{P}) \\longrightarrow \\mathcal{T}(N)\\) associating power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) total preorder \\(R(\\succeq)\\) (\\(R^\\succeq\\)) elements \\(N\\). definition, notion \\(R^\\succeq j\\) means applying social ranking solution power relation \\(\\succeq\\) gives result \\(\\) ranked higher equal \\(j\\).","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"creating-powerrelation-objects","dir":"Articles","previous_headings":"PowerRelation Objects","what":"Creating PowerRelation Objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"power relation socialranking package defined reflexive, transitive total. designing package deemed logical coalitions specified consecutive order, seen Example 1. coalition order split either \">\" (left side strictly better) \"~\" (two coalitions indifferent one another). following code chunk shows power relation Example 1 correlating PowerRelation object can constructed. Notice coalitions \\(\\{1,2\\}\\) written 12 improve readability. Similarly function newPowerRelationFromString saves typing user’s end interpreting character coalition separate player. Note spaces function ignored. compact notation done PowerRelation objects every player one digit one character long. case, curly braces commas added needed. may spotted \"SingleCharElements\" class missing class(prLong) class(pr). \"SingleCharElements\" influences way coalitions printed. removed class(pr), output include curly braces commas displayed prLong. Internally PowerRelation list four attributes (see table ). Notice every coalition vector turned set object sets package[12]. Since coalition vector turned set, coalitions c(1,2), c(2,1) c(1,1,2,2) equivalent. equivalenceClassIndex() determines index \\(\\) coalition \\(S \\\\sum_i\\).","code":"library(socialranking) pr <- newPowerRelation(c(1,2), \">\", 2, \"~\", c(), \">\", 1) pr ## Elements: 1 2 ## 12 > (2 ~ {}) > 1 class(pr) ## [1] \"PowerRelation\"      \"SingleCharElements\" newPowerRelationFromString(\"12 > 2~{} > 1\", asWhat = as.numeric) ## Elements: 1 2 ## 12 > (2 ~ {}) > 1 prLong <- newPowerRelation(   c(\"Alice\", \"Bob\"), \">\", \"Bob\", \"~\", c(), \">\", \"Alice\" ) prLong ## Elements: Alice Bob ## {Alice, Bob} > ({Bob} ~ {}) > {Alice} class(prLong) ## [1] \"PowerRelation\" class(pr) <- class(pr)[-which(class(pr) == \"SingleCharElements\")] pr ## Elements: 1 2 ## {1, 2} > ({2} ~ {}) > {1} prAtts <- newPowerRelation(c(2,2,1,1,2), \">\", c(1,1,1), \"~\", c()) prAtts ## Elements: 1 2 ## 12 > (1 ~ {}) prAtts$elements ## [1] 1 2 prAtts$rankingCoalitions ## [[1]] ## {1, 2} ##  ## [[2]] ## {1} ##  ## [[3]] ## {} prAtts$rankingComparators ## [1] \">\" \"~\" prAtts$equivalenceClasses ## [[1]] ## [[1]][[1]] ## {1, 2} ##  ##  ## [[2]] ## [[2]][[1]] ## {1} ##  ## [[2]][[2]] ## {} equivalenceClassIndex(prAtts, c(2,1)) ## [1] 1 equivalenceClassIndex(prAtts, 1) ## [1] 2 equivalenceClassIndex(prAtts, c()) ## [1] 2 # are the given coalitions in the same equivalence class? coalitionsAreIndifferent(prAtts, 1, c()) ## [1] TRUE coalitionsAreIndifferent(prAtts, 1, c(1,2)) ## [1] FALSE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"manipulating-powerrelation-objects","dir":"Articles","previous_headings":"PowerRelation Objects","what":"Manipulating PowerRelation Objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"strongly discouraged directly manipulate PowerRelation objects, since modifying one list vector entry require updates attributes. Instead newPowerRelation offers two parameters rankingCoalitions rankingComparators, corresponding named attributes PowerRelation object. Note rankingComparators optional. default assumes rankingCoalitions linear order. length rankingComparators vector smaller larger length rankingCoalitions, function silently fills gaps.","code":"pr ## Elements: 1 2 ## {1, 2} > ({2} ~ {}) > {1} # reverse power ranking newPowerRelation(   rankingCoalitions = rev(pr$rankingCoalitions),   rankingComparators = pr$rankingComparators ) ## Elements: 1 2 ## 1 > ({} ~ 2) > 12 newPowerRelation(rankingCoalitions = rev(pr$rankingCoalitions)) ## Elements: 1 2 ## 1 > {} > 2 > 12 # if too short -> comparator values are repeated newPowerRelation(   rankingCoalitions = as.list(1:9),   rankingComparators = \"~\" ) ## Elements: 1 2 3 4 5 6 7 8 9 ## (1 ~ 2 ~ 3 ~ 4 ~ 5 ~ 6 ~ 7 ~ 8 ~ 9) newPowerRelation(     rankingCoalitions = as.list(letters[1:9]),     rankingComparators = c(\">\", \"~\", \"~\") ) ## Elements: a b c d e f g h i ## a > (b ~ c ~ d) > (e ~ f ~ g) > (h ~ i) # if too long -> ignore excessive comparators newPowerRelation(   rankingCoalitions = pr$rankingCoalitions,   rankingComparators = c(\"~\", \">\", \"~\", \">\", \">\", \"~\") ) ## Elements: 1 2 ## (12 ~ 2) > ({} ~ 1)"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"creating-power-sets","dir":"Articles","previous_headings":"PowerRelation Objects","what":"Creating Power sets","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"number elements \\(n\\) increases, number possible coalitions increases \\(|2^N| = 2^n\\). createPowerset convenient function creates power set \\(2^N\\) can used call newPowerRelation, also formats function call way makes easy rearrange ordering coalitions. RStudio offers shortcuts Alt+Alt+(Option+Option+MacOS) move one multiple lines code (see fig. ). Using Alt+Alt+move one lines code writeLines copyToClipboard set FALSE, function instead returns list containing coalition vectors. list can passed directly rankingCoalitions parameter newPowerRelation.","code":"createPowerset(   c(\"a\", \"b\", \"c\"),   writeLines = TRUE,   copyToClipboard = FALSE ) ## newPowerRelation( ##   c(\"a\", \"b\", \"c\"), ##   \">\", c(\"a\", \"b\"), ##   \">\", c(\"a\", \"c\"), ##   \">\", c(\"b\", \"c\"), ##   \">\", c(\"a\"), ##   \">\", c(\"b\"), ##   \">\", c(\"c\"), ##   \">\", c(), ## ) ps <- createPowerset(1:2, includeEmptySet = FALSE) ps ## [[1]] ## [1] 1 2 ##  ## [[2]] ## [1] 1 ##  ## [[3]] ## [1] 2 newPowerRelation(rankingCoalitions = ps) ## Elements: 1 2 ## 12 > 1 > 2 newPowerRelation(rankingCoalitions = createPowerset(letters[1:4])) ## Elements: a b c d ## abcd > abc > abd > acd > bcd > ab > ac > ad > bc > bd > cd > a > b > c > d > {}"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"socialrankingsolution-objects","dir":"Articles","previous_headings":"","what":"SocialRankingSolution Objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"main goal socialranking package rank elements based given power ranking. formally try map \\(R: \\mathcal{T}(\\mathcal{P}) \\rightarrow \\mathcal{T}(N)\\), associating power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) total preorder \\(R(\\succeq)\\) (\\(R^\\succeq\\)) elements \\(N\\). context \\(R^\\succeq j\\) tells us , given power relation \\(\\succeq\\) applying social ranking solution \\(R(\\succeq)\\), \\(\\) ranked higher equal \\(j\\). , > ~ also denote asymmetric symmetric part social ranking, respectively, \\(\\) > \\(j\\) indicating \\(\\) strictly better \\(j\\), whereas \\(\\) ~ \\(j\\), \\(\\) indifferent \\(j\\). section 3.1 show general SocialRankingSolution object can constructed using doRanking function. following sections, introduce notion dominance[4], cumulative dominance[13] CP-Majority comparison[6] lets us compare two elements diving social ranking solutions Ordinal Banzhaf Index[5], Copeland-like Kramer-Simpson-like methods[10], lastly Lexicographical Excellence Solution[9] (Lexcel) Dual Lexicographical Excellence solution[14] (Dual Lexcel). Let \\(\\{,b\\} \\succ (\\{,c\\} \\sim \\{b,c\\}) \\succ (\\{\\} \\sim \\{c\\}) > \\emptyset \\succ \\{b\\}\\) power ranking. Using following social ranking solutions, get: > b > c lexcelRanking > c > b dualLexcelRanking > b ~ c copelandRanking kramerSimpsonRanking ~ c > b ordinalBanzhafRanking","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"creating-socialrankingsolution-objects","dir":"Articles","previous_headings":"SocialRankingSolution Objects","what":"Creating SocialRankingSolution objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"SocialRankingSolution object represents total preorder \\(\\mathcal{T}(N)\\) elements \\(N\\). Internally saved list vectors, containing players indifferent one another. somewhat similar equivalenceClasses attribute PowerRelation objects. function doRanking offers generic way creating SocialRankingSolution objects. Given PowerRelation object sortable vector list scores determines power relation players. Note length(scores) == length(powerRelation$elements) must TRUE. Additionally index scores corresponds index sorted vector powerRelation$elements. default elements assumed indifferent one another scores equal. Sometimes however factors come play make non-obvious compare two scores. cases function comparing two scores can passed return TRUE two scores considered equal.","code":"pr <- newPowerRelationFromString(\"abc > ab ~ ac > bc\")  # pr$elements == c(\"a\", \"b\", \"c\") # we define some arbitrary score vector where \"a\" scores highest # \"b\" and \"c\" both score 1, thus they are indifferent scores <- c(100, 1, 1) doRanking(pr, scores) ## a > b ~ c # we can also tell doRanking to punish higher scores doRanking(pr, scores, decreasing = FALSE) ## b ~ c > a scores <- c(0, 20, 21) # b and c are considered to be indifferent, # because their score difference is less than 2 doRanking(pr, scores, isIndifferent = function(a,b) abs(a-b) < 2) ## b ~ c > a"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"comparison-functions","dir":"Articles","previous_headings":"SocialRankingSolution Objects","what":"Comparison Functions","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Comparison functions compare two elements given power relation. offer social ranking solution. However cases CP-Majority comparison, comparison functions may used construct social ranking solution particular cases.","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ch:dominance","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Comparison Functions","what":"Dominance","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"(Dominance [4]) Given power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) two elements \\(,j \\N\\), \\(\\) dominates \\(j\\) \\(\\succeq\\) \\(S \\cup \\{\\} \\succeq S \\cup \\{j\\}\\) \\(S \\2^{N\\setminus \\{,j\\}}\\). \\(\\) also strictly dominates \\(j\\) exists \\(S \\2^{N\\setminus \\{,j\\}}\\) \\(S \\cup \\{\\} \\succ S \\cup \\{j\\}\\). implication every coalition \\(\\) \\(j\\) can join, \\(\\) least positive impact \\(j\\). function dominates(pr, e1, e2) returns logical value TRUE e1 dominates e2, else FALSE. Note e1 dominating e2 indicate e2 dominates e1, imply e1 indifferent e2. \\(S \\2^{N \\setminus \\{,j\\}}\\), can compare \\(S \\cup \\{\\} \\succeq S \\cup \\{j\\}\\) \\(S \\cup \\{\\}\\) \\(S \\cup \\{j\\}\\) take part power relation. Additionally, \\(S = \\emptyset\\), also want compare \\(\\{\\} \\succeq \\{j\\}\\). situations however comparison singletons desired. reason parameter includeEmptySet can set FALSE \\(\\emptyset \\cup \\{\\} \\succeq \\emptyset \\cup \\{j\\}\\) considered CP-Majority comparison.","code":"pr <- newPowerRelationFromString(   \"3 > 1 > 2 > 12 > 13 > 23\",   asWhat = as.numeric )  # 1 clearly dominates 2 dominates(pr, 1, 2) ## [1] TRUE dominates(pr, 2, 1) ## [1] FALSE # 3 does not dominate 1, nor does 1 dominate 3, because # {}u3 > {}u1, but 2u1 > 2u3 dominates(pr, 1, 3) ## [1] FALSE dominates(pr, 3, 1) ## [1] FALSE # an element i dominates itself, but it does not strictly dominate itself # because there is no Sui > Sui dominates(pr, 1, 1) ## [1] TRUE dominates(pr, 1, 1, strictly = TRUE) ## [1] FALSE pr <- newPowerRelationFromString(\"ac > bc ~ b > a ~ abc > ab\")  # FALSE because ac > bc, whereas b > a dominates(pr, \"a\", \"b\") ## [1] FALSE # TRUE because ac > bc, ignoring b > a comparison dominates(pr, \"a\", \"b\", includeEmptySet = FALSE) ## [1] TRUE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ch:cumul","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Comparison Functions","what":"Cumulative Dominance","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"comparing two players \\(,j \\N\\), instead looking particular coalitions \\(S \\2^{N \\setminus \\{,j\\}}\\) can join, look many stronger coalitions can form point. property originally introduced [13] regular dominance axiom. given power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) corresponding quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), power player \\(\\) given vector \\(\\textrm{Score}_\\textrm{Cumul}() \\\\mathbb{N}^m\\) cumulatively sum amount times \\(\\) appears \\(\\sum_k\\) index \\(k\\). (Cumulative Dominance Score) Given power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), cumulative score vector \\(\\textrm{Score}_\\textrm{Cumul}() \\\\mathbb{N}^m\\) element \\(\\N\\) given : \\[\\begin{equation}     \\textrm{Score}_\\textrm{Cumul}() = \\Big( \\sum_{t=1}^k |\\{S \\\\textstyle \\sum_t : \\S\\}|\\Big)_{k \\\\{1, \\dots, m\\}} \\end{equation}\\] (Cumulative Dominance) Given two elements \\(,j \\N\\), \\(\\) cumulatively dominates \\(j\\) \\(\\succeq\\), \\(\\textrm{Score}_\\textrm{Cumul}()_k \\geq \\textrm{Score}_\\textrm{Cumul}(j)_k\\) \\(k \\\\{1, \\dots, m\\}\\). \\(\\) also strictly cumulatively dominates \\(j\\) exists \\(k\\) \\(\\textrm{Score}_\\textrm{Cumul}()_k > \\textrm{Score}_\\textrm{Cumul}(j)_k\\). given PowerRelation object pr two elements e1 e2, cumulativeScores(pr) returns vectors described definition 2 element, cumulativelyDominates(pr, e1, e2) returns TRUE FALSE based definition 3. Similar dominance property previous section, two elements dominating one indicate indifferent.","code":"pr <- newPowerRelationFromString(\"ab > (ac ~ bc) > (a ~ c) > {} > b\") cumulativeScores(pr) ## $a ## [1] 1 2 3 3 3 ##  ## $b ## [1] 1 2 2 2 3 ##  ## $c ## [1] 0 2 3 3 3 ##  ## attr(,\"class\") ## [1] \"CumulativeScores\" # for each index k, $a[k] >= $b[k] cumulativelyDominates(pr, \"a\", \"b\") ## [1] TRUE # $a[3] > $b[3], therefore a also strictly dominates b cumulativelyDominates(pr, \"a\", \"b\", strictly = TRUE) ## [1] TRUE # $b[1] > $c[1], but $c[3] > $b[3] # therefore neither b nor c dominate each other cumulativelyDominates(pr, \"b\", \"c\") ## [1] FALSE cumulativelyDominates(pr, \"c\", \"b\") ## [1] FALSE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"cp-majority-comparison","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Comparison Functions","what":"CP-Majority comparison","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Ceteris Paribus Majority (CP-Majority) relation somewhat relaxed version dominance property. Instead checking \\(S \\cup \\{\\} \\succeq S \\cup \\{j\\}\\) \\(S \\2^{N \\setminus \\{,j\\}}\\), CP-Majority relation \\(iR^\\succeq_\\textrm{CP}j\\) holds number times \\(S \\cup \\{\\} \\succeq S \\cup \\{j\\}\\) greater equal number times \\(S \\cup \\{j\\} \\succeq S \\cup \\{\\}\\). (CP-Majority [6]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). Ceteris Paribus majority relation binary relation \\(R^\\succeq_\\textrm{CP} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{CP}j \\Leftrightarrow d_{ij}(\\succeq) \\geq d_{ji}(\\succeq) \\end{equation}\\] \\(d_{ij}(\\succeq)\\) represents cardinality set \\(D_{ij}(\\succeq)\\), set coalitions \\(S \\2^{N \\setminus \\{,j\\}}\\) \\(S \\cup \\{\\} \\succeq S \\cup \\{j\\}\\). cpMajorityComparisonScore(pr, e1, e2) calculates two scores \\(d_{ij}(\\succeq)\\) \\(-d_{ji}(\\succeq)\\). Notice minus sign - way can use sum values determine relation e1 e2. slight variation logical parameter strictly calculates \\(d_{ij}(\\succ)\\) \\(-d_{ji}(\\succ)\\), number coalitions \\(S \\2^{N\\setminus \\{,j\\}}\\) \\(S\\cup\\{\\}\\succ S\\cup\\{j\\}\\). Coincidentally, cpMajorityComparisonScore strictly = TRUE can used determine e1 (strictly) dominates e2. cpMajorityComparisonScore used simple quick calculations. comprehensive function cpMajorityComparison(pr, e1, e2) calculations, process retains information comparisons might interesting user, .e., set \\(D_{ij}(\\succeq)\\) \\(D_{ji}(\\succeq)\\) well relation \\(iR^\\succeq_\\textrm{CP}j\\). See documentation full list available data. CP-Majority relation can generate cycles, reason offered social ranking solution. Instead introduce Copeland-like method Kramer-Simpson-like method make use CP-Majority functions determine power relation elements. readings CP-Majority, see [7] [10].","code":"pr <- newPowerRelationFromString(\"ab > (ac ~ bc) > (a ~ c) > {} > b\") cpMajorityComparisonScore(pr, \"a\", \"b\") ## [1]  2 -1 cpMajorityComparisonScore(pr, \"b\", \"a\") ## [1]  1 -2 if(sum(cpMajorityComparisonScore(pr, \"a\", \"b\")) >= 0) {   print(\"a >= b\") } else {   print(\"b > a\") } ## [1] \"a >= b\" # Now (ac ~ bc) is not counted cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = TRUE) ## [1] 1 0 # Notice that the sum is still the same sum(cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = FALSE)) ==   sum(cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = TRUE)) ## [1] TRUE # extract more information in cpMajorityComparison cpMajorityComparison(pr, \"a\", \"b\") ## a > b ## D_ab = {c, {}} ## D_ba = {c} ## Score of a = 2 ## Score of b = 1 # with strictly set to TRUE, coalition c does # neither appear in D_ab nor in D_ba cpMajorityComparison(pr, \"a\", \"b\", strictly = TRUE) ## a > b ## D_ab = {{}} ## D_ba = {} ## Score of a = 1 ## Score of b = 0"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ordinal-banzhaf","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Social Ranking Solutions","what":"Ordinal Banzhaf","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Ordinal Banzhaf Score vector defined principle marginal contributions. Intuitively speaking, player joining coalition causes move ranking, can interpreted positive contribution. contrary negative contribution means participating causes coalition go ranking. (Ordinal marginal contribution [5]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). given element \\(\\N\\), ordinal marginal contribution \\(m_i^S(\\succeq)\\) right coalition \\(S \\\\mathcal{P}\\) defined : \\[\\begin{equation}     m_i^S(\\succeq) = \\begin{cases}         \\hphantom{-}1 & \\textrm{} S \\cup \\{\\} \\succ S\\\\         -1 & \\textrm{} S \\succ S \\cup \\{\\}\\\\         \\hphantom{-}0 & \\textrm{otherwise}     \\end{cases} \\end{equation}\\] (Ordinal Banzhaf relation) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). Ordinal Banzhaf relation binary relation \\(R^\\succeq_\\textrm{Banz} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{Banz}j \\Leftrightarrow \\text{Score}_\\text{Banz}() \\geq \\text{Score}_\\text{Banz}(j), \\end{equation}\\] \\(\\text{Score}_\\text{Banz}() = \\sum_{S} m^S_i(\\succeq)\\) \\(S \\N\\setminus\\{\\}\\). Note \\(S \\cup \\{\\} \\notin \\mathcal{P}\\), \\(m_i^S(\\succeq) = 0\\). function ordinalBanzhafScores returns two numbers element: number coalitions \\(S\\) player’s contribution positive impact, number coalitions \\(S\\) player’s contribution negative impact. two numbers added elements ranked highest lowest.","code":"pr <- newPowerRelation(   c(1,2),   \">\", c(1),   \">\", c(2) )  # both players 1 and 2 have an Ordinal Banzhaf Score of 1 # therefore they are indifferent to one another ordinalBanzhafScores(pr) ## $`1` ## [1] 1 0 ##  ## $`2` ## [1] 1 0 ##  ## attr(,\"class\") ## [1] \"OrdinalBanzhafScores\" ordinalBanzhafRanking(pr) ## 1 ~ 2 pr <- newPowerRelationFromString(\"ab > a > {} > b\")  # player b has a negative impact on the empty set # -> player b's score is 1 - 1 = 0 # -> player a's score is 2 - 0 = 2 sapply(ordinalBanzhafScores(pr), function(score) sum(score)) ## a b  ## 2 0 ordinalBanzhafRanking(pr) ## a > b"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ch:copeland","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Social Ranking Solutions","what":"Copeland-like method","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Copeland-like method ranking elements based CP-Majority rule strongly inspired Copeland score social choice theory[15]. score element \\(\\N\\) determined amount pairwise CP-Majority winning comparisons \\(R^\\succeq_\\textrm{CP} j\\), minus number losing comparisons \\(j R^\\succeq_\\textrm{CP} \\) elements \\(j \\N \\setminus \\{\\}\\). (Copeland-like relation [10]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). Copeland-like relation binary relation \\(R^\\succeq_\\textrm{Cop} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{Cop}j \\Leftrightarrow \\text{Score}_\\text{Cop}() \\geq \\text{Score}_\\text{Cop}(j), \\end{equation}\\] \\(\\text{Score}_\\text{Cop}() = |\\{j \\N \\setminus \\{\\}: d_{ij}(\\succeq) \\geq d_{ji}(\\succeq)\\}| - |\\{j \\N \\setminus \\{\\}: d_{ij}(\\succeq) \\leq d_{ji}(\\succeq)\\}|\\) copelandScores(pr) returns two numerical values element, positive number winning comparisons (shown \\(\\text{Score}_\\text{Cop}()\\) left) negative number losing comparisons (\\(\\text{Score}_\\text{Cop}()\\) right).","code":"pr <- newPowerRelationFromString(\"(abc ~ ab ~ c ~ a) > (b ~ bc) > ac\") scores <- copelandScores(pr)  # Based on CP-Majority, a>=b and a>=c (+2), but b>=a (-1) scores$a ## [1]  2 -1 sapply(copelandScores(pr), sum) ##  a  b  c  ##  1  0 -1 copelandRanking(pr) ## a > b > c"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ch:kramerSimpson","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Social Ranking Solutions","what":"Kramer-Simpson-like method","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Strongly inspired Kramer-Simpson method social choice theory[16, 17], elements ranked inversely greatest pairwise defeat possible CP-Majority comparisons. (Kramer-Simpson-like relation [10]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). Kramer-Simpson-like relation binary relation \\(R^\\succeq_\\textrm{KS} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{KS}j \\Leftrightarrow \\text{Score}_\\text{KS}() \\leq \\text{Score}_\\text{KS}(j), \\end{equation}\\] \\(\\text{Score}_\\text{KS}() = \\max_j d_{ji}(\\succeq)\\) \\(j \\N \\setminus \\{\\}\\). kramerSimpsonScores(pr) returns single numerical value element, sorted lowest highest gives us ranking solution. small caveat Definition 8. default function compare \\(d_{ii}(\\succeq)\\). terms, score every element maximum CP-Majority comparison score elements. slightly different definition found [10], CP-Majority comparison \\(d_{ii}(\\succeq)\\) also considered. Since definition \\(d_{ii}(\\succeq) = 0\\), Kramer-Simpson scores cases never negative, possibly discarding valuable information. still account original definition [10], functions kramerSimpsonScores kramerSimpsonRanking offer compIvsI parameter can set TRUE one wishes \\(d_{ii}(\\succeq)\\) included comparisons.","code":"pr <- newPowerRelationFromString(\"(abc ~ ab ~ c ~ a) > (b ~ bc) > ac\") unlist(kramerSimpsonScores(pr)) ## a b c  ## 0 0 1 kramerSimpsonRanking(pr) ## a ~ b > c pr <- newPowerRelationFromString(   \"b > (a ~ c) > ab > (ac ~ bc) > {} > abc\" ) kramerSimpsonRanking(pr) ## b > a > c # notice how b's score is negative unlist(kramerSimpsonScores(pr)) ##  a  b  c  ##  1 -1  2 kramerSimpsonScores(pr, elements = \"b\", compIvsI = TRUE) ## $b ## [1] 0 ##  ## attr(,\"class\") ## [1] \"KramerSimpsonScores\""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"ch:lexcel","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Social Ranking Solutions","what":"Lexicographical Excellence Solution","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"idea behind lexicographical excellence solution (Lexcel) reward elements appearing frequently higher ranked equivalence classes. given power relation \\(\\succeq\\) quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), denote \\(i_k\\) number coalitions \\(\\sum_k\\) containing \\(\\): \\[\\begin{equation}     i_k = |\\{S \\\\textstyle \\sum_k: \\S\\}| \\end{equation}\\] \\(k \\\\{1, \\dots, m\\}\\). Now, let \\(\\text{Score}_\\text{Lex}()\\) \\(m\\)-dimensional vector \\(\\text{Score}_\\text{Lex}() = (i_1, \\dots, i_m)\\) associated \\(\\succeq\\). Consider lexicographic order \\(\\geq_\\textrm{Lex}\\) among vectors \\(\\mathbf{}\\) \\(\\mathbf{j}\\): \\(\\mathbf{} \\geq_\\textrm{Lex} \\mathbf{j}\\) either \\(\\mathbf{} = \\mathbf{j}\\) exists \\(t : i_r = j_r, r \\\\{1,\\dots,t-1\\}\\), \\(i_t > j_t\\). (Lexicographic-Excellence relation [8]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) corresponding quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\). Lexicographic-Excellence relation binary relation \\(R^\\succeq_\\textrm{Lex} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{Lex}j \\Leftrightarrow \\text{Score}_\\text{Lex}() \\geq_{\\textrm{Lex}} \\text{Score}_\\text{Lex}(j) \\end{equation}\\] generalizations Lexcel solution see also [9]. Lexcel score vectors similar cumulative score vectors (see section Cumulative Dominance) number times element appears given equivalence class interest. fact, applying base function cumsum element’s lexcel score gives us cumulative score.","code":"pr <- newPowerRelationFromString(   \"12 > (123 ~ 23 ~ 3) > (1 ~ 2) > 13\",   asWhat = as.numeric )  # show the number of times an element appears in each equivalence class # e.g. 3 appears 3 times in [[2]] and 1 time in [[4]] lapply(pr$equivalenceClasses, unlist) ## [[1]] ## [1] 1 2 ##  ## [[2]] ## [1] 1 2 3 2 3 3 ##  ## [[3]] ## [1] 1 2 ##  ## [[4]] ## [1] 1 3 lexScores <- lexcelScores(pr) for(i in names(lexScores))   paste0(\"Lexcel score of element \", i, \": \", lexScores[i])  # at index 1, element 2 ranks higher than 3 lexScores['2'] > lexScores['3'] ## [1] TRUE # at index 2, element 2 ranks higher than 1 lexScores['2'] > lexScores['1'] ## [1] TRUE lexcelRanking(pr) ## 2 > 1 > 3 lexcelCumulated <- lapply(lexScores, cumsum) cumulScores <- cumulativeScores(pr)  paste0(names(lexcelCumulated), \": \", lexcelCumulated, collapse = ', ') ## [1] \"1: 1:4, 2: c(1, 3, 4, 4), 3: c(0, 3, 3, 4)\" paste0(names(cumulScores), \": \", cumulScores, collapse = ', ') ## [1] \"1: 1:4, 2: c(1, 3, 4, 4), 3: c(0, 3, 3, 4)\""},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"dual-lexicographical-excellence-solution","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Social Ranking Solutions","what":"Dual Lexicographical Excellence Solution","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Similar Lexcel ranking, Dual Lexcel also uses Lexcel score vectors definition 9 establish ranking. However, instead rewarding higher frequencies high ranking coalitions, punishes higher frequencies lower ranking coalitions, , punishes mediocrity[14]. Take values \\(i_k\\) \\(k \\\\{1, \\dots, m\\}\\) Lexcel score vector \\(\\text{Score}_\\text{Lex}()\\) section Lexicographical Excellence Solution. Consider dual lexicographical order \\(\\geq_\\textrm{DualLex}\\) among vectors \\(\\mathbf{}\\) \\(\\mathbf{j}\\): \\(\\mathbf{} \\geq_\\textrm{DualLex} \\mathbf{j}\\) either \\(\\mathbf{} = \\mathbf{j}\\) exists \\(t: i_t < j_t\\) \\(i_r = j_r, r\\\\{t+1, \\dots, m\\}\\). (Dual Lexicographical-Excellence relation [14]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). Dual Lexicographic-Excellence relation binary relation \\(R^\\succeq_\\textrm{DualLex} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{DualLex}j \\Leftrightarrow \\text{Score}_\\text{Lex}() \\geq_\\textrm{DualLex} \\text{Score}_\\text{Lex}(j) \\end{equation}\\] S3 class LexcelScores account Dual Lexcel comparisons. Instead -rev(x) called Lexcel score vector x resulting comparisons produces Dual Lexcel ranking solution.","code":"pr <- newPowerRelationFromString(   \"12 > (123 ~ 23 ~ 3) > (1 ~ 2) > 13\",   asWhat = as.numeric )  lexScores <- lexcelScores(pr)  # in regular Lexcel, 1 scores higher than 3 lexScores['1'] > lexScores['3'] ## [1] TRUE # turn Lexcel score into Dual Lexcel score dualLexScores <- structure(   lapply(lexcelScores(pr), function(r) -rev(r)),   class = 'LexcelScores' )  # now 1 scores lower than 3 dualLexScores['1'] > dualLexScores['3'] ## [1] FALSE # element 2 comes out at the top in both Lexcel and Dual Lexcel lexcelRanking(pr) ## 2 > 1 > 3 dualLexcelRanking(pr) ## 2 > 3 > 1"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"incidence-matrix","dir":"Articles","previous_headings":"Relations","what":"Incidence Matrix","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"vignette focused intuitive aspects power relations social ranking solutions. reiterate, power relation total preorder, reflexive transitive relation \\(\\succeq \\\\mathcal{P} \\times \\mathcal{P}\\), \\(\\sim\\) denotes symmetric part \\(\\succ\\) asymmetric part. power relation can viewed incidence matrix \\((b_{ij}) = B \\\\{0,1\\}^{|\\mathcal{P}| \\times |\\mathcal{P}|}\\). Given two coalitions \\(, j \\\\mathcal{P}\\), \\(iRj\\) \\(b_{ij} = 1\\), else \\(0\\). help relations package, functions relations::.relation(pr) powerRelationMatrix(pr) turn PowerRelation object relation object. relations offers ways display relation object incidence matrix relation_incidence(rel) test basic properties relation_is_linear_order(rel), relation_is_acyclic(rel) relation_is_antisymmetric(rel) (see relations package [11]). Note columns rows sorted names relation_domain(rel), hence name preceded ordering number.","code":"pr <- newPowerRelationFromString(\"ab > a > {} > b\") rel <- relations::as.relation(pr)  relations::relation_incidence(rel) ## Incidences: ##    ab ​a ​​{} ​​​b ## ab  1 1  1 1 ## ​a   0 1  1 1 ## ​​{}  0 0  1 1 ## ​​​b   0 0  0 1 c(   relations::relation_is_acyclic(rel),   relations::relation_is_antisymmetric(rel),   relations::relation_is_linear_order(rel),   relations::relation_is_complete(rel),   relations::relation_is_reflexive(rel),   relations::relation_is_transitive(rel) ) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE # a power relation where coalitions {1} and {2} are indifferent pr <- newPowerRelationFromString(\"12 > (1 ~ 2)\", asWhat = as.numeric) rel <- relations::as.relation(pr)  # we have both binary relations {1}R{2} as well as {2}R{1} relations::relation_incidence(rel) ## Incidences: ##    12 ​1 ​​2 ## 12  1 1 1 ## ​1   0 1 1 ## ​​2   0 1 1 # FALSE c(   relations::relation_is_acyclic(rel),   relations::relation_is_antisymmetric(rel),   relations::relation_is_linear_order(rel),   relations::relation_is_complete(rel),   relations::relation_is_reflexive(rel),   relations::relation_is_transitive(rel) ) ## [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking.html","id":"cycles-and-transitive-closure","dir":"Articles","previous_headings":"Relations","what":"Cycles and Transitive Closure","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"cycle power relation exists, one coalition \\(S \\2^N\\) appears twice. example, \\(\\{1,2\\} \\succ (\\{1\\} \\sim \\emptyset) \\succ \\{1,2\\}\\), coalition \\(\\{1,2\\}\\) appears beginning end power relation. Properly handling power relations calculating social ranking solutions cycles somewhat ill-defined, hence warning message shown soon one created. Recall power relation transitive, meaning three coalitions \\(x, y, z \\2^N\\), \\(xRy\\) \\(yRz\\), \\(xRz\\). introduce cycles, pretty much introduce symmetry. Assume power relation \\(x \\succ y \\succ x\\). , even though \\(xRy\\) \\(yRx\\) defined asymmetric part power relation \\(\\succeq\\), together form symmetric power relation \\(x \\sim y\\). transitiveClosure(pr) function turns power relation cycles one without one. process removing duplicate coalitions, turns asymmectric relations within cycle symmetric relations.","code":"newPowerRelation(c(1,2), \">\", 2, \">\", 1, \"~\", 2, \">\", c(1,2)) ## Warning in newPowerRelation(c(1, 2), \">\", 2, \">\", 1, \"~\", 2, \">\", c(1, 2)): Found the following duplicates. Did you mean to introduce cycles? ##   {2} ##   {1, 2} ## Elements: 1 2 ## 12 > 2 > (1 ~ 2) > 12 pr <- suppressWarnings(newPowerRelation(1, '>', 2, '>', 1)) pr ## Elements: 1 2 ## 1 > 2 > 1 transitiveClosure(pr) ## Elements: 1 2 ## (1 ~ 2) # two cycles, (1>3>1) and (2>23>2) pr <- suppressWarnings(   newPowerRelationFromString(     \"1 > 3 > 1 > 2 > 23 > 2\",     asWhat = as.numeric   ) )  transitiveClosure(pr) ## Elements: 1 2 3 ## (1 ~ 3) > (2 ~ 23) # overlapping cycles pr <- suppressWarnings(   newPowerRelationFromString(\"c > ac > b > ac > (a ~ b) > abc\") )  transitiveClosure(pr) ## Elements: a b c ## c > (ac ~ b ~ a) > abc"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"literature cooperative games, notion power index [1–3] widely studied analyze ``influence” individuals taking account ability force decision within groups coalitions. practical situations, however, information concerning strength coalitions hardly quantifiable. , attempt numerically represent influence groups individuals clashes complex multi-attribute nature problem seems realistic represent collective decision-making mechanisms using ordinal coalitional framework based two main ingredients: binary relation groups coalitions ranking individuals. main objective package socialranking provide answers general problem compare elements finite set \\(N\\) given ranking elements power-set (set possible subsets \\(N\\)). , package socialranking implements portfolio solutions recent literature social rankings [4–10].","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"quick-start","dir":"Articles","previous_headings":"Introduction","what":"Quick Start","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"power relation (.e, ranking subsets finite set \\(N\\); see Section PowerRelation objects formal definition) can constructed using newPowerRelation() newPowerRelationFromString() functions. Functions used analyze given PowerRelation object can grouped three main categories: Comparison functions, comparing two elements; Score functions, calculating scores element; Ranking functions, creating SocialRankingSolution objects. Comparison score functions often used evaluate social ranking solution (see section PowerRelation objects formal definition). Listed prominent functions solutions introduced aforementioned papers. functions may called follows. Finally incidence matrix given coalitions can constructed using powerRelationMatrix(pr) .relation(pr) relations package [11]. incidence matrix may displayed using relations::relation_incidence().","code":"library(socialranking) newPowerRelation(c(1,2), \">\", 1, \"~\", c(), \">\", 2) ## Elements: 1 2 ## 12 > (1 ~ {}) > 2 newPowerRelationFromString(\"ab > a ~ {} > b\") ## Elements: a b ## ab > (a ~ {}) > b newPowerRelationFromString(\"12 > 1 ~ {} > 2\", asWhat = as.numeric) ## Elements: 1 2 ## 12 > (1 ~ {}) > 2 pr <- newPowerRelationFromString(\"ab > ac ~ bc > a ~ c > {} > b\")  # a dominates b -> TRUE dominates(pr, \"a\", \"b\") ## [1] TRUE # b does not dominate a -> FALSE dominates(pr, \"b\", \"a\") ## [1] FALSE # calculate cumulative scores scores <- cumulativeScores(pr) # show score of element a scores$a ## [1] 1 2 3 3 3 # performing a bunch of rankings lexcelRanking(pr) ## a > b > c dualLexcelRanking(pr) ## a > c > b copelandRanking(pr) ## a > b ~ c kramerSimpsonRanking(pr) ## a > b ~ c ordinalBanzhafRanking(pr) ## a ~ c > b rel <- relations::as.relation(pr) rel ## A binary relation of size 7 x 7. relations::relation_incidence(rel) ## Incidences: ##    ab ​ac ​​bc ​​​a ​​​​c ​​​​​{} ​​​​​​b ## ab  1  1  1 1 1  1 1 ## ​ac  0  1  1 1 1  1 1 ## ​​bc  0  1  1 1 1  1 1 ## ​​​a   0  0  0 1 1  1 1 ## ​​​​c   0  0  0 1 1  1 1 ## ​​​​​{}  0  0  0 0 0  1 1 ## ​​​​​​b   0  0  0 0 0  0 1"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"sec:prelim","dir":"Articles","previous_headings":"","what":"PowerRelation Objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"first introduce basic definitions binary relations. Let \\(X\\) set. set \\(R \\subseteq X \\times X\\) said binary relation \\(X\\). two elements \\(x, y \\X\\), \\(xRy\\) refers relation, formally means \\((x,y) \\R\\). binary relation \\((x,y) \\R\\) said : reflexive, \\(x \\X, xRx\\) transitive, \\(x, y, z \\X, xRy\\) \\(yRz \\Rightarrow xRz\\) total, \\(x,y \\X, x \\neq y \\Rightarrow xRy\\) \\(yRx\\) symmetric, \\(x,y \\X,xRy \\Leftrightarrow yRx\\) asymmetric, \\(x,y \\X,(x,y) \\R \\Rightarrow (y,x) \\notin R\\) antisymmetric, \\(x,y \\X,xRy \\cap yRx \\Rightarrow x=y\\) preorder defined reflexive transitive relation. total, called total preorder. Additionally antisymmetric, called linear order. Let \\(N = \\{1, 2, \\dots, n\\}\\) finite set elements, sometimes also called players. \\(p \\\\{1, \\ldots, 2^n\\}\\), let \\(\\mathcal{P} = \\{S_1, S_2, \\dots, S_{p}\\}\\) set coalitions \\(S_i \\subseteq N\\) \\(\\\\{1, \\ldots, p\\}\\). Thus \\(\\mathcal{P} \\subseteq 2^N\\), \\(2^N\\) denotes power set \\(N\\) (.e., set subsets coalitions \\(N\\)). \\(\\mathcal{T}(N)\\) denotes set total preorders \\(N\\), \\(\\mathcal{T}(\\mathcal{P})\\) set total preorders \\(\\mathcal{P}\\). single total preorder \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) said power relation. given power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) \\(\\mathcal{P} \\subseteq 2^N\\), symmetric part denoted \\(\\sim\\) (.e., \\(S \\sim T\\) \\(S \\succeq T\\) \\(T \\succeq S\\)), whereas asymmetric part denoted \\(\\succ\\) (.e., \\(S \\succ T\\) \\(S \\succeq T\\) \\(T \\succeq S\\)). terms, \\(S \\sim T\\) say \\(S\\) indifferent \\(T\\), whereas \\(S \\succ T\\) say \\(S\\) strictly better \\(T\\). Lastly given power relation form \\(S_1 \\succeq S_2 \\succeq \\ldots \\succeq S_m\\), coalitions indifferent one another can grouped equivalence classes \\(\\sum_i\\) get quotient order \\(\\sum_1 \\succ \\sum_2 \\succ \\ldots \\succ \\sum_m\\). Let \\(N=\\{1,2\\}\\) two players corresponding power set \\(2^N = \\{\\{1,2\\}, \\{1\\}, \\{2\\}, \\emptyset\\}\\). following power relation given: \\(\\succeq = \\{(\\{1,2\\},\\{2\\}), (\\{2\\}, \\emptyset), (\\emptyset, \\{2\\}), (\\emptyset, \\{1\\})\\}\\). power relation can rewritten consecutive order : \\(\\{1,2\\} \\succ \\{2\\} \\sim \\emptyset \\succ \\{1\\}\\). quotient order formed three equivalence classes \\(\\sum_1 = \\{\\{1,2\\}\\}, \\sum_2 = \\{\\{2\\}, \\emptyset\\},\\) \\(\\sum_3 = \\{\\{1\\}\\}\\); quotient order \\(\\succeq\\) \\(\\{\\{1,2\\}\\} \\succ \\{\\{2\\}, \\emptyset\\} \\succ \\{\\{1\\}\\}\\). social ranking solution (also called social ranking , simply, solution) \\(N\\), function \\(R: \\mathcal{T}(\\mathcal{P}) \\longrightarrow \\mathcal{T}(N)\\) associating power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) total preorder \\(R(\\succeq)\\) (\\(R^\\succeq\\)) elements \\(N\\). definition, notion \\(R^\\succeq j\\) means applying social ranking solution power relation \\(\\succeq\\) gives result \\(\\) ranked higher equal \\(j\\).","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"creating-powerrelation-objects","dir":"Articles","previous_headings":"PowerRelation Objects","what":"Creating PowerRelation Objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"power relation socialranking package defined reflexive, transitive total. designing package deemed logical coalitions specified consecutive order, seen Example 1. coalition order split either \">\" (left side strictly better) \"~\" (two coalitions indifferent one another). following code chunk shows power relation Example 1 correlating PowerRelation object can constructed. Notice coalitions \\(\\{1,2\\}\\) written 12 improve readability. Similarly function newPowerRelationFromString saves typing user’s end interpreting character coalition separate player. Note spaces function ignored. compact notation done PowerRelation objects every player one digit one character long. case, curly braces commas added needed. may spotted \"SingleCharElements\" class missing class(prLong) class(pr). \"SingleCharElements\" influences way coalitions printed. removed class(pr), output include curly braces commas displayed prLong. Internally PowerRelation list four attributes (see table ). Notice every coalition vector turned set object sets package[12]. Since coalition vector turned set, coalitions c(1,2), c(2,1) c(1,1,2,2) equivalent. equivalenceClassIndex() determines index \\(\\) coalition \\(S \\\\sum_i\\).","code":"library(socialranking) pr <- newPowerRelation(c(1,2), \">\", 2, \"~\", c(), \">\", 1) pr ## Elements: 1 2 ## 12 > (2 ~ {}) > 1 class(pr) ## [1] \"PowerRelation\"      \"SingleCharElements\" newPowerRelationFromString(\"12 > 2~{} > 1\", asWhat = as.numeric) ## Elements: 1 2 ## 12 > (2 ~ {}) > 1 prLong <- newPowerRelation(   c(\"Alice\", \"Bob\"), \">\", \"Bob\", \"~\", c(), \">\", \"Alice\" ) prLong ## Elements: Alice Bob ## {Alice, Bob} > ({Bob} ~ {}) > {Alice} class(prLong) ## [1] \"PowerRelation\" class(pr) <- class(pr)[-which(class(pr) == \"SingleCharElements\")] pr ## Elements: 1 2 ## {1, 2} > ({2} ~ {}) > {1} prAtts <- newPowerRelation(c(2,2,1,1,2), \">\", c(1,1,1), \"~\", c()) prAtts ## Elements: 1 2 ## 12 > (1 ~ {}) prAtts$elements ## [1] 1 2 prAtts$rankingCoalitions ## [[1]] ## {1, 2} ##  ## [[2]] ## {1} ##  ## [[3]] ## {} prAtts$rankingComparators ## [1] \">\" \"~\" prAtts$equivalenceClasses ## [[1]] ## [[1]][[1]] ## {1, 2} ##  ##  ## [[2]] ## [[2]][[1]] ## {1} ##  ## [[2]][[2]] ## {} equivalenceClassIndex(prAtts, c(2,1)) ## [1] 1 equivalenceClassIndex(prAtts, 1) ## [1] 2 equivalenceClassIndex(prAtts, c()) ## [1] 2 # are the given coalitions in the same equivalence class? coalitionsAreIndifferent(prAtts, 1, c()) ## [1] TRUE coalitionsAreIndifferent(prAtts, 1, c(1,2)) ## [1] FALSE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"manipulating-powerrelation-objects","dir":"Articles","previous_headings":"PowerRelation Objects","what":"Manipulating PowerRelation Objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"strongly discouraged directly manipulate PowerRelation objects, since modifying one list vector entry require updates attributes. Instead newPowerRelation offers two parameters rankingCoalitions rankingComparators, corresponding named attributes PowerRelation object. Note rankingComparators optional. default assumes rankingCoalitions linear order. length rankingComparators vector smaller larger length rankingCoalitions, function silently fills gaps.","code":"pr ## Elements: 1 2 ## {1, 2} > ({2} ~ {}) > {1} # reverse power ranking newPowerRelation(   rankingCoalitions = rev(pr$rankingCoalitions),   rankingComparators = pr$rankingComparators ) ## Elements: 1 2 ## 1 > ({} ~ 2) > 12 newPowerRelation(rankingCoalitions = rev(pr$rankingCoalitions)) ## Elements: 1 2 ## 1 > {} > 2 > 12 # if too short -> comparator values are repeated newPowerRelation(   rankingCoalitions = as.list(1:9),   rankingComparators = \"~\" ) ## Elements: 1 2 3 4 5 6 7 8 9 ## (1 ~ 2 ~ 3 ~ 4 ~ 5 ~ 6 ~ 7 ~ 8 ~ 9) newPowerRelation(     rankingCoalitions = as.list(letters[1:9]),     rankingComparators = c(\">\", \"~\", \"~\") ) ## Elements: a b c d e f g h i ## a > (b ~ c ~ d) > (e ~ f ~ g) > (h ~ i) # if too long -> ignore excessive comparators newPowerRelation(   rankingCoalitions = pr$rankingCoalitions,   rankingComparators = c(\"~\", \">\", \"~\", \">\", \">\", \"~\") ) ## Elements: 1 2 ## (12 ~ 2) > ({} ~ 1)"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"creating-power-sets","dir":"Articles","previous_headings":"PowerRelation Objects","what":"Creating Power sets","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"number elements \\(n\\) increases, number possible coalitions increases \\(|2^N| = 2^n\\). createPowerset convenient function creates power set \\(2^N\\) can used call newPowerRelation, also formats function call way makes easy rearrange ordering coalitions. RStudio offers shortcuts Alt+Alt+(Option+Option+MacOS) move one multiple lines code (see fig. ). Using Alt+Alt+move one lines code writeLines copyToClipboard set FALSE, function instead returns list containing coalition vectors. list can passed directly rankingCoalitions parameter newPowerRelation.","code":"createPowerset(   c(\"a\", \"b\", \"c\"),   writeLines = TRUE,   copyToClipboard = FALSE ) ## newPowerRelation( ##   c(\"a\", \"b\", \"c\"), ##   \">\", c(\"a\", \"b\"), ##   \">\", c(\"a\", \"c\"), ##   \">\", c(\"b\", \"c\"), ##   \">\", c(\"a\"), ##   \">\", c(\"b\"), ##   \">\", c(\"c\"), ##   \">\", c(), ## ) ps <- createPowerset(1:2, includeEmptySet = FALSE) ps ## [[1]] ## [1] 1 2 ##  ## [[2]] ## [1] 1 ##  ## [[3]] ## [1] 2 newPowerRelation(rankingCoalitions = ps) ## Elements: 1 2 ## 12 > 1 > 2 newPowerRelation(rankingCoalitions = createPowerset(letters[1:4])) ## Elements: a b c d ## abcd > abc > abd > acd > bcd > ab > ac > ad > bc > bd > cd > a > b > c > d > {}"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"socialrankingsolution-objects","dir":"Articles","previous_headings":"","what":"SocialRankingSolution Objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"main goal socialranking package rank elements based given power ranking. formally try map \\(R: \\mathcal{T}(\\mathcal{P}) \\rightarrow \\mathcal{T}(N)\\), associating power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) total preorder \\(R(\\succeq)\\) (\\(R^\\succeq\\)) elements \\(N\\). context \\(R^\\succeq j\\) tells us , given power relation \\(\\succeq\\) applying social ranking solution \\(R(\\succeq)\\), \\(\\) ranked higher equal \\(j\\). , > ~ also denote asymmetric symmetric part social ranking, respectively, \\(\\) > \\(j\\) indicating \\(\\) strictly better \\(j\\), whereas \\(\\) ~ \\(j\\), \\(\\) indifferent \\(j\\). section 3.1 show general SocialRankingSolution object can constructed using doRanking function. following sections, introduce notion dominance[4], cumulative dominance[13] CP-Majority comparison[6] lets us compare two elements diving social ranking solutions Ordinal Banzhaf Index[5], Copeland-like Kramer-Simpson-like methods[10], lastly Lexicographical Excellence Solution[9] (Lexcel) Dual Lexicographical Excellence solution[14] (Dual Lexcel). Let \\(\\{,b\\} \\succ (\\{,c\\} \\sim \\{b,c\\}) \\succ (\\{\\} \\sim \\{c\\}) > \\emptyset \\succ \\{b\\}\\) power ranking. Using following social ranking solutions, get: > b > c lexcelRanking > c > b dualLexcelRanking > b ~ c copelandRanking kramerSimpsonRanking ~ c > b ordinalBanzhafRanking","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"creating-socialrankingsolution-objects","dir":"Articles","previous_headings":"SocialRankingSolution Objects","what":"Creating SocialRankingSolution objects","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"SocialRankingSolution object represents total preorder \\(\\mathcal{T}(N)\\) elements \\(N\\). Internally saved list vectors, containing players indifferent one another. somewhat similar equivalenceClasses attribute PowerRelation objects. function doRanking offers generic way creating SocialRankingSolution objects. Given PowerRelation object sortable vector list scores determines power relation players. Note length(scores) == length(powerRelation$elements) must TRUE. Additionally index scores corresponds index sorted vector powerRelation$elements. default elements assumed indifferent one another scores equal. Sometimes however factors come play make non-obvious compare two scores. cases function comparing two scores can passed return TRUE two scores considered equal.","code":"pr <- newPowerRelationFromString(\"abc > ab ~ ac > bc\")  # pr$elements == c(\"a\", \"b\", \"c\") # we define some arbitrary score vector where \"a\" scores highest # \"b\" and \"c\" both score 1, thus they are indifferent scores <- c(100, 1, 1) doRanking(pr, scores) ## a > b ~ c # we can also tell doRanking to punish higher scores doRanking(pr, scores, decreasing = FALSE) ## b ~ c > a scores <- c(0, 20, 21) # b and c are considered to be indifferent, # because their score difference is less than 2 doRanking(pr, scores, isIndifferent = function(a,b) abs(a-b) < 2) ## b ~ c > a"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"comparison-functions","dir":"Articles","previous_headings":"SocialRankingSolution Objects","what":"Comparison Functions","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Comparison functions compare two elements given power relation. offer social ranking solution. However cases CP-Majority comparison, comparison functions may used construct social ranking solution particular cases.","code":""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ch:dominance","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Comparison Functions","what":"Dominance","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"(Dominance [4]) Given power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) two elements \\(,j \\N\\), \\(\\) dominates \\(j\\) \\(\\succeq\\) \\(S \\cup \\{\\} \\succeq S \\cup \\{j\\}\\) \\(S \\2^{N\\setminus \\{,j\\}}\\). \\(\\) also strictly dominates \\(j\\) exists \\(S \\2^{N\\setminus \\{,j\\}}\\) \\(S \\cup \\{\\} \\succ S \\cup \\{j\\}\\). implication every coalition \\(\\) \\(j\\) can join, \\(\\) least positive impact \\(j\\). function dominates(pr, e1, e2) returns logical value TRUE e1 dominates e2, else FALSE. Note e1 dominating e2 indicate e2 dominates e1, imply e1 indifferent e2. \\(S \\2^{N \\setminus \\{,j\\}}\\), can compare \\(S \\cup \\{\\} \\succeq S \\cup \\{j\\}\\) \\(S \\cup \\{\\}\\) \\(S \\cup \\{j\\}\\) take part power relation. Additionally, \\(S = \\emptyset\\), also want compare \\(\\{\\} \\succeq \\{j\\}\\). situations however comparison singletons desired. reason parameter includeEmptySet can set FALSE \\(\\emptyset \\cup \\{\\} \\succeq \\emptyset \\cup \\{j\\}\\) considered CP-Majority comparison.","code":"pr <- newPowerRelationFromString(   \"3 > 1 > 2 > 12 > 13 > 23\",   asWhat = as.numeric )  # 1 clearly dominates 2 dominates(pr, 1, 2) ## [1] TRUE dominates(pr, 2, 1) ## [1] FALSE # 3 does not dominate 1, nor does 1 dominate 3, because # {}u3 > {}u1, but 2u1 > 2u3 dominates(pr, 1, 3) ## [1] FALSE dominates(pr, 3, 1) ## [1] FALSE # an element i dominates itself, but it does not strictly dominate itself # because there is no Sui > Sui dominates(pr, 1, 1) ## [1] TRUE dominates(pr, 1, 1, strictly = TRUE) ## [1] FALSE pr <- newPowerRelationFromString(\"ac > bc ~ b > a ~ abc > ab\")  # FALSE because ac > bc, whereas b > a dominates(pr, \"a\", \"b\") ## [1] FALSE # TRUE because ac > bc, ignoring b > a comparison dominates(pr, \"a\", \"b\", includeEmptySet = FALSE) ## [1] TRUE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ch:cumul","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Comparison Functions","what":"Cumulative Dominance","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"comparing two players \\(,j \\N\\), instead looking particular coalitions \\(S \\2^{N \\setminus \\{,j\\}}\\) can join, look many stronger coalitions can form point. property originally introduced [13] regular dominance axiom. given power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) corresponding quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), power player \\(\\) given vector \\(\\textrm{Score}_\\textrm{Cumul}() \\\\mathbb{N}^m\\) cumulatively sum amount times \\(\\) appears \\(\\sum_k\\) index \\(k\\). (Cumulative Dominance Score) Given power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), cumulative score vector \\(\\textrm{Score}_\\textrm{Cumul}() \\\\mathbb{N}^m\\) element \\(\\N\\) given : \\[\\begin{equation}     \\textrm{Score}_\\textrm{Cumul}() = \\Big( \\sum_{t=1}^k |\\{S \\\\textstyle \\sum_t : \\S\\}|\\Big)_{k \\\\{1, \\dots, m\\}} \\end{equation}\\] (Cumulative Dominance) Given two elements \\(,j \\N\\), \\(\\) cumulatively dominates \\(j\\) \\(\\succeq\\), \\(\\textrm{Score}_\\textrm{Cumul}()_k \\geq \\textrm{Score}_\\textrm{Cumul}(j)_k\\) \\(k \\\\{1, \\dots, m\\}\\). \\(\\) also strictly cumulatively dominates \\(j\\) exists \\(k\\) \\(\\textrm{Score}_\\textrm{Cumul}()_k > \\textrm{Score}_\\textrm{Cumul}(j)_k\\). given PowerRelation object pr two elements e1 e2, cumulativeScores(pr) returns vectors described definition 2 element, cumulativelyDominates(pr, e1, e2) returns TRUE FALSE based definition 3. Similar dominance property previous section, two elements dominating one indicate indifferent.","code":"pr <- newPowerRelationFromString(\"ab > (ac ~ bc) > (a ~ c) > {} > b\") cumulativeScores(pr) ## $a ## [1] 1 2 3 3 3 ##  ## $b ## [1] 1 2 2 2 3 ##  ## $c ## [1] 0 2 3 3 3 ##  ## attr(,\"class\") ## [1] \"CumulativeScores\" # for each index k, $a[k] >= $b[k] cumulativelyDominates(pr, \"a\", \"b\") ## [1] TRUE # $a[3] > $b[3], therefore a also strictly dominates b cumulativelyDominates(pr, \"a\", \"b\", strictly = TRUE) ## [1] TRUE # $b[1] > $c[1], but $c[3] > $b[3] # therefore neither b nor c dominate each other cumulativelyDominates(pr, \"b\", \"c\") ## [1] FALSE cumulativelyDominates(pr, \"c\", \"b\") ## [1] FALSE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"cp-majority-comparison","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Comparison Functions","what":"CP-Majority comparison","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Ceteris Paribus Majority (CP-Majority) relation somewhat relaxed version dominance property. Instead checking \\(S \\cup \\{\\} \\succeq S \\cup \\{j\\}\\) \\(S \\2^{N \\setminus \\{,j\\}}\\), CP-Majority relation \\(iR^\\succeq_\\textrm{CP}j\\) holds number times \\(S \\cup \\{\\} \\succeq S \\cup \\{j\\}\\) greater equal number times \\(S \\cup \\{j\\} \\succeq S \\cup \\{\\}\\). (CP-Majority [6]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). Ceteris Paribus majority relation binary relation \\(R^\\succeq_\\textrm{CP} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{CP}j \\Leftrightarrow d_{ij}(\\succeq) \\geq d_{ji}(\\succeq) \\end{equation}\\] \\(d_{ij}(\\succeq)\\) represents cardinality set \\(D_{ij}(\\succeq)\\), set coalitions \\(S \\2^{N \\setminus \\{,j\\}}\\) \\(S \\cup \\{\\} \\succeq S \\cup \\{j\\}\\). cpMajorityComparisonScore(pr, e1, e2) calculates two scores \\(d_{ij}(\\succeq)\\) \\(-d_{ji}(\\succeq)\\). Notice minus sign - way can use sum values determine relation e1 e2. slight variation logical parameter strictly calculates \\(d_{ij}(\\succ)\\) \\(-d_{ji}(\\succ)\\), number coalitions \\(S \\2^{N\\setminus \\{,j\\}}\\) \\(S\\cup\\{\\}\\succ S\\cup\\{j\\}\\). Coincidentally, cpMajorityComparisonScore strictly = TRUE can used determine e1 (strictly) dominates e2. cpMajorityComparisonScore used simple quick calculations. comprehensive function cpMajorityComparison(pr, e1, e2) calculations, process retains information comparisons might interesting user, .e., set \\(D_{ij}(\\succeq)\\) \\(D_{ji}(\\succeq)\\) well relation \\(iR^\\succeq_\\textrm{CP}j\\). See documentation full list available data. CP-Majority relation can generate cycles, reason offered social ranking solution. Instead introduce Copeland-like method Kramer-Simpson-like method make use CP-Majority functions determine power relation elements. readings CP-Majority, see [7] [10].","code":"pr <- newPowerRelationFromString(\"ab > (ac ~ bc) > (a ~ c) > {} > b\") cpMajorityComparisonScore(pr, \"a\", \"b\") ## [1]  2 -1 cpMajorityComparisonScore(pr, \"b\", \"a\") ## [1]  1 -2 if(sum(cpMajorityComparisonScore(pr, \"a\", \"b\")) >= 0) {   print(\"a >= b\") } else {   print(\"b > a\") } ## [1] \"a >= b\" # Now (ac ~ bc) is not counted cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = TRUE) ## [1] 1 0 # Notice that the sum is still the same sum(cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = FALSE)) ==   sum(cpMajorityComparisonScore(pr, \"a\", \"b\", strictly = TRUE)) ## [1] TRUE # extract more information in cpMajorityComparison cpMajorityComparison(pr, \"a\", \"b\") ## a > b ## D_ab = {c, {}} ## D_ba = {c} ## Score of a = 2 ## Score of b = 1 # with strictly set to TRUE, coalition c does # neither appear in D_ab nor in D_ba cpMajorityComparison(pr, \"a\", \"b\", strictly = TRUE) ## a > b ## D_ab = {{}} ## D_ba = {} ## Score of a = 1 ## Score of b = 0"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ordinal-banzhaf","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Social Ranking Solutions","what":"Ordinal Banzhaf","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Ordinal Banzhaf Score vector defined principle marginal contributions. Intuitively speaking, player joining coalition causes move ranking, can interpreted positive contribution. contrary negative contribution means participating causes coalition go ranking. (Ordinal marginal contribution [5]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). given element \\(\\N\\), ordinal marginal contribution \\(m_i^S(\\succeq)\\) right coalition \\(S \\\\mathcal{P}\\) defined : \\[\\begin{equation}     m_i^S(\\succeq) = \\begin{cases}         \\hphantom{-}1 & \\textrm{} S \\cup \\{\\} \\succ S\\\\         -1 & \\textrm{} S \\succ S \\cup \\{\\}\\\\         \\hphantom{-}0 & \\textrm{otherwise}     \\end{cases} \\end{equation}\\] (Ordinal Banzhaf relation) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). Ordinal Banzhaf relation binary relation \\(R^\\succeq_\\textrm{Banz} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{Banz}j \\Leftrightarrow \\text{Score}_\\text{Banz}() \\geq \\text{Score}_\\text{Banz}(j), \\end{equation}\\] \\(\\text{Score}_\\text{Banz}() = \\sum_{S} m^S_i(\\succeq)\\) \\(S \\N\\setminus\\{\\}\\). Note \\(S \\cup \\{\\} \\notin \\mathcal{P}\\), \\(m_i^S(\\succeq) = 0\\). function ordinalBanzhafScores returns two numbers element: number coalitions \\(S\\) player’s contribution positive impact, number coalitions \\(S\\) player’s contribution negative impact. two numbers added elements ranked highest lowest.","code":"pr <- newPowerRelation(   c(1,2),   \">\", c(1),   \">\", c(2) )  # both players 1 and 2 have an Ordinal Banzhaf Score of 1 # therefore they are indifferent to one another ordinalBanzhafScores(pr) ## $`1` ## [1] 1 0 ##  ## $`2` ## [1] 1 0 ##  ## attr(,\"class\") ## [1] \"OrdinalBanzhafScores\" ordinalBanzhafRanking(pr) ## 1 ~ 2 pr <- newPowerRelationFromString(\"ab > a > {} > b\")  # player b has a negative impact on the empty set # -> player b's score is 1 - 1 = 0 # -> player a's score is 2 - 0 = 2 sapply(ordinalBanzhafScores(pr), function(score) sum(score)) ## a b  ## 2 0 ordinalBanzhafRanking(pr) ## a > b"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ch:copeland","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Social Ranking Solutions","what":"Copeland-like method","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Copeland-like method ranking elements based CP-Majority rule strongly inspired Copeland score social choice theory[15]. score element \\(\\N\\) determined amount pairwise CP-Majority winning comparisons \\(R^\\succeq_\\textrm{CP} j\\), minus number losing comparisons \\(j R^\\succeq_\\textrm{CP} \\) elements \\(j \\N \\setminus \\{\\}\\). (Copeland-like relation [10]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). Copeland-like relation binary relation \\(R^\\succeq_\\textrm{Cop} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{Cop}j \\Leftrightarrow \\text{Score}_\\text{Cop}() \\geq \\text{Score}_\\text{Cop}(j), \\end{equation}\\] \\(\\text{Score}_\\text{Cop}() = |\\{j \\N \\setminus \\{\\}: d_{ij}(\\succeq) \\geq d_{ji}(\\succeq)\\}| - |\\{j \\N \\setminus \\{\\}: d_{ij}(\\succeq) \\leq d_{ji}(\\succeq)\\}|\\) copelandScores(pr) returns two numerical values element, positive number winning comparisons (shown \\(\\text{Score}_\\text{Cop}()\\) left) negative number losing comparisons (\\(\\text{Score}_\\text{Cop}()\\) right).","code":"pr <- newPowerRelationFromString(\"(abc ~ ab ~ c ~ a) > (b ~ bc) > ac\") scores <- copelandScores(pr)  # Based on CP-Majority, a>=b and a>=c (+2), but b>=a (-1) scores$a ## [1]  2 -1 sapply(copelandScores(pr), sum) ##  a  b  c  ##  1  0 -1 copelandRanking(pr) ## a > b > c"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ch:kramerSimpson","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Social Ranking Solutions","what":"Kramer-Simpson-like method","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Strongly inspired Kramer-Simpson method social choice theory[16, 17], elements ranked inversely greatest pairwise defeat possible CP-Majority comparisons. (Kramer-Simpson-like relation [10]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). Kramer-Simpson-like relation binary relation \\(R^\\succeq_\\textrm{KS} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{KS}j \\Leftrightarrow \\text{Score}_\\text{KS}() \\leq \\text{Score}_\\text{KS}(j), \\end{equation}\\] \\(\\text{Score}_\\text{KS}() = \\max_j d_{ji}(\\succeq)\\) \\(j \\N \\setminus \\{\\}\\). kramerSimpsonScores(pr) returns single numerical value element, sorted lowest highest gives us ranking solution. small caveat Definition 8. default function compare \\(d_{ii}(\\succeq)\\). terms, score every element maximum CP-Majority comparison score elements. slightly different definition found [10], CP-Majority comparison \\(d_{ii}(\\succeq)\\) also considered. Since definition \\(d_{ii}(\\succeq) = 0\\), Kramer-Simpson scores cases never negative, possibly discarding valuable information. still account original definition [10], functions kramerSimpsonScores kramerSimpsonRanking offer compIvsI parameter can set TRUE one wishes \\(d_{ii}(\\succeq)\\) included comparisons.","code":"pr <- newPowerRelationFromString(\"(abc ~ ab ~ c ~ a) > (b ~ bc) > ac\") unlist(kramerSimpsonScores(pr)) ## a b c  ## 0 0 1 kramerSimpsonRanking(pr) ## a ~ b > c pr <- newPowerRelationFromString(   \"b > (a ~ c) > ab > (ac ~ bc) > {} > abc\" ) kramerSimpsonRanking(pr) ## b > a > c # notice how b's score is negative unlist(kramerSimpsonScores(pr)) ##  a  b  c  ##  1 -1  2 kramerSimpsonScores(pr, elements = \"b\", compIvsI = TRUE) ## $b ## [1] 0 ##  ## attr(,\"class\") ## [1] \"KramerSimpsonScores\""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"ch:lexcel","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Social Ranking Solutions","what":"Lexicographical Excellence Solution","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"idea behind lexicographical excellence solution (Lexcel) reward elements appearing frequently higher ranked equivalence classes. given power relation \\(\\succeq\\) quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\), denote \\(i_k\\) number coalitions \\(\\sum_k\\) containing \\(\\): \\[\\begin{equation}     i_k = |\\{S \\\\textstyle \\sum_k: \\S\\}| \\end{equation}\\] \\(k \\\\{1, \\dots, m\\}\\). Now, let \\(\\text{Score}_\\text{Lex}()\\) \\(m\\)-dimensional vector \\(\\text{Score}_\\text{Lex}() = (i_1, \\dots, i_m)\\) associated \\(\\succeq\\). Consider lexicographic order \\(\\geq_\\textrm{Lex}\\) among vectors \\(\\mathbf{}\\) \\(\\mathbf{j}\\): \\(\\mathbf{} \\geq_\\textrm{Lex} \\mathbf{j}\\) either \\(\\mathbf{} = \\mathbf{j}\\) exists \\(t : i_r = j_r, r \\\\{1,\\dots,t-1\\}\\), \\(i_t > j_t\\). (Lexicographic-Excellence relation [8]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\) corresponding quotient order \\(\\sum_1 \\succ \\dots \\succ \\sum_m\\). Lexicographic-Excellence relation binary relation \\(R^\\succeq_\\textrm{Lex} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{Lex}j \\Leftrightarrow \\text{Score}_\\text{Lex}() \\geq_{\\textrm{Lex}} \\text{Score}_\\text{Lex}(j) \\end{equation}\\] generalizations Lexcel solution see also [9]. Lexcel score vectors similar cumulative score vectors (see section Cumulative Dominance) number times element appears given equivalence class interest. fact, applying base function cumsum element’s lexcel score gives us cumulative score.","code":"pr <- newPowerRelationFromString(   \"12 > (123 ~ 23 ~ 3) > (1 ~ 2) > 13\",   asWhat = as.numeric )  # show the number of times an element appears in each equivalence class # e.g. 3 appears 3 times in [[2]] and 1 time in [[4]] lapply(pr$equivalenceClasses, unlist) ## [[1]] ## [1] 1 2 ##  ## [[2]] ## [1] 1 2 3 2 3 3 ##  ## [[3]] ## [1] 1 2 ##  ## [[4]] ## [1] 1 3 lexScores <- lexcelScores(pr) for(i in names(lexScores))   paste0(\"Lexcel score of element \", i, \": \", lexScores[i])  # at index 1, element 2 ranks higher than 3 lexScores['2'] > lexScores['3'] ## [1] TRUE # at index 2, element 2 ranks higher than 1 lexScores['2'] > lexScores['1'] ## [1] TRUE lexcelRanking(pr) ## 2 > 1 > 3 lexcelCumulated <- lapply(lexScores, cumsum) cumulScores <- cumulativeScores(pr)  paste0(names(lexcelCumulated), \": \", lexcelCumulated, collapse = ', ') ## [1] \"1: 1:4, 2: c(1, 3, 4, 4), 3: c(0, 3, 3, 4)\" paste0(names(cumulScores), \": \", cumulScores, collapse = ', ') ## [1] \"1: 1:4, 2: c(1, 3, 4, 4), 3: c(0, 3, 3, 4)\""},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"dual-lexicographical-excellence-solution","dir":"Articles","previous_headings":"SocialRankingSolution Objects > Social Ranking Solutions","what":"Dual Lexicographical Excellence Solution","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"Similar Lexcel ranking, Dual Lexcel also uses Lexcel score vectors definition 9 establish ranking. However, instead rewarding higher frequencies high ranking coalitions, punishes higher frequencies lower ranking coalitions, , punishes mediocrity[14]. Take values \\(i_k\\) \\(k \\\\{1, \\dots, m\\}\\) Lexcel score vector \\(\\text{Score}_\\text{Lex}()\\) section Lexicographical Excellence Solution. Consider dual lexicographical order \\(\\geq_\\textrm{DualLex}\\) among vectors \\(\\mathbf{}\\) \\(\\mathbf{j}\\): \\(\\mathbf{} \\geq_\\textrm{DualLex} \\mathbf{j}\\) either \\(\\mathbf{} = \\mathbf{j}\\) exists \\(t: i_t < j_t\\) \\(i_r = j_r, r\\\\{t+1, \\dots, m\\}\\). (Dual Lexicographical-Excellence relation [14]) Let \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\). Dual Lexicographic-Excellence relation binary relation \\(R^\\succeq_\\textrm{DualLex} \\subseteq N \\times N\\) \\(,j \\N\\): \\[\\begin{equation}     iR^\\succeq_\\textrm{DualLex}j \\Leftrightarrow \\text{Score}_\\text{Lex}() \\geq_\\textrm{DualLex} \\text{Score}_\\text{Lex}(j) \\end{equation}\\] S3 class LexcelScores account Dual Lexcel comparisons. Instead -rev(x) called Lexcel score vector x resulting comparisons produces Dual Lexcel ranking solution.","code":"pr <- newPowerRelationFromString(   \"12 > (123 ~ 23 ~ 3) > (1 ~ 2) > 13\",   asWhat = as.numeric )  lexScores <- lexcelScores(pr)  # in regular Lexcel, 1 scores higher than 3 lexScores['1'] > lexScores['3'] ## [1] TRUE # turn Lexcel score into Dual Lexcel score dualLexScores <- structure(   lapply(lexcelScores(pr), function(r) -rev(r)),   class = 'LexcelScores' )  # now 1 scores lower than 3 dualLexScores['1'] > dualLexScores['3'] ## [1] FALSE # element 2 comes out at the top in both Lexcel and Dual Lexcel lexcelRanking(pr) ## 2 > 1 > 3 dualLexcelRanking(pr) ## 2 > 3 > 1"},{"path":[]},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"incidence-matrix","dir":"Articles","previous_headings":"Relations","what":"Incidence Matrix","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"vignette focused intuitive aspects power relations social ranking solutions. reiterate, power relation total preorder, reflexive transitive relation \\(\\succeq \\\\mathcal{P} \\times \\mathcal{P}\\), \\(\\sim\\) denotes symmetric part \\(\\succ\\) asymmetric part. power relation can viewed incidence matrix \\((b_{ij}) = B \\\\{0,1\\}^{|\\mathcal{P}| \\times |\\mathcal{P}|}\\). Given two coalitions \\(, j \\\\mathcal{P}\\), \\(iRj\\) \\(b_{ij} = 1\\), else \\(0\\). help relations package, functions relations::.relation(pr) powerRelationMatrix(pr) turn PowerRelation object relation object. relations offers ways display relation object incidence matrix relation_incidence(rel) test basic properties relation_is_linear_order(rel), relation_is_acyclic(rel) relation_is_antisymmetric(rel) (see relations package [11]). Note columns rows sorted names relation_domain(rel), hence name preceded ordering number.","code":"pr <- newPowerRelationFromString(\"ab > a > {} > b\") rel <- relations::as.relation(pr)  relations::relation_incidence(rel) ## Incidences: ##    ab ​a ​​{} ​​​b ## ab  1 1  1 1 ## ​a   0 1  1 1 ## ​​{}  0 0  1 1 ## ​​​b   0 0  0 1 c(   relations::relation_is_acyclic(rel),   relations::relation_is_antisymmetric(rel),   relations::relation_is_linear_order(rel),   relations::relation_is_complete(rel),   relations::relation_is_reflexive(rel),   relations::relation_is_transitive(rel) ) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE # a power relation where coalitions {1} and {2} are indifferent pr <- newPowerRelationFromString(\"12 > (1 ~ 2)\", asWhat = as.numeric) rel <- relations::as.relation(pr)  # we have both binary relations {1}R{2} as well as {2}R{1} relations::relation_incidence(rel) ## Incidences: ##    12 ​1 ​​2 ## 12  1 1 1 ## ​1   0 1 1 ## ​​2   0 1 1 # FALSE c(   relations::relation_is_acyclic(rel),   relations::relation_is_antisymmetric(rel),   relations::relation_is_linear_order(rel),   relations::relation_is_complete(rel),   relations::relation_is_reflexive(rel),   relations::relation_is_transitive(rel) ) ## [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE"},{"path":"https://jassler.github.io/socialranking/articles/socialranking_pdf.html","id":"cycles-and-transitive-closure","dir":"Articles","previous_headings":"Relations","what":"Cycles and Transitive Closure","title":"`socialranking`: A package for evaluating ordinal power relations in cooperative game theory","text":"cycle power relation exists, one coalition \\(S \\2^N\\) appears twice. example, \\(\\{1,2\\} \\succ (\\{1\\} \\sim \\emptyset) \\succ \\{1,2\\}\\), coalition \\(\\{1,2\\}\\) appears beginning end power relation. Properly handling power relations calculating social ranking solutions cycles somewhat ill-defined, hence warning message shown soon one created. Recall power relation transitive, meaning three coalitions \\(x, y, z \\2^N\\), \\(xRy\\) \\(yRz\\), \\(xRz\\). introduce cycles, pretty much introduce symmetry. Assume power relation \\(x \\succ y \\succ x\\). , even though \\(xRy\\) \\(yRx\\) defined asymmetric part power relation \\(\\succeq\\), together form symmetric power relation \\(x \\sim y\\). transitiveClosure(pr) function turns power relation cycles one without one. process removing duplicate coalitions, turns asymmectric relations within cycle symmetric relations.","code":"newPowerRelation(c(1,2), \">\", 2, \">\", 1, \"~\", 2, \">\", c(1,2)) ## Warning in newPowerRelation(c(1, 2), \">\", 2, \">\", 1, \"~\", 2, \">\", c(1, 2)): Found the following duplicates. Did you mean to introduce cycles? ##   {2} ##   {1, 2} ## Elements: 1 2 ## 12 > 2 > (1 ~ 2) > 12 pr <- suppressWarnings(newPowerRelation(1, '>', 2, '>', 1)) pr ## Elements: 1 2 ## 1 > 2 > 1 transitiveClosure(pr) ## Elements: 1 2 ## (1 ~ 2) # two cycles, (1>3>1) and (2>23>2) pr <- suppressWarnings(   newPowerRelationFromString(     \"1 > 3 > 1 > 2 > 23 > 2\",     asWhat = as.numeric   ) )  transitiveClosure(pr) ## Elements: 1 2 3 ## (1 ~ 3) > (2 ~ 23) # overlapping cycles pr <- suppressWarnings(   newPowerRelationFromString(\"c > ac > b > ac > (a ~ b) > abc\") )  transitiveClosure(pr) ## Elements: a b c ## c > (ac ~ b ~ a) > abc"},{"path":[]},{"path":"https://jassler.github.io/socialranking/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Felix Fritz. Author, maintainer. Jochen Staudacher. Author, copyright holder, thesis advisor. Moretti Stefano. Author, copyright holder, thesis advisor.","code":""},{"path":"https://jassler.github.io/socialranking/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Fritz F, Staudacher J, Stefano M (2022). socialranking: Social Ranking Solutions Power Relations Coalitions. R package version 0.1.2, https://jassler.github.io/socialranking/.","code":"@Manual{,   title = {socialranking: Social Ranking Solutions for Power Relations on Coalitions},   author = {Felix Fritz and Jochen Staudacher and Moretti Stefano},   year = {2022},   note = {R package version 0.1.2},   url = {https://jassler.github.io/socialranking/}, }"},{"path":"https://jassler.github.io/socialranking/index.html","id":"socialranking","dir":"","previous_headings":"","what":"Social Ranking Solutions for Power Relations on Coalitions","title":"Social Ranking Solutions for Power Relations on Coalitions","text":"package socialranking offers functions represent ordinal information coalitions calculate power relation elements players.","code":""},{"path":"https://jassler.github.io/socialranking/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Social Ranking Solutions for Power Relations on Coalitions","text":"Install package directly CRAN : can also install development version socialranking GitHub :","code":"install.packages(\"socialranking\") # install.packages(\"devtools\") devtools::install_github(\"jassler/socialranking\")"},{"path":"https://jassler.github.io/socialranking/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Social Ranking Solutions for Power Relations on Coalitions","text":"package socialranking offers functions represent ordinal information coalitions calculate power relation elements players. installed, call library(socialranking) load package current environment. newPowerRelation() newPowerRelationFromString() creates PowerRelation object. createPowerset() convenient function generate newPowerRelation() function call possible coalitions. functions used analyze power relations can grouped comparison functions, score functions ranking solutions. Ranking solutions produce SocialRankingSolution object. ^1 cpMajorityComparisonScore() faster alternative cpMajorityComparison(), produces less data. PowerRelation objects can turned relations objects relations package using powerRelationMatrix() .relation(). Use browseVignettes(\"socialranking\") information.","code":"library(socialranking) if(interactive()) {   createPowerset(1:3, copyToClipboard = TRUE) }  # pasted, rearranged, adjusted comparators pr <- newPowerRelation(   c(1,2,3),   \">\", c(1,2),   \"~\", c(1,3),   \">\", c(2),   \"~\", c(2,3),   \">\", c(1),   \">\", c(3) )  # equivalent pr <- newPowerRelation(   rankingCoalitions = list(c(1,2,3), c(1,2), c(1,3), c(2), c(2,3), c(1), c(3)),   rankingComparators = c(\">\", \"~\", \">\", \"~\", \">\", \">\") )  # equivalent pr <- newPowerRelationFromString(\"123 > 12 ~ 13 > 2 ~ 23 > 1 > 3\", asWhat = as.numeric) pr #> Elements: 1 2 3 #> 123 > (12 ~ 13) > (2 ~ 23) > 1 > 3  pr$elements #> [1] 1 2 3 pr$equivalenceClasses[[2]] #> [[1]] #> {1, 2} #>  #> [[2]] #> {1, 3} dominates(pr, 1, 2) #> [1] FALSE  copelandRanking(pr) #> 1 ~ 2 > 3  lexcelScores(pr, 1) #> $`1` #> [1] 1 2 0 1 0 #>  #> attr(,\"class\") #> [1] \"LexcelScores\""},{"path":"https://jassler.github.io/socialranking/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Social Ranking Solutions for Power Relations on Coalitions","text":"package licensed GPL-3.","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.default.html","id":null,"dir":"Reference","previous_headings":"","what":"PowerRelation object — PowerRelation.default","title":"PowerRelation object — PowerRelation.default","text":"Use newPowerRelation() newPowerRelationFromString() create PowerRelation object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PowerRelation object — PowerRelation.default","text":"","code":"# S3 method for default PowerRelation(x, ...)"},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PowerRelation object — PowerRelation.default","text":"x object ... Arguments passed methods","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PowerRelation object — PowerRelation.default","text":"return value.","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":null,"dir":"Reference","previous_headings":"","what":"PowerRelation object — PowerRelation","title":"PowerRelation object — PowerRelation","text":"Use newPowerRelation() newPowerRelationFromString() create PowerRelation object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PowerRelation object — PowerRelation","text":"","code":"PowerRelation(x, ...)  is.PowerRelation(x, ...)  # S3 method for PowerRelation print(x, ...)"},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PowerRelation object — PowerRelation","text":"x object ... Arguments passed methods","code":""},{"path":"https://jassler.github.io/socialranking/reference/PowerRelation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PowerRelation object — PowerRelation","text":"return value.","code":""},{"path":"https://jassler.github.io/socialranking/reference/SocialRankingSolution.default.html","id":null,"dir":"Reference","previous_headings":"","what":"SocialRankingSolution object — SocialRankingSolution.default","title":"SocialRankingSolution object — SocialRankingSolution.default","text":"Use doRanking() create SocialRankingSolution object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/SocialRankingSolution.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SocialRankingSolution object — SocialRankingSolution.default","text":"","code":"# S3 method for default SocialRankingSolution(x, ...)"},{"path":"https://jassler.github.io/socialranking/reference/SocialRankingSolution.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SocialRankingSolution object — SocialRankingSolution.default","text":"x object ... Arguments passed methods","code":""},{"path":"https://jassler.github.io/socialranking/reference/SocialRankingSolution.default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SocialRankingSolution object — SocialRankingSolution.default","text":"return value.","code":""},{"path":"https://jassler.github.io/socialranking/reference/SocialRankingSolution.html","id":null,"dir":"Reference","previous_headings":"","what":"SocialRankingSolution object — SocialRankingSolution","title":"SocialRankingSolution object — SocialRankingSolution","text":"Use doRanking() create SocialRankingSolution object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/SocialRankingSolution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SocialRankingSolution object — SocialRankingSolution","text":"","code":"SocialRankingSolution(x, ...)"},{"path":"https://jassler.github.io/socialranking/reference/SocialRankingSolution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SocialRankingSolution object — SocialRankingSolution","text":"x object ... Arguments passed methods","code":""},{"path":"https://jassler.github.io/socialranking/reference/SocialRankingSolution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SocialRankingSolution object — SocialRankingSolution","text":"return value.","code":""},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":null,"dir":"Reference","previous_headings":"","what":"Are coalitions indifferent — coalitionsAreIndifferent","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"Check coalitions indifferent one another, , appear equivalence class.","code":""},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"","code":"coalitionsAreIndifferent(powerRelation, c1, c2)"},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"powerRelation PowerRelation object created newPowerRelation() c1 Coalition vector sets::set() c2 Coalition vector sets::set()","code":""},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"Logical value TRUE c1 c2 equivalence class, else FALSE.","code":""},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"equivalenceClassIndex() called determine, equivalence class c1 c2 belong . returns TRUE equivalence class. either coalition c1 c2 part power relation, error thrown.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/coalitionsAreIndifferent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are coalitions indifferent — coalitionsAreIndifferent","text":"","code":"pr <- newPowerRelation(c(1,2), \">\", c(1), \"~\", c(2))  # FALSE coalitionsAreIndifferent(pr, c(1,2), c(1)) #> [1] FALSE  # TRUE coalitionsAreIndifferent(pr, 2, 1) #> [1] TRUE  # Error: The coalition {} does not appear in the power relation tryCatch(   equivalenceClassIndex(pr, c()),   error = function(e) { e } ) #> <simpleError in equivalenceClassIndex(pr, c()): The coalition {} does not appear in the power relation>"},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Copeland-like method — copelandScores","title":"Copeland-like method — copelandScores","text":"Based cpMajorityComparison(), add subtract scores based element fares others. copelandRanking returns corresponding ranking.","code":""},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copeland-like method — copelandScores","text":"","code":"copelandScores(powerRelation, elements = NULL)  copelandRanking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copeland-like method — copelandScores","text":"powerRelation PowerRelation object created newPowerRelation() elements vector elements calculate scores. elements == NULL, create vectors elements pr$elements","code":""},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copeland-like method — copelandScores","text":"Score function returns list type CopelandScores length powerRelation$elements (unless parameter elements specified). element vector 2 numbers, number pairwise winning comparisons number pairwise losing comparisons. two numbers summed together gives us actual ordinal Copeland score. Ranking function returns corresponding SocialRankingSolution object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Copeland-like method — copelandScores","text":"Strongly inspired Copeland score social choice theory (Copeland 1951) , Copeland-like solution based net flow CP-majority graph (Allouche et al. 2020) . Individuals ordered according number pairwise winning comparisons, minus number pairwise losing comparisons, set CP-comparisons. formally, given PowerRelation pr element \\(\\), count number elements \\(j \\N \\setminus \\lbrace \\rbrace\\) cpMajorityComparison(pr, , j) >= 0 subtract cpMajorityComparison(pr, , j) <= 0.","code":""},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Copeland-like method — copelandScores","text":"Allouche T, Escoffier B, Moretti S, Öztürk M (2020). “Social Ranking Manipulability CP-Majority, Banzhaf Lexicographic Excellence Solutions.” Bessiere C (ed.), Proceedings Twenty-Ninth International Joint Conference Artificial Intelligence, IJCAI-20, 17--23. doi:10.24963/ijcai.2020/3 , Main track. Copeland AH (1951). “reasonable social welfare function.” mimeo, 1951. University Michigan.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/copelandScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Copeland-like method — copelandScores","text":"","code":"# (123 ~ 12 ~ 3 ~ 1) > (2 ~ 23) > 13 pr <- newPowerRelation(   c(1,2,3),   \"~\", c(1,2),   \"~\", c(3),   \"~\", c(1),   \">\", c(2),   \"~\", c(2,3),   \">\", c(1,3) )  # `1` = 1 # `2` = 0 # `3` = -1 copelandScores(pr) #> $`1` #> [1]  2 -1 #>  #> $`2` #> [1]  2 -2 #>  #> $`3` #> [1]  1 -2 #>  #> attr(,\"class\") #> [1] \"CopelandScores\"  # only calculate results for two elements # `1` = 1 # `3` = -1 copelandScores(pr, c(1,3)) #> $`1` #> [1]  2 -1 #>  #> $`3` #> [1]  1 -2 #>  #> attr(,\"class\") #> [1] \"CopelandScores\"  # or just one element copelandScores(pr, 2) #> $`2` #> [1]  2 -2 #>  #> attr(,\"class\") #> [1] \"CopelandScores\"  # 1 > 2 > 3 copelandRanking(pr) #> 1 > 2 > 3"},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":null,"dir":"Reference","previous_headings":"","what":"CP-Majority relation — cpMajorityComparison","title":"CP-Majority relation — cpMajorityComparison","text":"Ceteris Paribus-majority relation compares relative success two players joining coalition. cpMajorityComparisonScore() returns two numbers, positive number coalitions e1 beats e2, negative number coalitions e1 beaten e2.","code":""},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CP-Majority relation — cpMajorityComparison","text":"","code":"cpMajorityComparison(   powerRelation,   e1,   e2,   strictly = FALSE,   includeEmptySet = TRUE )  cpMajorityComparisonScore(   powerRelation,   e1,   e2,   strictly = FALSE,   includeEmptySet = TRUE )"},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CP-Majority relation — cpMajorityComparison","text":"powerRelation PowerRelation object created newPowerRelation() e1, e2 Elements powerRelation$elements strictly include \\(D_{ij}(\\succ)\\) \\(D_{ji}(\\succ)\\), .e., coalitions \\(S \\2^{N \\setminus \\lbrace ,j\\rbrace}\\) \\(S \\cup \\lbrace \\rbrace \\succ S \\cup \\lbrace j\\rbrace\\) vice versa. includeEmptySet TRUE, check \\(\\lbrace \\rbrace \\succeq \\lbrace j \\rbrace\\) even empty set part power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CP-Majority relation — cpMajorityComparison","text":"cpMajorityComparison() returns list elements described details. cpMajorityComparisonScore() returns vector two numbers, positive number coalitions e1 beats e2 (\\(d_{ij}(\\succeq)\\)), negative number coalitions e1 beaten e2 (\\(-d_{ji}(\\succeq)\\)).","code":""},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CP-Majority relation — cpMajorityComparison","text":"Given two elements \\(\\) \\(j\\), go coalition \\(S \\2^{N \\setminus \\lbrace , j \\rbrace}\\). \\(D_{ij}(\\succeq)\\) contains coalitions \\(S\\) \\(S \\cup \\lbrace \\rbrace \\succeq S \\cup \\lbrace j \\rbrace\\) \\(D_{ji}(\\succeq)\\) contains coalitions \\(S \\cup \\lbrace j \\rbrace \\succeq S \\cup \\lbrace \\rbrace\\). cardinalities \\(d_{ij}(\\succeq) = |D_{ij}|\\) \\(d_{ji}(\\succeq) = |D_{ji}|\\) represent score two elements, \\(\\succ j\\)    \\(d_{ij}(\\succeq)   >  d_{ji}(\\succeq)\\) \\(\\sim  j\\)    \\(d_{ij}(\\succeq)  ==  d_{ji}(\\succeq)\\). cpMajorityComparison() tries retain information. list returned contains following information. Note context two elements \\(\\) \\(j\\) refer element 1 element 2 respectively. $e1: list information element 1 $e1$name: name element 1 $e1$score: score \\(d_{ij}(\\succeq)\\). \\(d_{ij}(\\succ)\\) strictly == TRUE $e1$winningCoalitions: list coalition sets::sets \\(S \\D_{ij}(\\succeq)\\). \\(S \\D_{ij}(\\succ)\\) strictly == TRUE $e2: list information element 2 $e2$name: name element 2 $e1$score: score \\(d_{ji}(\\succeq)\\). \\(d_{ji}(\\succ)\\) strictly == TRUE $e1$winningCoalitions: list coalition sets::sets \\(S \\D_{ji}(\\succeq)\\).  \\(S \\D_{ji}(\\succ)\\) strictly == TRUE $winner: name higher scoring element. NULL indifferent. $loser: name lower scoring element. NULL indifferent. $tuples: list coalitions \\(S \\2^{N \\setminus \\lbrace , j \\rbrace }\\) : $tuples[[x]]$coalition: sets::set, coalition \\(S\\) $tuples[[x]]$included: logical, TRUE \\(S \\cup \\lbrace \\rbrace\\) \\(S \\cup \\lbrace j \\rbrace\\) power relation $tuples[[x]]$winner: name winning element \\(\\) \\(S \\cup \\lbrace \\rbrace \\succ S \\cup \\lbrace j \\rbrace\\). NULL \\(S \\cup \\lbrace \\rbrace \\sim S \\cup \\lbrace j \\rbrace\\) $tuples[[x]]$e1: index \\(x_1\\) \\(S \\cup \\lbrace \\rbrace \\\\sum_{x_1}\\) $tuples[[x]]$e2: index \\(x_2\\) \\(S \\cup \\lbrace j \\rbrace \\\\sum_{x_2}\\) much efficient cpMajorityComparisonScore() calculates $e1$score. Unlike Lexcel, Ordinal Banzhaf, etc., power relation can introduce cycles. reason function cpMajorityComparison() cpMajorityComparisonScore() offers direct comparisons two elements ranking players. See CP-majority based functions offer way rank players.","code":""},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"CP-Majority relation — cpMajorityComparison","text":"Haret , Khani H, Moretti S, Öztürk M (2018). “Ceteris paribus majority social ranking.” 27th International Joint Conference Artificial Intelligence (IJCAI-ECAI-18), 303--309. Fayard N, Escoffier MÖ (2018). “Ordinal Social ranking: simulation CP-majority rule.” DA2PL'2018 (Multiple Criteria Decision Aid Preference Learning).","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/cpMajorityComparison.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CP-Majority relation — cpMajorityComparison","text":"","code":"pr <- newPowerRelationFromString(\"ac > (a ~ b) > (c ~ bc)\")  # a > b # D_ab = {c, {}} # D_ba = {{}} # Score of a = 2 # Score of b = 1 scores <- cpMajorityComparison(pr, \"a\", \"b\") stopifnot(scores$e1$name == \"a\") stopifnot(scores$e2$name == \"b\") stopifnot(scores$e1$score == 2) stopifnot(scores$e2$score == 1) stopifnot(scores$e1$score == length(scores$e1$winningCoalitions)) stopifnot(scores$e2$score == length(scores$e2$winningCoalitions))  # get tuples with coalitions S in 2^(N - {i,j}) emptySetTuple <- Filter(function(x) x$coalition == sets::set(), scores$tuples)[[1]] playerCTuple  <- Filter(function(x) x$coalition == sets::set(\"c\"), scores$tuples)[[1]]  # because {} u a ~ {} u b, there is no winner stopifnot(is.null(emptySetTuple$winner)) stopifnot(emptySetTuple$e1 == emptySetTuple$e2)  # because c u a > c u b, player \"a\" gets the score stopifnot(playerCTuple$winner == \"a\") stopifnot(playerCTuple$e1 < playerCTuple$e2) stopifnot(playerCTuple$e1 == 1L) stopifnot(playerCTuple$e2 == 3L)  cpMajorityComparisonScore(pr, \"a\", \"b\") # c(1,0) #> [1]  2 -1 cpMajorityComparisonScore(pr, \"b\", \"a\") # c(0,-1) #> [1]  1 -2"},{"path":"https://jassler.github.io/socialranking/reference/createPowerset.html","id":null,"dir":"Reference","previous_headings":"","what":"Create powerset — createPowerset","title":"Create powerset — createPowerset","text":"Given vector elements generate newPowerRelation()-valid function call possible coalitions.","code":""},{"path":"https://jassler.github.io/socialranking/reference/createPowerset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create powerset — createPowerset","text":"","code":"createPowerset(   elements,   copyToClipboard = FALSE,   writeLines = FALSE,   includeEmptySet = TRUE )"},{"path":"https://jassler.github.io/socialranking/reference/createPowerset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create powerset — createPowerset","text":"elements vector elements copyToClipboard Copy code string clipboard writeLines Write code string console includeEmptySet TRUE, empty vector added end","code":""},{"path":"https://jassler.github.io/socialranking/reference/createPowerset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create powerset — createPowerset","text":"List power set vectors. copyToClipboard = TRUE, returns nothing copies function-call string clipboard. writeLines = TRUE, returns nothing prints function-call string ready copy-pasted.","code":""},{"path":"https://jassler.github.io/socialranking/reference/createPowerset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create powerset — createPowerset","text":"","code":"if(interactive()) {   createPowerset(1:3, copyToClipboard = TRUE)   createPowerset(c(\"a\", \"b\", \"c\", \"d\"), writeLines = TRUE, includeEmptySet = FALSE) }  # without copyToClipboard or writeLines set to TRUE, it returns a list createPowerset(c(\"Alice\", \"Bob\"), includeEmptySet = FALSE) #> [[1]] #> [1] \"Alice\" \"Bob\"   #>  #> [[2]] #> [1] \"Alice\" #>  #> [[3]] #> [1] \"Bob\" #>  ## [[1]] ## [1] \"Alice\" \"Bob\" ## ## [[2]] ## [1] \"Alice\" ## ## [[3]] ## [1] \"Bob\""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative scores — cumulativeScores","title":"Cumulative scores — cumulativeScores","text":"Calculate cumulative score vectors element.","code":""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative scores — cumulativeScores","text":"","code":"cumulativeScores(powerRelation, elements = NULL)  cumulativelyDominates(powerRelation, e1, e2, strictly = FALSE)"},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative scores — cumulativeScores","text":"powerRelation PowerRelation object created newPowerRelation() elements vector elements calculate scores. elements == NULL, create vectors elements pr$elements e1, e2 Elements powerRelation$elements strictly TRUE, check p1 strictly dominates p2","code":""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative scores — cumulativeScores","text":"Score function returns list type CumulativeScores length powerRelation$elements (unless parameter elements specified). index contains vector length powerRelation$equivalenceClasses, cumulatively counting number times given element appears equivalence class. cumulativelyDominates() returns TRUE e1 cumulatively dominates e2.","code":""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative scores — cumulativeScores","text":"element's cumulative score vector calculated cumulatively adding amount times appears equivalence class powerRelation. E.g. linear power relation eight coalitions, element 1 appears coalitions placed 1, 3, 6, score vector [1, 1, 2, 2, 2, 3, 3, 3].","code":""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"dominance","dir":"Reference","previous_headings":"","what":"Dominance","title":"Cumulative scores — cumulativeScores","text":"\\(\\) dominates \\(j\\) index \\(x, \\textrm{Score}()_x \\geq \\textrm{Score}(j)_x\\). \\(\\) strictly dominates \\(j\\), additionally \\(\\textrm{Score}() \\neq \\textrm{Score}(j)\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cumulative scores — cumulativeScores","text":"Moretti S (2015). “axiomatic approach social ranking coalitional power relations.” Homo Oeconomicus, 32(2), 183--208. Moretti S, Öztürk M (2017). “axiomatic algorithmic perspectives social ranking problem.” International Conference Algorithmic Decision Theory, 166--181. Springer.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/cumulativeScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative scores — cumulativeScores","text":"","code":"pr <- newPowerRelationFromString(\"12 > 1 > 2\", asWhat = as.numeric)  # `1`: c(1, 2, 2) # `2`: c(1, 1, 2) cumulativeScores(pr) #> $`1` #> [1] 1 2 2 #>  #> $`2` #> [1] 1 1 2 #>  #> attr(,\"class\") #> [1] \"CumulativeScores\"  # calculate for selected number of elements cumulativeScores(pr, c(2)) #> $`2` #> [1] 1 1 2 #>  #> attr(,\"class\") #> [1] \"CumulativeScores\"  # TRUE d1 <- cumulativelyDominates(pr, 1, 2)  # TRUE d2 <- cumulativelyDominates(pr, 1, 1)  # FALSE d3 <- cumulativelyDominates(pr, 1, 1, strictly = TRUE)  stopifnot(all(d1, d2, !d3))"},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":null,"dir":"Reference","previous_headings":"","what":"Create SocialRankingSolution — doRanking","title":"Create SocialRankingSolution — doRanking","text":"Map power relation coalitions power relation elements, also known social ranking solution.","code":""},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create SocialRankingSolution — doRanking","text":"","code":"doRanking(   powerRelation,   scores,   isIndifferent = function(a, b) a == b,   decreasing = TRUE )"},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create SocialRankingSolution — doRanking","text":"powerRelation PowerRelation object created newPowerRelation() scores sortable vector list element scores isIndifferent function returns TRUE, given two elements scores order matter. case two elements indifferent , symbolized \"~\" operator. decreasing TRUE (default), elements higher scores ranked higher.","code":""},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create SocialRankingSolution — doRanking","text":"list type SocialRankingSolution. element list contains sets::set() elements powerRelation indifferent one another.","code":""},{"path":"https://jassler.github.io/socialranking/reference/doRanking.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create SocialRankingSolution — doRanking","text":"","code":"pr <- newPowerRelationFromString(\"2 > 12 > 1\", asWhat = as.numeric)  # we define our own social ranking solution. # a player's score is determined by the equivalence class index it first appears in. # lower is better scores <- c(`1` = 2, `2` = 1)  # 2 > 1 doRanking(   pr,   scores,   isIndifferent = function(x, y) x == y,   decreasing = FALSE ) #> 2 > 1  # Suppose for a player to be ranked higher than the other, # their positions have to be at least 2 apart. # This means player 1 and 2 are indifferent, # if they are right next to each other in the power relation. # 2 ~ 1 doRanking(   pr,   scores,   isIndifferent = function(x, y) abs(x - y) < 2,   decreasing = FALSE ) #> 1 ~ 2"},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":null,"dir":"Reference","previous_headings":"","what":"Domination — dominates","title":"Domination — dominates","text":"Test one element dominates .","code":""},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Domination — dominates","text":"","code":"dominates(powerRelation, e1, e2, strictly = FALSE, includeEmptySet = TRUE)"},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Domination — dominates","text":"powerRelation PowerRelation object created newPowerRelation() e1, e2 Elements powerRelation$elements strictly TRUE, check p1 strictly dominates p2 includeEmptySet TRUE, check \\(\\lbrace \\rbrace \\succeq \\lbrace j \\rbrace\\) even empty set part power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Domination — dominates","text":"Logical value TRUE e1 dominates e2, else FALSE.","code":""},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Domination — dominates","text":"\\(\\) said dominate \\(j\\), \\(S \\cup \\lbrace \\rbrace \\succeq S \\cup \\lbrace j \\rbrace\\) \\(S \\2^{N \\setminus \\lbrace ,j \\rbrace}\\). \\(\\) strictly dominates \\(j\\), exists one \\(S \\2^{N \\setminus \\lbrace ,j \\rbrace}\\) \\(S \\cup \\lbrace \\rbrace \\succ S \\cup \\lbrace j \\rbrace\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/dominates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Domination — dominates","text":"","code":"pr <- newPowerRelationFromString(\"12 > 1 > 2\", asWhat = as.numeric)  # TRUE d1 <- dominates(pr, 1, 2)  # FALSE d2 <- dominates(pr, 2, 1)  # TRUE (because it's not strict dominance) d3 <- dominates(pr, 1, 1)  # FALSE d4 <- dominates(pr, 1, 1, strictly = TRUE)  stopifnot(all(d1, !d2, d3, !d4))"},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":null,"dir":"Reference","previous_headings":"","what":"Get index of equivalence class containing a coalition — equivalenceClassIndex","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"Given coalition vector sets::set(), return singular index number equivalence class located .","code":""},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"","code":"equivalenceClassIndex(powerRelation, coalition, stopIfNotExists = TRUE)"},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"powerRelation PowerRelation object created newPowerRelation() coalition coalition vector sets::set part powerRelation stopIfNotExists TRUE error thrown coalition given PowerRelation object. FALSE, -1 returned","code":""},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"Numeric value, equivalence class index coalition appears .","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/equivalenceClassIndex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get index of equivalence class containing a coalition — equivalenceClassIndex","text":"","code":"pr <- newPowerRelation(c(1,2), \">\", c(1), \"~\", c(2))  # 1 equivalenceClassIndex(pr, c(1, 2)) #> [1] 1  # 2 equivalenceClassIndex(pr, c(1)) #> [1] 2  # 2 equivalenceClassIndex(pr, c(2)) #> [1] 2  # Error: The coalition {} does not appear in the power relation tryCatch(   equivalenceClassIndex(pr, c()),   error = function(e) { e } ) #> <simpleError in equivalenceClassIndex(pr, c()): The coalition {} does not appear in the power relation>  # Error: This time only return a -1 stopifnot(-1 == equivalenceClassIndex(pr, c(), stopIfNotExists = FALSE))"},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Kramer-Simpson-like method — kramerSimpsonScores","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"Calculate Kramer-Simpson-like scores. Lower scores better. kramerSimpsonRanking returns corresponding ranking.","code":""},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"","code":"kramerSimpsonScores(powerRelation, elements = NULL, compIvsI = FALSE)  kramerSimpsonRanking(powerRelation, compIvsI = FALSE)"},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"powerRelation PowerRelation object created newPowerRelation() elements vector elements calculate scores. elements == NULL, create vectors elements pr$elements compIvsI TRUE, include CP-Majority comparison \\(d_{ii}(\\succeq)\\), , CP-Majority comparison score element , always 0.","code":""},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"Score function returns list type KramerSimpsonScores length powerRelation$elements (unless parameter elements specified). Lower scoring elements ranked higher. Ranking function returns corresponding SocialRankingSolution object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"Inspired Kramer-Simpson method social choice theory (Simpson 1969)  (Kramer 1975) , Kramer-Simpson-like method compares element elements using CP-Majority rule. given element \\(\\) calculate cpMajorityComparisonScore elements \\(j\\), \\(d_{ji}(\\succeq)\\) (notice \\(\\) \\(j\\) reverse order). \\(\\max_{j \\N \\setminus \\lbrace \\rbrace}(d_{ji}(\\succeq))\\) determines final score, lower scoring elements ranked higher.","code":""},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"default function compare \\(d_{ii}(\\succeq)\\). terms, score every element maximum CP-Majority comparison score elements. slightly different definitions found (Allouche et al. 2020) . Since definition  \\(d_{ii}(\\succeq) = 0\\) always holds, Kramer-Simpson scores cases never negative, possibly discarding valuable information. reason kramerSimpsonScores kramerSimpsonRanking includes compIvsI parameter can set TRUE one wishes \\(d_{ii}(\\succeq) = 0\\) included comparisons. Put mathematical terms, :","code":""},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"Allouche T, Escoffier B, Moretti S, Öztürk M (2020). “Social Ranking Manipulability CP-Majority, Banzhaf Lexicographic Excellence Solutions.” Bessiere C (ed.), Proceedings Twenty-Ninth International Joint Conference Artificial Intelligence, IJCAI-20, 17--23. doi:10.24963/ijcai.2020/3 , Main track. Simpson PB (1969). “defining areas voter choice: Professor Tullock stable voting.” Quarterly Journal Economics, 83(3), 478--490. Kramer GH (1975). “dynamical model political equilibrium.” Journal Economic Theory, 16(2), 310--334.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/kramerSimpsonScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kramer-Simpson-like method — kramerSimpsonScores","text":"","code":"# 2 > (1 ~ 3) > 12 > (13 ~ 23) > {} > 123 pr <- newPowerRelation(   2,   \">\", 1,   \"~\", 3,   \">\", c(1,2),   \">\", c(1,3),   \"~\", c(2,3),   \">\", c(),   \">\", c(1,2,3) )  # get scores for all elements # cpMajorityComparisonScore(pr, 2, 1) = 1 # cpMajorityComparisonScore(pr, 3, 1) = -1 # therefore the Kramer-Simpson-Score for element # `1` = 1 # # Score analogous for the other elements # `2` = -1 # `3` = 2 kramerSimpsonScores(pr) #> $`1` #> [1] 1 #>  #> $`2` #> [1] -1 #>  #> $`3` #> [1] 2 #>  #> attr(,\"class\") #> [1] \"KramerSimpsonScores\"  # get scores for two elements # `1` = 1 # `3` = 2 kramerSimpsonScores(pr, c(1,3)) #> $`1` #> [1] 1 #>  #> $`3` #> [1] 2 #>  #> attr(,\"class\") #> [1] \"KramerSimpsonScores\"  # or single element # result is still a list kramerSimpsonScores(pr, 2) #> $`2` #> [1] -1 #>  #> attr(,\"class\") #> [1] \"KramerSimpsonScores\"  # note how the previous result of element 2 is negative. # If we compare element 2 against itself, its max score will be 0 kramerSimpsonScores(pr, 2, compIvsI = TRUE) #> $`2` #> [1] 0 #>  #> attr(,\"class\") #> [1] \"KramerSimpsonScores\"  # 2 > 1 > 3 kramerSimpsonRanking(pr) #> 2 > 1 > 3"},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Lexicographical Excellence — lexcelScores","title":"Lexicographical Excellence — lexcelScores","text":"Calculate Lexicographical Excellence (Lexcel) score. lexcelRanking returns corresponding ranking. dualLexcelRanking uses score vectors instead rewarding participation, punishes mediocrity.","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lexicographical Excellence — lexcelScores","text":"","code":"lexcelScores(powerRelation, elements = NULL)  lexcelRanking(powerRelation)  dualLexcelRanking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lexicographical Excellence — lexcelScores","text":"powerRelation PowerRelation object created newPowerRelation() elements vector elements calculate scores. elements == NULL, create vectors elements pr$elements","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lexicographical Excellence — lexcelScores","text":"Score function returns list type LexcelScores length powerRelation$elements (unless parameter elements specified). index contains vector length powerRelation$equivalenceClasses, number times given element appears equivalence class. Ranking function returns corresponding SocialRankingSolution object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lexicographical Excellence — lexcelScores","text":"equivalence class \\(\\sum_i\\) holds coalitions indifferent one another. given power relation created newPowerRelation(), equivalence classes saved $equivalenceClasses. E.g. power relation defined \\(123 \\succ (12 \\sim 13 \\sim 1 \\sim \\emptyset) \\succ (23 \\sim 1 \\sim 2)\\) get following equivalence classes: \\(\\sum_1 = \\lbrace 123 \\rbrace\\), \\(\\sum_2 = \\lbrace 12, 13, 1, \\emptyset \\rbrace\\), \\(\\sum_3 = \\lbrace 23, 1, 2 \\rbrace\\). Lexcel score element vector index counts number times appears equivalence class. get: \\(\\textrm{lexcel}(1) = [ 1, 3, 1 ]\\), \\(\\textrm{lexcel}(2) = [ 1, 1, 2 ]\\), \\(\\textrm{lexcel}(3) = [ 1, 1, 1 ]\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"lexcel-ranking","dir":"Reference","previous_headings":"","what":"Lexcel Ranking","title":"Lexicographical Excellence — lexcelScores","text":"\"excellent contribution\" element determines ranking elements. Given two Lexcel score vectors \\(\\textrm{Score}()\\) \\(\\textrm{Score}(j)\\), first index \\(x\\) \\(\\textrm{Score}()_x \\neq \\textrm{Score}(j)_x\\) determines element ranked higher. previous example \\(1 > 2 > 3\\), : \\(\\textrm{Score}(1)_2 = 3 > \\textrm{Score}(2)_2 = \\textrm{Score}(3)_2 = 1\\), \\(\\textrm{Score}(2)_3 = 2 > \\textrm{Score}(3)_3 = 1\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"dual-lexcel-ranking","dir":"Reference","previous_headings":"","what":"Dual Lexcel Ranking","title":"Lexicographical Excellence — lexcelScores","text":"dual lexcel works reverse order , instead rewarding high scores, punishes mediocrity. case get \\(3 > 1 > 2\\) : \\(\\textrm{Score}(3)_3 < \\textrm{Score}(2)_3\\) \\(\\textrm{Score}(3)_2 < \\textrm{Score}(1)_2\\), \\(\\textrm{Score}(1)_3 < \\textrm{Score}(2)_3\\).","code":""},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lexicographical Excellence — lexcelScores","text":"Bernardi G, Lucchetti R, Moretti S (2019). “Ranking objects preference relation subsets.” Social Choice Welfare, 52(4), 589--606. Algaba E, Moretti S, Rémila E, Solal P (2021). “Lexicographic solutions coalitional rankings.” Social Choice Welfare, 57(4), 1--33. Serramia M, López-Sánchez M, Moretti S, Rodríguez-Aguilar JA (2021). “dominant set selection problem application value alignment.” Autonomous Agents Multi-Agent Systems, 35(2), 1--38.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/lexcelScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lexicographical Excellence — lexcelScores","text":"","code":"# note that the coalition {1} appears twice # 123 > 12 ~ 13 ~ 1 ~ {} > 23 ~ 1 ~ 2 # E = {123} > {12, 13, 1, {}} > {23, 1, 2} pr <- suppressWarnings(newPowerRelation(   c(1,2,3),   \">\", c(1,2), \"~\", c(1,3), \"~\", 1, \"~\", c(),   \">\", c(2,3), \"~\", 1, \"~\", 2 ))  # lexcel scores for all elements # `1` = c(1, 3, 1) # `2` = c(1, 1, 2) # `3` = c(1, 1, 1) lexcelScores(pr) #> $`1` #> [1] 1 3 1 #>  #> $`2` #> [1] 1 1 2 #>  #> $`3` #> [1] 1 1 1 #>  #> attr(,\"class\") #> [1] \"LexcelScores\"  # lexcel scores for a subset of all elements lexcelScores(pr, c(1, 3)) #> $`1` #> [1] 1 3 1 #>  #> $`3` #> [1] 1 1 1 #>  #> attr(,\"class\") #> [1] \"LexcelScores\" lexcelScores(pr, 2) #> $`2` #> [1] 1 1 2 #>  #> attr(,\"class\") #> [1] \"LexcelScores\"  # 1 > 2 > 3 lexcelRanking(pr) #> 1 > 2 > 3  # 3 > 1 > 2 dualLexcelRanking(pr) #> 3 > 1 > 2"},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":null,"dir":"Reference","previous_headings":"","what":"New Power Relation — newPowerRelation","title":"New Power Relation — newPowerRelation","text":"Create PowerRelation object based coalition parameters separated \">\" \"~\".","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"New Power Relation — newPowerRelation","text":"","code":"newPowerRelation(   ...,   rankingCoalitions = list(),   rankingComparators = c(),   equivalenceClasses = list() )"},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"New Power Relation — newPowerRelation","text":"... Coalition vector, comparison character (\">\" \"~\"), coalition vector, comparison character, coalition vector, ... rankingCoalitions List ordered coalition vectors. empty, ignored. Corresponds $rankingCoalitions list PowerRelation object. rankingComparators Vector \">\" \"~\" characters. rankingCoalitions list empty, ignored. vector empty, uses \">\" relation default. equivalenceClasses Nested list coalition vectors indifferent another. empty, ignored.","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"New Power Relation — newPowerRelation","text":"PowerRelation object containing vector elements players $elements, ordered list coalitions $rankingCoalitions ordered vector comparators $rankingComparators well ordered list equivalence classes $equivalenceClasses convenience","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"New Power Relation — newPowerRelation","text":"power relation describes ordinal information coalitions. createPowerset() offers convenient way creating powerset set elements can used call newPowerRelation() function. coalition case put separate line (see example). RStudio allows us easily rearrange coalitions using Alt+Alt+shortcut (Option+Option+MacOS). coalition vector sets::set(). Every vector turned sets::set().","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":"mathematical-background","dir":"Reference","previous_headings":"","what":"Mathematical background","title":"New Power Relation — newPowerRelation","text":"Let \\(N = \\lbrace 1, ..., n \\rbrace\\) finite set elements (sometimes also called players). \\(2^N\\) describes powerset \\(N\\), set subsets, also coalitions. Let \\(\\mathcal{P} \\subseteq 2^N\\) collection coalitions. power relation \\(\\mathcal{P}\\) total preorder \\(\\succeq \\subseteq \\mathcal{P} \\times \\mathcal{P}\\). , \\(\\mathcal{T}(\\mathcal{P})\\) denotes family power relations every collection \\(\\mathcal{P} \\subseteq 2^N\\). Given power relation \\(\\succeq \\\\mathcal{T}(\\mathcal{P})\\), \\(\\sim\\) denotes symmetric part whereas \\(\\succ\\) asymmetric part. example, let \\(S, T \\\\mathcal{P}\\). : \\[S \\sim T \\textrm{ } S \\succeq T \\textrm{ } T \\succeq S\\] \\[S \\succ T \\textrm{ } S \\succeq T \\textrm{ } T \\succeq S\\]","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"New Power Relation — newPowerRelation","text":"Moretti S, Öztürk M (2017). “axiomatic algorithmic perspectives social ranking problem.” International Conference Algorithmic Decision Theory, 166--181. Springer. Bernardi G, Lucchetti R, Moretti S (2019). “Ranking objects preference relation subsets.” Social Choice Welfare, 52(4), 589--606.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"New Power Relation — newPowerRelation","text":"","code":"if(interactive())   createPowerset(1:3, copyToClipboard = TRUE)  # pasted clipboard and rearranged lines using # Alt + Up, and # Alt + Down shortcut in RStudio pr <- newPowerRelation(   c(1,2),   \">\", c(1,2,3),   \">\", c(1,3),   \"~\", c(2),   \">\", c(1),   \"~\", c(2,3),   \"~\", c(3), )  # Elements: 1 2 3 # 12 > 123 > (13 ~ 2) > (1 ~ 23 ~ 3) print(pr) #> Elements: 1 2 3 #> 12 > 123 > (13 ~ 2) > (1 ~ 23 ~ 3)  # {1, 2, 3} pr$elements #> [1] 1 2 3  # {1, 2}, {1, 2, 3}, {1, 3}, {2}, {1}, {2, 3}, {3} pr$rankingCoalitions #> [[1]] #> {1, 2} #>  #> [[2]] #> {1, 2, 3} #>  #> [[3]] #> {1, 3} #>  #> [[4]] #> {2} #>  #> [[5]] #> {1} #>  #> [[6]] #> {2, 3} #>  #> [[7]] #> {3} #>   # \">\" \">\" \"~\" \">\" \">\" \">\" pr$rankingComparators #> [1] \">\" \">\" \"~\" \">\" \"~\" \"~\"  # {{1, 2}}, {{1, 2, 3}}, {{1, 3}, {2}}, {{1}, {2, 3}, {3}} pr$equivalenceClasses #> [[1]] #> [[1]][[1]] #> {1, 2} #>  #>  #> [[2]] #> [[2]][[1]] #> {1, 2, 3} #>  #>  #> [[3]] #> [[3]][[1]] #> {1, 3} #>  #> [[3]][[2]] #> {2} #>  #>  #> [[4]] #> [[4]][[1]] #> {1} #>  #> [[4]][[2]] #> {2, 3} #>  #> [[4]][[3]] #> {3} #>  #>   # not all coalitions of a powerset have to be present newPowerRelation(c(1,2), \">\", c(1)) #> Elements: 1 2 #> 12 > 1  # cycles produce a warning (but no errors) newPowerRelation(c(1,2), \">\", c(1), \">\", c(1,2)) #> Warning: Found the following duplicate. Did you mean to introduce cycles? #>   {1, 2} #> Elements: 1 2 #> 12 > 1 > 12  # use createPowerset directly # 123 > 12 > 13 > 23 > 1 > 2 > 3 > {} newPowerRelation(rankingCoalitions = createPowerset(1:3)) #> Elements: 1 2 3 #> 123 > 12 > 13 > 23 > 1 > 2 > 3 > {}  # 123 > (12 ~ 13) > (23 ~ 1) > (2 ~ 3) > {} newPowerRelation(rankingCoalitions = createPowerset(1:3), rankingComparators = c(\">\", \"~\")) #> Elements: 1 2 3 #> 123 > (12 ~ 13) > (23 ~ 1) > (2 ~ 3) > {}  # using equivalenceClasses parameter # (12 ~ 13 ~ 123) > (1 ~ 3 ~ {}) > (2 ~ 23) pr <- newPowerRelation(equivalenceClasses = list(   list(c(1,2), c(1,3), c(1,2,3)),   list(1, 3, c()),   list(2, c(2,3)) )) # and manipulating the order of the equivalence classes # (1 ~ 3 ~ {}) > (2 ~ 23) > (12 ~ 13 ~ 123) newPowerRelation(equivalenceClasses = pr$equivalenceClasses[c(2,3,1)]) #> Elements: 1 2 3 #> (1 ~ 3 ~ {}) > (2 ~ 23) > (12 ~ 13 ~ 123)   # It's discouraged to directly change the ordering of a power relation inside a # PowerRelation object. Instead extract rankingCoalitions, rearrange the list # and pass it to newPowerRelation newOrdering <- rev(pr$rankingCoalitions)  # 3 > 23 > (1 ~ 2) > (13 ~ 123 ~ 12) newPowerRelation(rankingCoalitions = newOrdering, rankingComparators = pr$rankingComparators) #> Elements: 1 2 3 #> (23 ~ 2 ~ {}) > (3 ~ 1 ~ 123) > (13 ~ 12)  # 3 > 23 > 1 > 2 > 13 > 123 > 12 newPowerRelation(rankingCoalitions = newOrdering) #> Elements: 1 2 3 #> 23 > 2 > {} > 3 > 1 > 123 > 13 > 12"},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelationFromString.html","id":null,"dir":"Reference","previous_headings":"","what":"Create PowerRelation object from string — newPowerRelationFromString","title":"Create PowerRelation object from string — newPowerRelationFromString","text":"Given pure string representation power relation, create PowerRelation object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelationFromString.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create PowerRelation object from string — newPowerRelationFromString","text":"","code":"newPowerRelationFromString(   string,   elementNames = \"[0-9a-zA-Z]\",   asWhat = identity )"},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelationFromString.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create PowerRelation object from string — newPowerRelationFromString","text":"string String representation power relation. Special characters \\(\\succ\\) \\(\\sim\\) replaced ASCII equivalents > ~ respectively. elementNames Regular expression match single characters string input interpreted name element. character match, simply ignored. asWhat Elements interpreted string characters default. base::.numeric base::.integer can passed convert string characters numeric values.","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelationFromString.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create PowerRelation object from string — newPowerRelationFromString","text":"PowerRelation object containing vector elements players $elements, ordered list coalitions $rankingCoalitions ordered vector comparators $rankingComparators well ordered list equivalence classes $equivalenceClasses convenience","code":""},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelationFromString.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create PowerRelation object from string — newPowerRelationFromString","text":"Elements power relation assumed one character long. E.g., coalitions \"{1,2,3}\" 123 equivalent, given elementNames parameter tells function interpret characters 1, 2 3 valid element names.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/newPowerRelationFromString.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create PowerRelation object from string — newPowerRelationFromString","text":"","code":"# Elements: 1 2 3 # 123 > 12 > 23 > 1 > (13 ~ 2) newPowerRelationFromString(\"123 > 12 > 23 > 1 > 13 ~ 2\", asWhat = as.numeric) #> Elements: 1 2 3 #> 123 > 12 > 23 > 1 > (13 ~ 2)  # commas, braces and spaces are ignored by default # notice that since an empty set is not a valid name of an element, # it is simply ignored. Since there are no valid elements at the # end, it is interpreted as an empty set. newPowerRelationFromString(\"{1,2,3} > {1,3} > {1,2 } ~ \\u2205\", asWhat = as.numeric) #> Elements: 1 2 3 #> 123 > 13 > (12 ~ {})  # use unvoncentional names pr <- newPowerRelationFromString(\".,; > .;~.,~,; > .~,~;\", elementNames = \"[.,;]\") stopifnot(pr$elements == sort(c(\".\", \",\", \";\")))"},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Ordinal Banzhaf — ordinalBanzhafScores","title":"Ordinal Banzhaf — ordinalBanzhafScores","text":"Calculate Ordinal Banzhaf scores, number positive negative marginal contributions. ordinalBanzhafRanking() returns corresponding ranking.","code":""},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ordinal Banzhaf — ordinalBanzhafScores","text":"","code":"ordinalBanzhafScores(powerRelation)  ordinalBanzhafRanking(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ordinal Banzhaf — ordinalBanzhafScores","text":"powerRelation PowerRelation object created newPowerRelation()","code":""},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ordinal Banzhaf — ordinalBanzhafScores","text":"Score function returns list class type OrdinalBanzhafScores length powerRelation$elements. index contains vector two numbers, number positive number negative marginal contributions. two numbers summed together gives us actual ordinal Banzhaf score. Ranking function returns corresponding SocialRankingSolution object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ordinal Banzhaf — ordinalBanzhafScores","text":"Inspired Banzhaf index (Banzhaf III 1964) , Ordinal Banzhaf determines score element \\(\\) adding amount coalitions \\(S \\subseteq N \\setminus \\lbrace \\rbrace\\) contribution impacts positively (\\(S \\cup \\lbrace \\rbrace \\succ S\\)) subtracting amount coalitions contribution negative impact (\\(S \\succ S \\cup \\lbrace \\rbrace\\))(Khani et al. 2019) .","code":""},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Ordinal Banzhaf — ordinalBanzhafScores","text":"Khani H, Moretti S, Öztürk M (2019). “ordinal banzhaf index social ranking.” 28th International Joint Conference Artificial Intelligence (IJCAI 2019), 378--384. Banzhaf III JF (1964). “Weighted voting work: mathematical analysis.” Rutgers L. Rev., 19, 317.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/ordinalBanzhafScores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ordinal Banzhaf — ordinalBanzhafScores","text":"","code":"# 12 > (2 ~ {}) > 1 pr <- newPowerRelation(c(1,2), \">\", 2, \"~\", c(), \">\", 1)  # Player 1 contributes positively to {2} # Player 1 contributes negatively to {empty set} # Therefore player 1 has a score of 1 - 1 = 0 # # Player 2 contributes positively to {1} # Player 2 does NOT have an impact on {empty set} # Therefore player 2 has a score of 1 - 0 = 0 # `1` = c(1, -1) # `2` = c(1, 0) ordinalBanzhafScores(pr) #> $`1` #> [1]  1 -1 #>  #> $`2` #> [1] 1 0 #>  #> attr(,\"class\") #> [1] \"OrdinalBanzhafScores\"  # 1 > 2 ordinalBanzhafRanking(pr) #> 2 > 1"},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create relation matrix — powerRelationMatrix","title":"Create relation matrix — powerRelationMatrix","text":"given PowerRelation object create relations::relation() object.","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create relation matrix — powerRelationMatrix","text":"","code":"powerRelationMatrix(   powerRelation,   domainNames = c(\"pretty\", \"numericPrec\", \"numeric\") )  # S3 method for PowerRelation as.relation(x, ...)"},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create relation matrix — powerRelationMatrix","text":"powerRelation PowerRelation object created newPowerRelation() domainNames row column names formatted? pretty: Coalitions c(1,2) formatted 12. ensure correctly sorted alphabetically, every name preceded certain amount invisible Unicode character \\u200b numericPrec: Coalitions c(1,2) formatted 1{12}, number front curly brace marking sorted spot. less pretty, use Unicode characters. numeric: Drop coalition names, count 1 upwards. number corresponds index powerRelation$rankingCoalitions function(x): custom function passed number 1 length(powerRelation$rankingCoalitions). Must return character object. x PowerRelation object ... parameters (ignored)","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create relation matrix — powerRelationMatrix","text":"relations::relation() object corresponding power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create relation matrix — powerRelationMatrix","text":"Turn PowerRelation object relations::relation() object. incidence matrix can viewed relations::relation_incidence(). columns rows PowerRelation object ordered powerRelation$rankingCoalitions. relations package automatically sorts columns rows domain names, reason parameter domainNames included. way ensure columns rows sorted order power relation.","code":""},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"cycles","dir":"Reference","previous_headings":"","what":"Cycles","title":"Create relation matrix — powerRelationMatrix","text":"PowerRelation object defined transitive. power relation includes cycle, meaning coalition appears twice ranking, coalitions within cycle considered indifferent one another. example, given power relation \\(1 \\succ 2 \\succ 3 \\succ 1 \\succ 12\\), relation somewhat equivalent \\(1 \\sim 2 \\sim 3 \\succ 12\\). way check cycles incidence matrix . Call transitiveClosure() remove cycles PowerRelation object.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/powerRelationMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create relation matrix — powerRelationMatrix","text":"","code":"pr <- newPowerRelation(c(1,2), \">\", 1, \">\", 2) relation <- powerRelationMatrix(pr)  # do relation stuff # Incidence matrix # 111 # 011 # 001 relations::relation_incidence(relation) #> Incidences: #>    12 ​1 ​​2 #> 12  1 1 1 #> ​1   0 1 1 #> ​​2   0 0 1  # all TRUE stopifnot(all(   relations::relation_is_acyclic(relation),   relations::relation_is_antisymmetric(relation),   relations::relation_is_linear_order(relation),   relations::relation_is_complete(relation),   relations::relation_is_reflexive(relation),   relations::relation_is_transitive(relation) ))   # a power relation where coalitions {1} and {2} are indifferent pr <- newPowerRelation(c(1,2), \">\", 1, \"~\", 2) relation <- powerRelationMatrix(pr)  # Incidence matrix # 111 # 011 # 011 relations::relation_incidence(relation) #> Incidences: #>    12 ​1 ​​2 #> 12  1 1 1 #> ​1   0 1 1 #> ​​2   0 1 1  # FALSE stopifnot(!any(   relations::relation_is_acyclic(relation),   relations::relation_is_antisymmetric(relation),   relations::relation_is_linear_order(relation) )) # TRUE stopifnot(all(   relations::relation_is_complete(relation),   relations::relation_is_reflexive(relation),   relations::relation_is_transitive(relation) ))   # a pr with cycles pr <- newPowerRelation(c(1,2), \">\", 1, \">\", 2, \">\", 1) #> Warning: Found the following duplicate. Did you mean to introduce cycles? #>   {1} relation <- powerRelationMatrix(pr)  # Incidence matrix # 1111 # 0111 # 0111 # 0111 relations::relation_incidence(relation) #> Incidences: #>    12 ​1 ​​2 ​​​1 #> 12  1 1 1 1 #> ​1   0 1 1 1 #> ​​2   0 1 1 1 #> ​​​1   0 1 1 1  # custom naming convention relation <- powerRelationMatrix(   pr,   function(x) paste0(letters[x], \":\", paste(pr$rankingCoalitions[[x]], collapse = \"|\")) )  # Incidences: #       a:1|2 b:1 c:2 d:1 # a:1|2     1   1   1   1 # b:1       0   1   1   1 # c:2       0   1   1   1 # d:1       0   1   1   1 relations::relation_incidence(relation) #> Incidences: #>       a:1|2 b:1 c:2 d:1 #> a:1|2     1   1   1   1 #> b:1       0   1   1   1 #> c:2       0   1   1   1 #> d:1       0   1   1   1"},{"path":"https://jassler.github.io/socialranking/reference/socialranking.html","id":null,"dir":"Reference","previous_headings":"","what":"socialranking: A package for constructing ordinal power relations and evaluating social ranking solutions — socialranking","title":"socialranking: A package for constructing ordinal power relations and evaluating social ranking solutions — socialranking","text":"package socialranking offers functions represent ordinal information coalitions calculate power relation elements players.","code":""},{"path":"https://jassler.github.io/socialranking/reference/socialranking.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"socialranking: A package for constructing ordinal power relations and evaluating social ranking solutions — socialranking","text":"newPowerRelation() creates PowerRelation object. createPowerset() convenient function generate newPowerRelation() function call possible coalitions. functions used analyze power relations can grouped comparison functions, score functions ranking solutions. Ranking solutions produce SocialRankingSolution object. ^1 cpMajorityComparisonScore() faster alternative cpMajorityComparison(), produces less data. powerRelationMatrix() uses relations::relation() create incidence matrix competing coalitions. incidence matrix can displayed relations::relation_incidence(). Use browseVignettes(\"socialranking\") information.","code":""},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":null,"dir":"Reference","previous_headings":"","what":"Test relation between two elements — testRelation","title":"Test relation between two elements — testRelation","text":"given PowerRelation object pr, check e1 relates e2 based given social ranking solution.","code":""},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test relation between two elements — testRelation","text":"","code":"testRelation(powerRelation, e1)  powerRelation %:% e1  pr_e1 %>=dom% e2  pr_e1 %>dom% e2  pr_e1 %>=cumuldom% e2  pr_e1 %>cumuldom% e2  pr_e1 %>=cp% e2  pr_e1 %>cp% e2  pr_e1 %>=banz% e2  pr_e1 %>banz% e2  pr_e1 %>=cop% e2  pr_e1 %>cop% e2  pr_e1 %>=ks% e2  pr_e1 %>ks% e2  pr_e1 %>=lex% e2  pr_e1 %>lex% e2  pr_e1 %>=duallex% e2  pr_e1 %>duallex% e2"},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test relation between two elements — testRelation","text":"powerRelation PowerRelation object created newPowerRelation() e1, e2 Elements powerRelation$elements pr_e1 PowerRelation e1 element, packed list using pr %:% e1","code":""},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test relation between two elements — testRelation","text":"testRelation() %:% returns list(powerRelation, e1). Followed %>=comparison% %>comparison% returns TRUE FALSE, depending relation e1 e2.","code":""},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test relation between two elements — testRelation","text":"function testRelation somewhat used make offered comparison operators package better discoverable. testRelation(pr, e1) equivalent pr %:% e1 list(pr, e1). used together one comparison operators listed usage section.","code":""},{"path":[]},{"path":"https://jassler.github.io/socialranking/reference/testRelation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test relation between two elements — testRelation","text":"","code":"pr <- newPowerRelationFromString(   \"123 > 12 ~ 13 > 3 > 1 ~ 2\", asWhat = as.numeric )  # Dominance stopifnot(pr %:% 1 %>=dom% 2)  # Strict dominance stopifnot((pr %:% 1 %>dom% 2) == FALSE)  # Cumulative dominance stopifnot(pr %:% 1 %>=cumuldom% 2)  # Strict cumulative dominance stopifnot(pr %:% 1 %>cumuldom% 2)  # CP-Majority relation stopifnot(pr %:% 1 %>=cp% 2)  # Strict CP-Majority relation stopifnot((pr %:% 1 %>cp% 2) == FALSE)  # Ordinal banzhaf relation stopifnot(pr %:% 1 %>=banz% 2)  # Strict ordinal banzhaf relation # (meaning 1 had a strictly higher positive contribution than 2) stopifnot((pr %:% 1 %>banz% 2) == FALSE)  # Copeland-like method stopifnot(pr %:% 1 %>=cop% 2) stopifnot(pr %:% 2 %>=cop% 1)  # Strict Copeland-like method # (meaning pairwise winning minus pairwise losing comparison of # 1 is strictly higher than of 2) stopifnot((pr %:% 1 %>cop% 2) == FALSE) stopifnot((pr %:% 2 %>cop% 1) == FALSE) stopifnot(pr %:% 3 %>cop% 1)  # Kramer-Simpson-like method stopifnot(pr %:% 1 %>=ks% 2) stopifnot(pr %:% 2 %>=ks% 1)  # Strict Kramer-Simpson-like method # (meaning ks-score of 1 is actually higher than 2) stopifnot((pr %:% 2 %>ks% 1) == FALSE) stopifnot((pr %:% 1 %>ks% 2) == FALSE) stopifnot(pr %:% 3 %>ks% 1)  # Lexicographical and dual lexicographical excellence stopifnot(pr %:% 1 %>=lex% 3) stopifnot(pr %:% 3 %>=duallex% 1)  # Strict lexicographical and dual lexicographical excellence # (meaning their lexicographical scores don't match) stopifnot(pr %:% 1 %>lex% 3) stopifnot(pr %:% 3 %>duallex% 1)"},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":null,"dir":"Reference","previous_headings":"","what":"Transitive Closure — transitiveClosure","title":"Transitive Closure — transitiveClosure","text":"Apply transitive closure power relation cycles.","code":""},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transitive Closure — transitiveClosure","text":"","code":"transitiveClosure(powerRelation)"},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transitive Closure — transitiveClosure","text":"powerRelation PowerRelation object created newPowerRelation()","code":""},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transitive Closure — transitiveClosure","text":"PowerRelation object cycles.","code":""},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transitive Closure — transitiveClosure","text":"power relation binary relationship coalitions transitive. coalitions \\(, b, c \\2^N\\), means \\(\\succ b\\) \\(b \\succ c\\), \\(\\succ c\\). power relation cycles transitive. transitive closure power relation removes cycles turns transitive relation placing coalitions within cycle equivalence class. \\(\\succ b \\succ \\), symmetric definition newPowerRelation() therefore assume \\(\\sim b\\). Similarly \\(\\succ b_1 \\succ b_2 \\succ \\dots \\succ b_n \\succ \\), transitive closure turns \\(\\sim b_1 \\sim b_2 \\sim \\dots \\sim b_n\\). transitiveClosure() transforms PowerRelation object cycles Powerrelation object without cycles. described previous paragraph, coalitions within cycle put equivalence class duplicate coalitions removed.","code":""},{"path":"https://jassler.github.io/socialranking/reference/transitiveClosure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transitive Closure — transitiveClosure","text":"","code":"pr <- newPowerRelation(1, \">\", 2)  # nothing changes transitiveClosure(pr) #> Elements: 1 2 #> 1 > 2   pr <- suppressWarnings(newPowerRelation(1, \">\", 2, \">\", 1))  # 1 ~ 2 transitiveClosure(pr) #> Elements: 1 2 #> (1 ~ 2)   pr <- suppressWarnings(   newPowerRelation(1, \">\", 3, \">\", 1, \">\", 2, \">\", c(2,3), \">\", 2) )  # 1 > 3 > 1 > 2 > 23 > 2 => # 1 ~ 3 > 2 ~ 23 transitiveClosure(pr) #> Elements: 1 2 3 #> (1 ~ 3) > (2 ~ 23)"},{"path":"https://jassler.github.io/socialranking/news/index.html","id":"socialranking-012-2022-10-11","dir":"Changelog","previous_headings":"","what":"socialranking 0.1.2 (2022-10-11)","title":"socialranking 0.1.2 (2022-10-11)","text":"CRAN release: 2022-10-27 Changed maintainer’s email address","code":""},{"path":"https://jassler.github.io/socialranking/news/index.html","id":"socialranking-011-2022-04-25","dir":"Changelog","previous_headings":"","what":"socialranking 0.1.1 (2022-04-25)","title":"socialranking 0.1.1 (2022-04-25)","text":"CRAN release: 2022-04-25 Added parameter equivalenceClasses newPowerRelation()","code":""}]
